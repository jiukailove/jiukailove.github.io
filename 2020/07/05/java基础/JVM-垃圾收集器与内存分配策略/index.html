<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM-垃圾收集器与内存分配策略 | 学习笔记</title><meta name="keywords" content="java基础,jvm"><meta name="author" content="liberxk"><meta name="copyright" content="liberxk"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、怎么判断对象已死？1.1 引用计数算法在对象中添加一个引用计数器， 每当有一个地方引用它时， 计数器值就加一； 当引用失效时， 计数器值就减一； 任何时刻计数器为零的对象就是不可能再被使用的。    主流Java虚拟机并未选用引用计数法，因为它无法解决对象之间的循环引用问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM-垃圾收集器与内存分配策略">
<meta property="og:url" content="http://jiukailove.github.io/2020/07/05/java%E5%9F%BA%E7%A1%80/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/index.html">
<meta property="og:site_name" content="学习笔记">
<meta property="og:description" content="一、怎么判断对象已死？1.1 引用计数算法在对象中添加一个引用计数器， 每当有一个地方引用它时， 计数器值就加一； 当引用失效时， 计数器值就减一； 任何时刻计数器为零的对象就是不可能再被使用的。    主流Java虚拟机并未选用引用计数法，因为它无法解决对象之间的循环引用问题。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images.unsplash.com/photo-1564347208312-4edb9f9a866f?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxfDB8MXxyYW5kb218MHx8fHx8fHx8MTYyNjg4MTU1NQ&ixlib=rb-1.2.1&q=80&utm_campaign=api-credit&utm_medium=referral&utm_source=unsplash_source&w=1080">
<meta property="article:published_time" content="2020-07-05T15:55:39.000Z">
<meta property="article:modified_time" content="2021-08-30T11:54:37.548Z">
<meta property="article:author" content="liberxk">
<meta property="article:tag" content="java基础">
<meta property="article:tag" content="jvm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.unsplash.com/photo-1564347208312-4edb9f9a866f?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=MnwxfDB8MXxyYW5kb218MHx8fHx8fHx8MTYyNjg4MTU1NQ&ixlib=rb-1.2.1&q=80&utm_campaign=api-credit&utm_medium=referral&utm_source=unsplash_source&w=1080"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://jiukailove.github.io/2020/07/05/java%E5%9F%BA%E7%A1%80/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: liberxk","link":"链接: ","source":"来源: 学习笔记","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM-垃圾收集器与内存分配策略',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-30 11:54:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="/self/github.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">学习笔记</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JVM-垃圾收集器与内存分配策略</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-07-05T15:55:39.000Z" title="undefined 2020-07-05 15:55:39">2020-07-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E5%9F%BA%E7%A1%80/">java基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM-垃圾收集器与内存分配策略"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="一、怎么判断对象已死？"><a href="#一、怎么判断对象已死？" class="headerlink" title="一、怎么判断对象已死？"></a>一、怎么判断对象已死？</h2><h3 id="1-1-引用计数算法"><a href="#1-1-引用计数算法" class="headerlink" title="1.1 引用计数算法"></a>1.1 引用计数算法</h3><p>在对象中添加一个引用计数器， 每当有一个地方引用它时， 计数器值就加一； 当引用失效时， 计数器值就减一； 任何时刻计数器为零的对象就是不可能再被使用的。   </p>
<p>主流Java虚拟机并未选用引用计数法，因为它<strong>无法解决对象之间的循环引用问题</strong>。</p>
<span id="more"></span>

<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceCountingGC</span> <span class="token punctuation">&#123;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Object</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ReferenceCountingGC</span> objA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ReferenceCountingGC</span> objB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        objA<span class="token punctuation">.</span>instance <span class="token operator">=</span> objB<span class="token punctuation">;</span>
        objB<span class="token punctuation">.</span>instance <span class="token operator">=</span> objA<span class="token punctuation">;</span>
        
        objA <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        objB <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><p>通过一系列成为<code>GC Roots</code>的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链，如果某个对象到<code>GC Roots</code>间没有任何引用链相连，即从<code>GC Roots</code>到这个对象不可达时，则证明此对象是不可能再次被使用的。</p>
<p>可作为<code>GC Roots</code>的对象包括以下几种：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>方法区中类静态属性的对象，譬如Java类的引用类型静态变量。</li>
<li>方法去中常量引用的对象，譬如字符串常量池里的引用。</li>
<li>本地方法栈中<code>JNI</code>（<code>Navtive</code>方法）引用的对象。</li>
<li>虚拟机内部的引用， 如基本数据类型对应的<code>Class</code>对象， 一些常驻的异常对象（比如<code>NullPointExcepiton</code>、 <code>OutOfMemoryError</code>） 等， 还有系统类加载器。  </li>
<li>所有被同步锁（<code>synchronized</code>关键字） 持有的对象。  </li>
<li>反映<code>Java</code>虚拟机内部情况的<code>JMXBean</code>、 <code>JVMTI</code>中注册的回调、 本地代码缓存等。  </li>
</ol>
<p>除了这些固定的<code>GC Roots</code>集合以外， 根据用户所选用的垃圾收集器以及当前回收的内存区域不同， 还可以有其他对象“临时性”地加入， 共同构成完整<code>GC Roots</code>集合。  </p>
<h3 id="1-3-引用的几种类型"><a href="#1-3-引用的几种类型" class="headerlink" title="1.3 引用的几种类型"></a>1.3 引用的几种类型</h3><ol>
<li><p>强引用</p>
<ul>
<li>最传统的引用定义，代码中普遍存在的</li>
<li>类似<code>Object obj = new Object()</code>这种关系</li>
<li>不论任何情况下，<strong>只要强引用关系还在，该对象永远不会被回收</strong></li>
</ul>
</li>
<li><p>软引用 </p>
<ul>
<li>用来描述一些还有用，但非必须的对象</li>
<li>通过<code>SoftReference</code>类来实现</li>
<li><strong>当前内存足够时不会被回收，不够时才会被回收</strong></li>
</ul>
</li>
<li><p>若引用</p>
<ul>
<li>用来描述非必须对象，强度比软引用更弱，被弱引用关联的对象只能生存到下一次<code>GC</code></li>
<li>通过<code>WeakReference</code>类来实现</li>
<li><strong>不论当前内存是否足够，都会被回收</strong></li>
</ul>
</li>
<li><p>虚引用</p>
<ul>
<li>通过<code>PhantomReference</code>类来实现</li>
<li>一个对象是否有虚引用存在，完全不会对其生存时间构成影响</li>
<li>无法通过虚引用来取得一个对象</li>
<li>为一个对象设置虚引用关联的<strong>唯一目的是为了能在这个对象被垃圾回收时收到一个通知</strong></li>
</ul>
</li>
</ol>
<h3 id="1-4-被可达性分析算法中判定为不可达的对象，就一定是死忙对象吗？"><a href="#1-4-被可达性分析算法中判定为不可达的对象，就一定是死忙对象吗？" class="headerlink" title="1.4 被可达性分析算法中判定为不可达的对象，就一定是死忙对象吗？"></a>1.4 被可达性分析算法中判定为不可达的对象，就一定是死忙对象吗？</h3><p>要宣告一个对象死亡，至少要经历两次标记过程。第一个标记后进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。 假如对象没有覆盖<code>finalize()</code>方法， 或者<code>finalize()</code>方法已经被虚拟机调用过， 那么虚拟机将这两种情况都视为“没有必要执行”。  </p>
<p>如果这个对象被判定为确有必要执行<code>finalize()</code>方法， 那么该对象将会被放置在一个名为<code>F-Queue</code>的队列之中， 并在稍后由一条由虚拟机自动建立的、 低调度优先级的<code>Finalizer</code>线程去执行它们的<code>finalize()</code>方法。   </p>
<p><code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会， 稍后收集器将对<code>F-Queue</code>中的对象进行第二次小规模的标记， 如果对象要在<code>finalize()</code>中成功拯救自己–<strong>只要重新与引用链上的任何一个对象建立关联即可</strong>， 譬如把自己（<code>this</code>关键字） 赋值给某个类变量或者对象的成员变量， 那在第二次标记时它将被移出“即将回收”的集合； 如果对象这时候还没有逃脱， 那基本上它就真的要被回收了。  </p>
<blockquote>
<p>任何一个对象的<code>finalize()</code>方法都只会被系统自动调用一次;并不鼓励使用该方法来拯救对象。</p>
</blockquote>
<h3 id="1-5-方法区的GC"><a href="#1-5-方法区的GC" class="headerlink" title="1.5 方法区的GC"></a>1.5 方法区的<code>GC</code></h3><p>方法区中垃圾收集的性价比是比较低的，虚拟机规范中也并未要求在方法区中实现垃圾回收。</p>
<p>方法区的垃圾收集主要回收两部分内容： 废弃的常量和不再使用的类型。   </p>
<p>判定一个常量是否“废弃”相对简单，来<strong>判断一个类是否属于“不再被使用的类”要同时满足一下三个条件</strong>：</p>
<ol>
<li>该类所有的实例都已经被回收，堆中不存在<strong>该类及其子类</strong>的实例</li>
<li>加载该类的<strong>类加载器</strong>已经被回收，该条件通常很难达成</li>
<li>该类对应的**<code>Class</code>对象**没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ol>
<p>满足上诉条件的类<strong>被允许</strong>进行回收，而不是和对象一样，没有引用了就必然会被回收。</p>
<h2 id="二、垃圾收集算法"><a href="#二、垃圾收集算法" class="headerlink" title="二、垃圾收集算法"></a>二、垃圾收集算法</h2><h3 id="2-1-标记-清除算法"><a href="#2-1-标记-清除算法" class="headerlink" title="2.1 标记-清除算法"></a>2.1 标记-清除算法</h3><p>标记-清除<code>Mark-Sweep</code>算法是最基础的收集算法。算法分类<strong>标记</strong>和<strong>清除</strong>两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象；也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程就是判定对象是否属于垃圾的过程。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/20200705155648.png"></p>
<p>缺点：</p>
<ol>
<li>执行效率不稳定，如果堆中包含大量对象，其中大部分是需要被回收的，这时必须进行大量标记和清除动作，效率随对象的数量增长而降低</li>
<li>内存空间的碎片化问题，标记、清除后会产生大量不连续的内存碎片，碎片太多会导致以后需要较大对象时无法找到足够的连续内存而不得不提前触发另一次<code>GC</code></li>
</ol>
<h3 id="2-2-标记-复制算法"><a href="#2-2-标记-复制算法" class="headerlink" title="2.2 标记-复制算法"></a>2.2 标记-复制算法</h3><p>标记-复制算法常被成为复制算法。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后把已使用的内存空间一次清理掉。</p>
<p>如果内存中多数对象都是存活的， 这种算法将会产生大量的内存间复制的开销， 但对于多数对象都是可回收的情况， 算法需要复制的就是占少数的存活对象， 而且每次都是针对整个半区进行内存回收， 分配内存时也就不用考虑有空间碎片的复杂情况。</p>
<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://liberxk.top/upload/2020/04/image-20200405205317564-4b8cb7a967e5430ab1a608666d3233f9.png" style="zoom:50%;" />

<p>缺点：将可用内存缩小为了原来的一般，太浪费空间。</p>
<h3 id="2-3-标记-整理算法"><a href="#2-3-标记-整理算法" class="headerlink" title="2.3 标记-整理算法"></a>2.3 标记-整理算法</h3><p>标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象；然后将所有存活的对象都想内存空间一端移动，清理掉边界以外的内存。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/20200705155703.png"></p>
<p>如果移动存活对象， 尤其是在老年代这种每次回收都有大量对象存活区域， 移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作， 而且这种对象移动操作必须全程暂停用户应用程序才能进行。这种停顿称为<code>STW</code>，即<code>Stop The World</code>。  </p>
<p>即使不移动对象会使得收集器的效率提升一些， 但因内存分配和访问相比垃圾收集频率要高得多， 这部分的耗时增加， 总吞吐量仍然是下降的。  </p>
<blockquote>
<p>通常标记-清除算法也是需要停顿用户线程来标记、 清理可回收对象的， 只是停顿时间相对而言要来的短而已。  </p>
</blockquote>
<h3 id="2-4-经典垃圾收集器"><a href="#2-4-经典垃圾收集器" class="headerlink" title="2.4 经典垃圾收集器"></a>2.4 经典垃圾收集器</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/20200705155716.png"></p>
<p>如果两个收集器之间存在连线，说明它们可以搭配使用。</p>
<h4 id="2-4-1-Serial收集器"><a href="#2-4-1-Serial收集器" class="headerlink" title="2.4.1 Serial收集器"></a>2.4.1 <code>Serial</code>收集器</h4><p><code>Serial</code>收集器是一个单线程工作的收集器， 但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集程去完成垃圾收集工作， 更重要的是强调在<strong>它进行垃圾收集时， 必须暂停其他所有工作线程</strong>， 直到它收集结束。  </p>
<ul>
<li>依然是HotSpot虚拟机运行在<strong>客户端模式</strong>下的默认新生代收集器  </li>
<li>简单而高效  </li>
<li>对于内存资源受限的环境， 它是所有收集器里额外内存消耗<code>Memory Footprint</code>最小的  </li>
</ul>
<blockquote>
<p>在用户桌面的应用场景以及近年来流行的部分微服务应用中， 分配给虚拟机管理的内存一般来说并不会特别大， 收集几十兆甚至一两百兆的新生代（仅仅是指新生代使用的内存， 桌面应用甚少超过这个容量） ， 垃圾收集的停顿时间完全可以控制在十几、 几十毫秒， 最多一百多毫秒以内， 只要不是频繁发生收集， 这点停顿时间对许多用户来说是完全可以接受的。  </p>
</blockquote>
<h4 id="2-4-2-ParNew收集器"><a href="#2-4-2-ParNew收集器" class="headerlink" title="2.4.2 ParNew收集器"></a>2.4.2 <code>ParNew</code>收集器</h4><p><code>Serial</code>收集器的多线程版本。</p>
<ul>
<li><p>是不少运行在<strong>服务端模式</strong>下的<code>HotSpot</code>虚拟机， 尤其是<code>JDK 7</code>之前的遗留系统中首选的新生代收集器  </p>
</li>
<li><p>除了<code>Serial</code>收集器外， 目前只有它能与<code>CMS</code>收集器配合工作</p>
</li>
</ul>
<h4 id="2-4-3-Parallel-Scavenge收集器"><a href="#2-4-3-Parallel-Scavenge收集器" class="headerlink" title="2.4.3 Parallel Scavenge收集器"></a>2.4.3 <code>Parallel Scavenge</code>收集器</h4><p>Parallel Scavenge收集器也是一款<strong>新生代</strong>收集器， 它同样是基于<strong>标记-复制</strong>算法实现的收集器， 也是<strong>能够并行</strong>收集的多线程收集器，也称为吞吐量优先收集器。</p>
<ul>
<li><p>目标是达到一个<strong>可控制的吞吐量</strong><code>Throughput</code>，<code>CMS</code>等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间  </p>
</li>
<li><p>吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 运行垃圾收集时间 )</p>
</li>
<li><p>垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的  </p>
</li>
<li><p>通过开关<code>+UseAdaptiveSizePolicy  </code>，可不设置新生代大小，Eden与Survivor比例，晋升老年代大小等参数，虚拟机<strong>可自适应调节</strong></p>
</li>
</ul>
<h4 id="2-4-4-Serial-Old收集器"><a href="#2-4-4-Serial-Old收集器" class="headerlink" title="2.4.4 Serial Old收集器"></a>2.4.4 <code>Serial Old</code>收集器</h4><p><code>Serial Old</code>是<code>Serial</code>收集器的老年代版本， 它同样是一个<code>单线程</code>收集器， 使用<code>标记-整理</code>算法。  </p>
<ul>
<li><p>供客户端模式下的<code>HotSpot</code>虚拟机使用  </p>
</li>
<li><p>服务端模式下，在<code>JDK 5</code>以及之前的版本中与<code>Parallel Scavenge</code>收集器搭配使用  </p>
</li>
<li><p>服务端模式下，可作为<code>CMS</code>收集器发生失败时的后备预案， 在并发收集发生<code>Concurrent Mode Failure</code>时使用  </p>
</li>
</ul>
<h4 id="2-4-5-Parallel-Old收集器"><a href="#2-4-5-Parallel-Old收集器" class="headerlink" title="2.4.5 Parallel Old收集器"></a>2.4.5 <code>Parallel Old</code>收集器</h4><p>是<code>Parallel Scavenge</code>收集器的老年代版本， 支持<strong>多线程</strong>并发收集， 基于<strong>标记-整理</strong>算法实现。在注重吞吐量或者处理器资源较为稀缺的场合， 可优先考虑<code>Parallel Scavenge</code>加<code>Parallel Old</code>收集器这个组合。  </p>
<h4 id="2-4-6-CMS收集器"><a href="#2-4-6-CMS收集器" class="headerlink" title="2.4.6 CMS收集器"></a>2.4.6 <code>CMS</code>收集器</h4><p><code>Concurrent Mark Sweep</code>收集器是一种<strong>以获取最短回收停顿时间为目标</strong>的收集器。<code>CMS</code>收集器是基于<strong>标记-清除</strong>算法实现的，整个过程分为四个步骤：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">初始标记 <span class="token operator">></span> 并发标记 <span class="token operator">></span> 重新标记 <span class="token operator">></span> 并发清除<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="2-4-6-1-初始标记"><a href="#2-4-6-1-初始标记" class="headerlink" title="2.4.6.1 初始标记"></a>2.4.6.1 初始标记</h5><p>需要<code>STW</code>，只是标记一下<code>GC Roots</code>能直接关联到的对象，速度很快。</p>
<h5 id="2-4-6-2-并发标记"><a href="#2-4-6-2-并发标记" class="headerlink" title="2.4.6.2 并发标记"></a>2.4.6.2 并发标记</h5><p>从<code>GC Roots</code>的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行  。</p>
<h5 id="2-4-6-3-重新标记"><a href="#2-4-6-3-重新标记" class="headerlink" title="2.4.6.3 重新标记"></a>2.4.6.3 重新标记</h5><p>需要<code>STW</code>，修正并发标记期间， 因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。</p>
<h5 id="2-4-6-4-并发清除"><a href="#2-4-6-4-并发清除" class="headerlink" title="2.4.6.4 并发清除"></a>2.4.6.4 并发清除</h5><p>清理删除掉标记阶段判断的已经死亡的对象， 由于不需要移动存活对象， 所以这个阶段也是可以与用户线程同时并发的。</p>
<h5 id="2-4-6-5-缺点"><a href="#2-4-6-5-缺点" class="headerlink" title="2.4.6.5 缺点"></a>2.4.6.5 缺点</h5><ol>
<li>对处理器资源非常敏感</li>
<li>无法处理标记结束之后的浮动垃圾</li>
<li>会产生大量空间碎片</li>
</ol>
<h4 id="2-4-7-Garbage-First收集器"><a href="#2-4-7-Garbage-First收集器" class="headerlink" title="2.4.7 Garbage First收集器"></a>2.4.7 <code>Garbage First</code>收集器</h4><p><code>G1</code>收集器能够建立<strong>可预测的停顿时间模型</strong>，消耗在垃圾收集上的时间大概率不超过预定的时间目标。</p>
<p><code>G1</code>将连续的堆划分为多个大小相等的区域，每一个<code>Region</code>都可以根据需要，扮演新生代的Eden空间、<code>Survivor</code>空间，或者老年代空间，收集器能够对扮演不同角色的<code>Region</code>采用不同的策略去处理。<code>Region</code>中有一块特殊的<code>Humongous</code>区域，专门用来存储大对象。只要大小超过了一个<code>Region</code>容量一般的对象即可判定为大对象，对于那些超过了整个<code>Region</code>容量的超级大对象，将会被存放在N个连续的<code>Humnogous Region</code>对象中，<code>G1</code>的大多数行为把<code>Humnogous Region</code>作为老年代的一部分看待。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/20200705155732.png"></p>
<p><code>G1</code>收集器之所以能建立可预测的停顿时间模型， 是因为它将<code>Region</code>作为单次回收的最小单元， 即每次收集到的内存空间都是<code>Region</code>大小的整数倍， 这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。 更具体的处理思路是让<code>G1</code>收集器去跟踪各个<code>Region</code>里面的垃圾堆积的<strong>价值</strong>大小， 价值即回收所获得的空间大小以及回收所需时间的经验值， 然后在后台维护一个<strong>优先级列表</strong>， 每次根据用户设定允许的收集停顿时间（使用参数<code>-XX： MaxGCPauseMillis</code>指定， 默认值是200毫秒） ， 优先处理回收价值收益最大的那些<code>Region</code>， 这也就是<code>Garbage First</code>名字的由来。这种使用<code>Region</code>划分内存空间， 以及具有优先级的区域回收方式， 保证了<code>G1</code>收集器在有限的时间内获取尽可能高的收集效率。  </p>
<p>程序要继续运行就肯定会持续有新对象被创建， <code>G1</code>为每一个<code>Region</code>设计了两个名为<code>TAMS（Top at Mark Start）</code>的指针， 把<code>Region</code>中的一部分空间划分出来用于并发回收过程中的新对象分配， 并发回收时新分配的对象地址都必须要在这两个指针位置以上。 <code>G1</code>收集器默认在这个地址以上的对象是被隐式标记过的， 即默认它们是存活的， 不纳入回收范围。如果内存回收的速度赶不上内存分配的速度，<code>G1</code>收集器也要被迫冻结用户线程执行， 导致<code>Full GC</code>而产生长时间<code>Stop The World</code>。  </p>
<p>如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作） ， <code>G1</code>收集器的运作过程大致可划分为以下四个步骤：  </p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">初始标记 <span class="token operator">></span> 并发标记 <span class="token operator">></span> 最终标记 <span class="token operator">></span> 筛选回收<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="2-4-7-1-初始标记"><a href="#2-4-7-1-初始标记" class="headerlink" title="2.4.7.1 初始标记"></a>2.4.7.1 初始标记</h5><p>仅仅只是标记一下<code>GC Roots</code>能直接关联到的对象， 并且修改<code>TAMS</code>指针的值， 让下一阶段用户线程并发运行时， 能正确地在可用的<code>Region</code>中分配新对象。 这个阶段<strong>需要停顿线程</strong>， 但耗时很短， 而且是<strong>借用进行<code>Minor GC</code>的时候同步完成</strong>的， 所以G1收集器在这个阶段实际并没有额外的停顿。  </p>
<h5 id="2-4-7-2-并发标记"><a href="#2-4-7-2-并发标记" class="headerlink" title="2.4.7.2 并发标记"></a>2.4.7.2 并发标记</h5><p>从<code>GC Root</code>开始对堆中对象进行可达性分析， 递归扫描整个堆里的对象图， 找出要回收的对象， 这阶段耗时较长， 但可与用户程序并发执行。 当对象图扫描完成以后， 还要重新处理<code>SATB</code>记录下的在并发时有引用变动的对象。</p>
<h5 id="2-4-7-3-最终标记"><a href="#2-4-7-3-最终标记" class="headerlink" title="2.4.7.3 最终标记"></a>2.4.7.3 最终标记</h5><p>对用户线程做另一个短暂的暂停， 用于处理并发阶段结束后仍遗留下来的最后那少量的<code>SATB</code>记录，<strong>需要停顿线程</strong>。 </p>
<h5 id="2-4-7-4-筛选回收"><a href="#2-4-7-4-筛选回收" class="headerlink" title="2.4.7.4 筛选回收"></a>2.4.7.4 筛选回收</h5><p>负责更新<code>Region</code>的统计数据， 对各个<code>Region</code>的回收价值和成本进行排序， 根据用户所期望的停顿时间来制定回收计划， 可以自由选择任意多个<code>Region</code>构成回收集， 然后把决定回收的那一部分<code>Region</code>的存活对象复制到空的<code>Region</code>中， 再清理掉整个旧<code>Region</code>的全部空间。 这里的操作涉及存活对象的移动， 是必须<strong>暂停用户线程</strong>， 由多条收集器线程并行完成的。  </p>
<p><code>G1</code>收集器除了并发标记外， 其余阶段也是要完全暂停用户线程的，换言之， 它并非纯粹地追求低延迟， 官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量。</p>
<blockquote>
<p>这里设置的“期望值”必须是符合实际的， 不能异想天开， 毕竟G1是要冻结用户线程来复制对象的， 这个停顿时间再怎么低也得有个限度。 它默认的停顿目标为两百毫秒， 一般来说， 回收阶段占到几十到一百甚至接近两百毫秒都很正常， 但如果我们把停顿时间调得非常低， 譬如设置为二十毫秒， 很可能出现的结果就是由于停顿目标时间太短， 导致每次选出来的回收集只占堆内存很小的一部分， 收集器收集的速度逐渐跟不上分配器分配的速度， 导致垃圾慢慢堆积。 很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间， 但应用运行时间一长就不行了， 最终占满堆引发<code>Full GC</code>反而降低性能， 所以通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。  </p>
</blockquote>
<p>从<code>G1</code>开始， 最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的内存分配速率<code>Allocation Rate</code>， 而不追求一次把整个<code>Java</code>堆全部清理干净。 这样， 应用在分配， 同时收集器在收集， <strong>只要收集的速度能跟得上对象分配的速度</strong>， 那一切就能运作得很完美。 这种新的收集器设计思路从工程实现上看是从<code>G1</code>开始兴起的， 所以说<code>G1</code>是收集器技术发展的一个里程碑。  </p>
<p><code>G1</code>从<strong>整体</strong>来看是基于<strong>标记-整理</strong>算法实现的收集器， 但从<strong>局部</strong>（两个<code>Region</code>之间） 上看又是基于<strong>标记-复制</strong>算法实现， 无论如何， 这两种算法都意味着<code>G1</code>运作期间不会产生内存空间碎片， 垃圾收集完成之后能提供规整的可用内存。 这种特性有利于程序长时间运行， 在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。  </p>
<p>缺点：内存占用和执行负载较高。</p>
<blockquote>
<p>目前在小内存应用上<code>CMS</code>的表现大概率仍然要会优于<code>G1</code>， 而在<strong>大内存应用上</strong><code>G1</code>则大多能发挥其优势， 这个优劣势的Java堆容量平衡点通常在6GB至8GB之间， 当然， 以上这些也仅是经验之谈， 不同应用需要量体裁衣地实际测试才能得出最合适的结论， 随着<code>HotSpot</code>的开发者对<code>G1</code>的不断优化， 也会让对比结果继续向<code>G1</code>倾斜。  </p>
</blockquote>
<h3 id="2-5-低延迟垃圾收集器"><a href="#2-5-低延迟垃圾收集器" class="headerlink" title="2.5 低延迟垃圾收集器"></a>2.5 低延迟垃圾收集器</h3><h4 id="2-5-1-Shenandoah收集器"><a href="#2-5-1-Shenandoah收集器" class="headerlink" title="2.5.1 Shenandoah收集器"></a>2.5.1 <code>Shenandoah</code>收集器</h4><p>只在<code>OpenJDK</code>中提供。</p>
<h4 id="2-5-2-ZGC收集器"><a href="#2-5-2-ZGC收集器" class="headerlink" title="2.5.2 ZGC收集器"></a>2.5.2 <code>ZGC</code>收集器</h4><p><code>ZGC</code>收集器是一款基于<code>Region</code>内存布局的，（暂时）不设分代的， 使用了<strong>读屏障</strong>、 <strong>染色指针</strong>和<strong>内存多重映射</strong>等技术来实现可并发的<strong>标记-整理</strong>算法的， 以低延迟为首要目标的一款垃圾收集器。目标是希望在尽可能对吞吐量影响不太大的前提下， 实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。</p>
<p><code>ZGC</code>的<code>Region</code>具有动态性–动态创建和销毁，以及动态的区域容量大小。<code>ZGC</code>的<code>Region</code>可以具大、 中、 小三类容量：</p>
<ul>
<li>小型<code>Region</code> ：容量固定为2MB， 用于放置小于256KB的小对象。</li>
<li>中型<code>Region</code> ：容量固定为32MB， 用于放置大于等于256KB但小于4MB的对象。</li>
<li>大型<code>Region</code>：容量不固定， 可以动态变化， 但必须为2MB的整数倍， 用于放置4MB或以上的大对象。 每个大型<code>Region</code>中<strong>只会存放一个</strong>大对象， 这也预示着虽然名字叫作“大型<code>Region</code>”， 但**它的实际容量完全有可能小于中型<code>Region</code>**， 最小容量可低至4MB。 大型<code>Region</code>在<code>ZGC</code>的实现中是不会被重分配的， 因为复制一个大对象的代价非常高昂。  </li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/20200705155746.png"></p>
<h5 id="2-5-2-1-染色指针"><a href="#2-5-2-1-染色指针" class="headerlink" title="2.5.2.1 染色指针"></a>2.5.2.1 染色指针</h5><p>染色指针是一种直接将少量额外的信息存储在指针上的技术。<code>ZGC</code>的染色指针是最直接的、 最纯粹的， 它<strong>直接把标记信息记在引用对象的指针上</strong>， 这时， 与其说可达性分析是遍历<strong>对象图</strong>来标记对象， 还不如说是遍历引用图来标记引用了。染色指针将指针的能用来寻址的高4位提取出来存储4个标志信息，通过这些标志位， 虚拟机可以直接从指针中看到其引用对象的三色标记状态、 是否进入了重分配集（即被移动过） 、 是否只能通过<code>finalize()</code>方法才能被访问到。  </p>
<ul>
<li><p>可以使得一旦某个<code>Region</code>的存活对象被移走之后， 这个<code>Region</code>立即就能够被释放和重用掉， 而不必等待整个堆中所有指向该<code>Region</code>的引用都被修正后才能清理</p>
</li>
<li><p>大幅减少在垃圾收集过程中内存屏障的使用数量  </p>
</li>
<li><p>可以作为一种可扩展的存储结构用来记录更多与对象标记、 重定位过程相关的数据， 以便日后进一步提高性能 </p>
</li>
</ul>
<h5 id="2-5-2-2-内存多重映射"><a href="#2-5-2-2-内存多重映射" class="headerlink" title="2.5.2.2 内存多重映射"></a>2.5.2.2 内存多重映射</h5><p>将多个不同的虚拟内存地址映射到同一个物理内存地址上， 这是一种多对一映射， 意味着<code>ZGC</code>在虚拟内存中看到的地址空间要比实际的堆内存容量来得更大。 把染色指针中的标志位看作是地址的分段符， 那只要将这些不同的地址段都映射到同一个物理内存空间， 经过多重映射转换后， 就可以使用染色指针正常进行寻址了。<code>ZGC</code>的多重映射只是它采用染色指针技术的伴生产物， 并不是专门为了实现其他某种特性需求而去做的。  </p>
<h5 id="2-5-2-3-运作过程"><a href="#2-5-2-3-运作过程" class="headerlink" title="2.5.2.3 运作过程"></a>2.5.2.3 运作过程</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">并发标记 <span class="token operator">></span> 并发预备重分配 <span class="token operator">></span> 并发重分配 <span class="token operator">></span> 并发重映射<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol>
<li><p><strong>并发标记</strong>：遍历对象图做可达性分析的阶段，需要短暂停顿，与<code>G1</code>、 <code>Shenandoah</code>不同的是， <code>ZGC</code>的<strong>标记是在指针上</strong>而不是在对象上进行的， 标记阶段会更新染色指针中的<code>Marked 0</code>、 <code>Marked 1</code>标志位。  </p>
</li>
<li><p><strong>并发预备重分配</strong>：根据特定的查询条件统计得出本次收集过程要清理哪些<code>Region</code>， 将这些<code>Region</code>组成重分配集<code>Relocation Set</code>。<code>ZGC</code>划分Region的目的并非为了像G1那样做收益优先的增量回收。 相反， <code>ZGC</code>每次回收都会扫描所有的<code>Region</code>， 用范围更大的扫描成本换取省去<code>G1</code>中记忆集的维护成本。 因此， <code>ZGC</code>的重分配集只是决定了里面的存活对象会被重新复制到其他的<code>Region</code>中，标记过程是<strong>针对全堆</strong>的。</p>
</li>
<li><p><strong>并发重分配</strong>：重分配是<code>ZGC</code>执行过程中的核心阶段， 这个过程要把重分配集中的存活对象复制到新的<code>Region</code>上， 并为重分配集中的每个<code>Region</code>维护一个转发表<code>ForwardTable</code>， 记录从旧对象到新对象的转向关系。 得益于染色指针的支持， <code>ZGC</code>收集器能仅从引用上就明确得知一个对象是否处于重分配集之中， 如果用户线程此时并发访问了位于重分配集中的对象， 这次访问将会被预置的内存屏障所截获， 然后立即根据<code>Region</code>上的转发表记录将访问转发到新复制的对象上， 并同时修正更新该引用的值， 使其直接指向新对象， <code>ZGC</code>将这种行为称为指针的“自愈”<code>Self-Healing</code>能力。   </p>
</li>
<li><p><strong>并发重映射</strong>:重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用。</p>
</li>
</ol>
<h2 id="三、内存分配与回收策略"><a href="#三、内存分配与回收策略" class="headerlink" title="三、内存分配与回收策略"></a>三、内存分配与回收策略</h2><ul>
<li><p><strong>对象优先在<code>Eden</code>分配</strong>：当<code>Eden</code>区没有足够的空间进行分配时，虚拟机将发起一次<code>Minor GC</code></p>
</li>
<li><p><strong>大对象直接进入老年代</strong></p>
</li>
<li><p><strong>长期存活的对象将进入老年代</strong>：虚拟机给每个对象定义了一个对象年龄计数器， 存储在对象头中。 对象通常在<code>Eden</code>区里诞生， 如果经过第一次<code>Minor GC</code>后仍然存活， 并且能被<code>Survivor</code>容纳的话， 该对象会被移动到<code>Survivor</code>空间中， 并且将其对象年龄设为1岁。 对象在<code>Survivor</code>区中每熬过一次<code>Minor GC</code>，年龄就增加1岁， 当它的年龄增加到一定程度（默认为15）， 就会被晋升到老年代中。  </p>
</li>
<li><p><strong>动态对象年龄判定</strong>：如果在<code>Survivor</code>空间中相同年龄所有对象大小的总和大于<code>Survivor</code>空间的一半， 年龄大于或等于该年龄的对象就可以直接进入老年代， 无须等到<code>-XX：MaxTenuringThreshold</code>中要求的年龄。</p>
</li>
<li><p><strong>空间分配担保</strong>：在发生<code>Minor GC</code>之前， 虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间， 如果这个条件成立， 那这一次<code>Minor GC</code>可以确保是安全的。 如果不成立， 则虚拟机会先查看<code>-XX：HandlePromotionFailure</code>参数的设置值是否允许担保失败； 如果允许， 那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于， 将尝试进行一次<code>Minor GC</code>， 尽管这次<code>Minor GC</code>是有风险的； 如果小于， 或者<code>-XX：HandlePromotionFailure</code>设置不允许冒险， 那这时就要改为进行一次<code>Full GC</code>。  </p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">liberxk</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jiukailove.github.io/2020/07/05/java%E5%9F%BA%E7%A1%80/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">http://jiukailove.github.io/2020/07/05/java%E5%9F%BA%E7%A1%80/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://jiukailove.github.io" target="_blank">学习笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E5%9F%BA%E7%A1%80/">java基础</a><a class="post-meta__tags" href="/tags/jvm/">jvm</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/05/java%E5%9F%BA%E7%A1%80/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://images.unsplash.com/photo-1564347208312-4edb9f9a866f?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxfDB8MXxyYW5kb218MHx8fHx8fHx8MTYyNjg4MTU1NQ&amp;ixlib=rb-1.2.1&amp;q=80&amp;utm_campaign=api-credit&amp;utm_medium=referral&amp;utm_source=unsplash_source&amp;w=1080" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM-虚拟机内存模型-运行时数据区</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/03/java%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E5%B9%B6%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://images.unsplash.com/photo-1564347208312-4edb9f9a866f?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxfDB8MXxyYW5kb218MHx8fHx8fHx8MTYyNjg4MTU1NQ&amp;ixlib=rb-1.2.1&amp;q=80&amp;utm_campaign=api-credit&amp;utm_medium=referral&amp;utm_source=unsplash_source&amp;w=1080" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">序列化对象并导入导出</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">liberxk</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">一、怎么判断对象已死？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 引用计数算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 可达性分析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%BC%95%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 引用的几种类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E8%A2%AB%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E4%B8%AD%E5%88%A4%E5%AE%9A%E4%B8%BA%E4%B8%8D%E5%8F%AF%E8%BE%BE%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B0%B1%E4%B8%80%E5%AE%9A%E6%98%AF%E6%AD%BB%E5%BF%99%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 被可达性分析算法中判定为不可达的对象，就一定是死忙对象吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84GC"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 方法区的GC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">二、垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 标记-清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 标记-复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 标记-整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 经典垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1 Serial收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2 ParNew收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.4.3.</span> <span class="toc-text">2.4.3 Parallel Scavenge收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.4.4.</span> <span class="toc-text">2.4.4 Serial Old收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-5-Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.4.5.</span> <span class="toc-text">2.4.5 Parallel Old收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-6-CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.4.6.</span> <span class="toc-text">2.4.6 CMS收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-6-1-%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0"><span class="toc-number">2.4.6.1.</span> <span class="toc-text">2.4.6.1 初始标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-6-2-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0"><span class="toc-number">2.4.6.2.</span> <span class="toc-text">2.4.6.2 并发标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-6-3-%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0"><span class="toc-number">2.4.6.3.</span> <span class="toc-text">2.4.6.3 重新标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-6-4-%E5%B9%B6%E5%8F%91%E6%B8%85%E9%99%A4"><span class="toc-number">2.4.6.4.</span> <span class="toc-text">2.4.6.4 并发清除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-6-5-%E7%BC%BA%E7%82%B9"><span class="toc-number">2.4.6.5.</span> <span class="toc-text">2.4.6.5 缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-7-Garbage-First%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.4.7.</span> <span class="toc-text">2.4.7 Garbage First收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-7-1-%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0"><span class="toc-number">2.4.7.1.</span> <span class="toc-text">2.4.7.1 初始标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-7-2-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0"><span class="toc-number">2.4.7.2.</span> <span class="toc-text">2.4.7.2 并发标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-7-3-%E6%9C%80%E7%BB%88%E6%A0%87%E8%AE%B0"><span class="toc-number">2.4.7.3.</span> <span class="toc-text">2.4.7.3 最终标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-7-4-%E7%AD%9B%E9%80%89%E5%9B%9E%E6%94%B6"><span class="toc-number">2.4.7.4.</span> <span class="toc-text">2.4.7.4 筛选回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E4%BD%8E%E5%BB%B6%E8%BF%9F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 低延迟垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-Shenandoah%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text">2.5.1 Shenandoah收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-ZGC%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">2.5.2 ZGC收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-1-%E6%9F%93%E8%89%B2%E6%8C%87%E9%92%88"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">2.5.2.1 染色指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-2-%E5%86%85%E5%AD%98%E5%A4%9A%E9%87%8D%E6%98%A0%E5%B0%84"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">2.5.2.2 内存多重映射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-3-%E8%BF%90%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.5.2.3.</span> <span class="toc-text">2.5.2.3 运作过程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">3.</span> <span class="toc-text">三、内存分配与回收策略</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/07/25/Nginx/Nginx%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" title="Nginx实现服务器端集群搭建">Nginx实现服务器端集群搭建</a><time datetime="2021-07-25T17:36:15.000Z" title="发表于 2021-07-25 17:36:15">2021-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/07/25/Nginx/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" title="Nginx负载均衡">Nginx负载均衡</a><time datetime="2021-07-25T17:21:55.000Z" title="发表于 2021-07-25 17:21:55">2021-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/07/25/Nginx/Nginx%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/" title="Nginx进阶篇（二）">Nginx进阶篇（二）</a><time datetime="2021-07-25T15:52:46.000Z" title="发表于 2021-07-25 15:52:46">2021-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/07/25/Nginx/Nginx%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/" title="Nginx进阶篇（一）">Nginx进阶篇（一）</a><time datetime="2021-07-25T15:46:19.000Z" title="发表于 2021-07-25 15:46:19">2021-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/07/25/Nginx/Nginx%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%81%9C%E5%92%8C%E5%8D%87%E7%BA%A7/" title="Nginx服务启停和升级">Nginx服务启停和升级</a><time datetime="2021-07-25T15:31:11.000Z" title="发表于 2021-07-25 15:31:11">2021-07-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By liberxk</div><div class="footer_custom_text">Hi, Welcome to my Blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'QIxHNfGbxgw1l2HJJ1W4CB5e-MdYXbMMI',
      appKey: '6xUe77BqRdwmV1g37xY4Xzqr',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>