<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nginx实现服务器端集群搭建</title>
      <link href="/2021/07/25/Nginx/Nginx%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/07/25/Nginx/Nginx%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx实现服务器端集群搭建"><a href="#Nginx实现服务器端集群搭建" class="headerlink" title="Nginx实现服务器端集群搭建"></a>Nginx实现服务器端集群搭建</h1><h2 id="Nginx与Tomcat部署"><a href="#Nginx与Tomcat部署" class="headerlink" title="Nginx与Tomcat部署"></a>Nginx与Tomcat部署</h2><p>前面课程已经将Nginx的大部分内容进行了讲解，我们都知道了Nginx在高并发场景和处理静态资源是非常高性能的，但是在实际项目中除了静态资源还有就是后台业务代码模块，一般后台业务都会被部署在Tomcat，weblogic或者是websphere等web服务器上。那么如何使用Nginx接收用户的请求并把请求转发到后台web服务器？</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1604498725652.png"></p><p>步骤分析:</p><pre class="line-numbers language-none"><code class="language-none">1.准备Tomcat环境，并在Tomcat上部署一个web项目2.准备Nginx环境，使用Nginx接收请求，并把请求分发到Tomat上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="环境准备-Tomcat"><a href="#环境准备-Tomcat" class="headerlink" title="环境准备(Tomcat)"></a>环境准备(Tomcat)</h3><p>浏览器访问:</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;192.168.200.146:8080&#x2F;demo&#x2F;index.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取动态资源的链接地址:</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;192.168.200.146:8080&#x2F;demo&#x2F;getAddress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>本次课程将采用Tomcat作为后台web服务器</p><p>（1）在Centos上准备一个Tomcat</p><pre class="line-numbers language-none"><code class="language-none">1.Tomcat官网地址:https:&#x2F;&#x2F;tomcat.apache.org&#x2F;2.下载tomcat,本次课程使用的是apache-tomcat-8.5.59.tar.gz3.将tomcat进行解压缩mkdir web_tomcattar -zxf apache-tomcat-8.5.59.tar.gz -C &#x2F;web_tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）准备一个web项目，将其打包为war</p><pre class="line-numbers language-none"><code class="language-none">1.将资料中的demo.war上传到tomcat8目录下的webapps包下2.将tomcat进行启动，进入tomcat8的bin目录下.&#x2F;startup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（3）启动tomcat进行访问测试。</p><pre class="line-numbers language-none"><code class="language-none">静态资源: http:&#x2F;&#x2F;192.168.200.146:8080&#x2F;demo&#x2F;index.html动态资源: http:&#x2F;&#x2F;192.168.200.146:8080&#x2F;demo&#x2F;getAddress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="环境准备-Nginx"><a href="#环境准备-Nginx" class="headerlink" title="环境准备(Nginx)"></a>环境准备(Nginx)</h3><p>（1）使用Nginx的反向代理，将请求转给Tomcat进行处理。</p><pre class="line-numbers language-none"><code class="language-none">upstream webservice &#123;server 192.168.200.146:8080;&#125;server&#123;    listen80;    server_name localhost;    location &#x2F;demo &#123;    proxy_pass http:&#x2F;&#x2F;webservice;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）启动访问测试</p><p>学习到这，可能大家会有一个困惑，明明直接通过tomcat就能访问，为什么还需要多加一个nginx，这样不是反而是系统的复杂度变高了么?<br>那接下来我们从两个方便给大家分析下这个问题，</p><p>第一个使用Nginx实现动静分离</p><p>第二个使用Nginx搭建Tomcat的集群</p><h2 id="Nginx实现动静分离"><a href="#Nginx实现动静分离" class="headerlink" title="Nginx实现动静分离"></a>Nginx实现动静分离</h2><p>什么是动静分离?</p><p>动:后台应用程序的业务处理</p><p>静:网站的静态资源(html,javaScript,css,images等文件)</p><p>分离:将两者进行分开部署访问，提供用户进行访问。举例说明就是以后所有和静态资源相关的内容都交给Nginx来部署访问，非静态内容则交个类似于Tomcat的服务器来部署访问。</p><p>为什么要动静分离?</p><p>​    前面我们介绍过Nginx在处理静态资源的时候，效率是非常高的，而且Nginx的并发访问量也是名列前茅，而Tomcat则相对比较弱一些，所以把静态资源交个Nginx后，可以减轻Tomcat服务器的访问压力并提高静态资源的访问速度。</p><p>​    动静分离以后，降低了动态资源和静态资源的耦合度。如动态资源宕机了也不影响静态资源的展示。</p><p>如何实现动静分离?</p><p>实现动静分离的方式很多，比如静态资源可以部署到CDN、Nginx等服务器上，动态资源可以部署到Tomcat,weblogic或者websphere上。本次课程只要使用Nginx+Tomcat来实现动静分离。</p><h3 id="动静分离实现步骤"><a href="#动静分离实现步骤" class="headerlink" title="动静分离实现步骤"></a>动静分离实现步骤</h3><p>1.将demo.war项目中的静态资源都删除掉，重新打包生成一个war包，在资料中有提供。</p><p>2.将war包部署到tomcat中，把之前部署的内容删除掉</p><pre class="line-numbers language-none"><code class="language-none">进入到tomcat的webapps目录下，将之前的内容删除掉将新的war包复制到webapps下将tomcat启动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3.在Nginx所在服务器创建如下目录，并将对应的静态资源放入指定的位置</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1604493947499.png"></p><p>其中index.html页面的内容如下:</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/jquery.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">        <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           $<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'http://192.168.200.133/demo/getAddress'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>               <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#msg"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>images/logo.png<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Nginx如何将请求转发到后端服务器<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>images/mv.png<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4.配置Nginx的静态资源与动态资源的访问</p><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">upstream webservice&#123;   server 192.168.200.146:8080;&#125;server &#123;        listen       80;        server_name  localhost;        #动态资源        location &#x2F;demo &#123;                proxy_pass http:&#x2F;&#x2F;webservice;        &#125;        #静态资源        location ~&#x2F;.*\.(png|jpg|gif|js)&#123;                root html&#x2F;web;                gzip on;        &#125;        location &#x2F; &#123;            root   html&#x2F;web;            index  index.html index.htm;        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.启动测试，访问<a href="http://192.168.200.133/index.html">http://192.168.200.133/index.html</a></p><p>假如某个时间点，由于某个原因导致Tomcat后的服务器宕机了，我们再次访问Nginx,会得到如下效果，用户还是能看到页面，只是缺失了访问次数的统计，这就是前后端耦合度降低的效果，并且整个请求只和后的服务器交互了一次，js和images都直接从Nginx返回，提供了效率，降低了后的服务器的压力。</p><h2 id="Nginx实现Tomcat集群搭建"><a href="#Nginx实现Tomcat集群搭建" class="headerlink" title="Nginx实现Tomcat集群搭建"></a>Nginx实现Tomcat集群搭建</h2><p>在使用Nginx和Tomcat部署项目的时候，我们使用的是一台Nginx服务器和一台Tomcat服务器，效果图如下:</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1604494256017.png"></p><p>那么问题来了，如果Tomcat的真的宕机了，整个系统就会不完整，所以如何解决上述问题，一台服务器容易宕机，那就多搭建几台Tomcat服务器，这样的话就提升了后的服务器的可用性。这也就是我们常说的集群，搭建Tomcat的集群需要用到了Nginx的反向代理和赋值均衡的知识，具体如何来实现?我们先来分析下原理</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1604494269848.png"></p><p>环境准备：</p><p>(1)准备3台tomcat,使用端口进行区分[实际环境应该是三台服务器]，修改server.ml，将端口修改分别修改为8080,8180,8280</p><p>(2)启动tomcat并访问测试，</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;192.168.200.146:8080&#x2F;demo&#x2F;getAddress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;192.168.200.146:8180&#x2F;demo&#x2F;getAddress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;192.168.200.146:8280&#x2F;demo&#x2F;getAddress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(3)在Nginx对应的配置文件中添加如下内容:</p><pre class="line-numbers language-none"><code class="language-none">upstream webservice&#123;        server 192.168.200.146:8080;        server 192.168.200.146:8180;        server 192.168.200.146:8280;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好了，完成了上述环境的部署，我们已经解决了Tomcat的高可用性，一台服务器宕机，还有其他两条对外提供服务，同时也可以实现后台服务器的不间断更新。但是新问题出现了，上述环境中，如果是Nginx宕机了呢，那么整套系统都将服务对外提供服务了，这个如何解决？</p><h2 id="Nginx高可用解决方案"><a href="#Nginx高可用解决方案" class="headerlink" title="Nginx高可用解决方案"></a>Nginx高可用解决方案</h2><p>针对于上面提到的问题，我们来分析下要想解决上述问题，需要面临哪些问题?</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1604495169905.png"></p><pre class="line-numbers language-none"><code class="language-none">需要两台以上的Nginx服务器对外提供服务，这样的话就可以解决其中一台宕机了，另外一台还能对外提供服务，但是如果是两台Nginx服务器的话，会有两个IP地址，用户该访问哪台服务器，用户怎么知道哪台是好的，哪台是宕机了的?<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Keepalived"><a href="#Keepalived" class="headerlink" title="Keepalived"></a>Keepalived</h3><p>使用Keepalived来解决，Keepalived 软件由 C 编写的，最初是专为 LVS 负载均衡软件设计的，Keepalived 软件主要是通过 VRRP 协议实现高可用功能。</p><h3 id="VRRP介绍"><a href="#VRRP介绍" class="headerlink" title="VRRP介绍"></a>VRRP介绍</h3><p>VRRP（Virtual Route Redundancy Protocol）协议，翻译过来为虚拟路由冗余协议。VRRP协议将两台或多台路由器设备虚拟成一个设备，对外提供虚拟路由器IP,而在路由器组内部，如果实际拥有这个对外IP的路由器如果工作正常的话就是MASTER,MASTER实现针对虚拟路由器IP的各种网络功能。其他设备不拥有该虚拟IP，状态为BACKUP,处了接收MASTER的VRRP状态通告信息以外，不执行对外的网络功能。当主机失效时，BACKUP将接管原先MASTER的网络功能。</p><p>从上面的介绍信息获取到的内容就是VRRP是一种协议，那这个协议是用来干什么的？</p><p>1.选择协议</p><pre class="line-numbers language-none"><code class="language-none">VRRP可以把一个虚拟路由器的责任动态分配到局域网上的 VRRP 路由器中的一台。其中的虚拟路由即Virtual路由是由VRRP路由群组创建的一个不真实存在的路由，这个虚拟路由也是有对应的IP地址。而且VRRP路由1和VRRP路由2之间会有竞争选择，通过选择会产生一个Master路由和一个Backup路由。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.路由容错协议</p><pre class="line-numbers language-none"><code class="language-none">Master路由和Backup路由之间会有一个心跳检测，Master会定时告知Backup自己的状态，如果在指定的时间内，Backup没有接收到这个通知内容，Backup就会替代Master成为新的Master。Master路由有一个特权就是虚拟路由和后端服务器都是通过Master进行数据传递交互的，而备份节点则会直接丢弃这些请求和数据，不做处理，只是去监听Master的状态<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用了Keepalived后，解决方案如下:</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1604495442179.png"></p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>环境准备</p><table><thead><tr><th>VIP</th><th>IP</th><th>主机名</th><th>主/从</th></tr></thead><tbody><tr><td></td><td>192.168.200.133</td><td>keepalived1</td><td>Master</td></tr><tr><td>192.168.200.222</td><td></td><td></td><td></td></tr><tr><td></td><td>192.168.200.122</td><td>keepalived2</td><td>Backup</td></tr></tbody></table><p>keepalived的安装</p><pre class="line-numbers language-none"><code class="language-none">步骤1:从官方网站下载keepalived,官网地址https:&#x2F;&#x2F;keepalived.org&#x2F;步骤2:将下载的资源上传到服务器keepalived-2.0.20.tar.gz步骤3:创建keepalived目录，方便管理资源mkdir keepalived步骤4:将压缩文件进行解压缩，解压缩到指定的目录tar -zxf keepalived-2.0.20.tar.gz -C keepalived&#x2F;步骤5:对keepalived进行配置，编译和安装cd keepalived&#x2F;keepalived-2.0.20.&#x2F;configure --sysconf&#x3D;&#x2F;etc --prefix&#x3D;&#x2F;usr&#x2F;localmake &amp;&amp; make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装完成后，有两个文件需要我们认识下，一个是 <code>/etc/keepalived/keepalived.conf</code>(keepalived的系统配置文件，我们主要操作的就是该文件)，一个是/usr/local/sbin目录下的<code>keepalived</code>,是系统配置脚本，用来启动和关闭keepalived</p><h3 id="Keepalived配置文件介绍"><a href="#Keepalived配置文件介绍" class="headerlink" title="Keepalived配置文件介绍"></a>Keepalived配置文件介绍</h3><p>打开keepalived.conf配置文件</p><p>这里面会分三部，第一部分是global全局配置、第二部分是vrrp相关配置、第三部分是LVS相关配置。<br>本次课程主要是使用keepalived实现高可用部署，没有用到LVS，所以我们重点关注的是前两部分</p><pre class="line-numbers language-none"><code class="language-none">global全局部分：global_defs &#123;   #通知邮件，当keepalived发送切换时需要发email给具体的邮箱地址   notification_email &#123;     tom@itcast.cn     jerry@itcast.cn   &#125;   #设置发件人的邮箱信息   notification_email_from zhaomin@itcast.cn   #指定smpt服务地址   smtp_server 192.168.200.1   #指定smpt服务连接超时时间   smtp_connect_timeout 30   #运行keepalived服务器的一个标识，可以用作发送邮件的主题信息   router_id LVS_DEVEL      #默认是不跳过检查。检查收到的VRRP通告中的所有地址可能会比较耗时，设置此命令的意思是，如果通告与接收的上一个通告来自相同的master路由器，则不执行检查(跳过检查)   vrrp_skip_check_adv_addr   #严格遵守VRRP协议。   vrrp_strict   #在一个接口发送的两个免费ARP之间的延迟。可以精确到毫秒级。默认是0   vrrp_garp_interval 0   #在一个网卡上每组na消息之间的延迟时间，默认为0   vrrp_gna_interval 0&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">VRRP部分，该部分可以包含以下四个子模块1. vrrp_script2. vrrp_sync_group3. garp_group4. vrrp_instance我们会用到第一个和第四个，#设置keepalived实例的相关信息，VI_1为VRRP实例名称vrrp_instance VI_1 &#123;    state MASTER  #有两个值可选MASTER主 BACKUP备    interface ens33#vrrp实例绑定的接口，用于发送VRRP包[当前服务器使用的网卡名称]    virtual_router_id 51#指定VRRP实例ID，范围是0-255    priority 100#指定优先级，优先级高的将成为MASTER    advert_int 1#指定发送VRRP通告的间隔，单位是秒    authentication &#123;#vrrp之间通信的认证信息        auth_type PASS#指定认证方式。PASS简单密码认证(推荐)        auth_pass 1111#指定认证使用的密码，最多8位    &#125;    virtual_ipaddress &#123; #虚拟IP地址设置虚拟IP地址，供用户访问使用，可设置多个，一行一个        192.168.200.222    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置内容如下:</p><p>服务器1</p><pre class="line-numbers language-none"><code class="language-none">global_defs &#123;   notification_email &#123;        tom@itcast.cn        jerry@itcast.cn   &#125;   notification_email_from zhaomin@itcast.cn   smtp_server 192.168.200.1   smtp_connect_timeout 30   router_id keepalived1   vrrp_skip_check_adv_addr   vrrp_strict   vrrp_garp_interval 0   vrrp_gna_interval 0&#125;vrrp_instance VI_1 &#123;    state MASTER    interface ens33    virtual_router_id 51    priority 100    advert_int 1    authentication &#123;        auth_type PASS        auth_pass 1111    &#125;    virtual_ipaddress &#123;        192.168.200.222    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务器2</p><pre class="line-numbers language-none"><code class="language-none">! Configuration File for keepalivedglobal_defs &#123;   notification_email &#123;        tom@itcast.cn        jerry@itcast.cn   &#125;   notification_email_from zhaomin@itcast.cn   smtp_server 192.168.200.1   smtp_connect_timeout 30   router_id keepalived2   vrrp_skip_check_adv_addr   vrrp_strict   vrrp_garp_interval 0   vrrp_gna_interval 0&#125;vrrp_instance VI_1 &#123;    state BACKUP    interface ens33    virtual_router_id 51    priority 90    advert_int 1    authentication &#123;        auth_type PASS        auth_pass 1111    &#125;    virtual_ipaddress &#123;        192.168.200.222    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h3><ol><li>启动keepalived之前，咱们先使用命令 <code>ip a</code>,查看192.168.200.133和192.168.200.122这两台服务器的IP情况。</li></ol><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1604599529242.png"></p><ol start="2"><li>分别启动两台服务器的keepalived</li></ol><pre class="line-numbers language-none"><code class="language-none">cd &#x2F;usr&#x2F;local&#x2F;sbin.&#x2F;keepalived<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再次通过 <code>ip a</code>查看ip</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1604599616821.png"></p><ol start="3"><li>当把192.168.200.133服务器上的keepalived关闭后，再次查看ip</li></ol><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1604599709822.png"></p><p>通过上述的测试，我们会发现，虚拟IP(VIP)会在MASTER节点上，当MASTER节点上的keepalived出问题以后，因为BACKUP无法收到MASTER发出的VRRP状态通过信息，就会直接升为MASTER。VIP也会”漂移”到新的MASTER。</p><p>上面测试和Nginx有什么关系?</p><p>我们把192.168.200.133服务器的keepalived再次启动下，由于它的优先级高于服务器192.168.200.122的，所有它会再次成为MASTER，VIP也会”漂移”过去，然后我们再次通过浏览器访问:</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;192.168.200.222&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果把192.168.200.133服务器的keepalived关闭掉，再次访问相同的地址</p><p>效果实现了以后， 我们会发现要想让vip进行切换，就必须要把服务器上的keepalived进行关闭，而什么时候关闭keepalived呢?应该是在keepalived所在服务器的nginx出现问题后，把keepalived关闭掉，就可以让VIP执行另外一台服务器，但是现在这所有的操作都是通过手动来完成的，我们如何能让系统自动判断当前服务器的nginx是否正确启动，如果没有，要能让VIP自动进行”漂移”，这个问题该如何解决?</p><h3 id="keepalived之vrrp-script"><a href="#keepalived之vrrp-script" class="headerlink" title="keepalived之vrrp_script"></a>keepalived之vrrp_script</h3><p>keepalived只能做到对网络故障和keepalived本身的监控，即当出现网络故障或者keepalived本身出现问题时，进行切换。但是这些还不够，我们还需要监控keepalived所在服务器上的其他业务，比如Nginx,如果Nginx出现异常了，仅仅keepalived保持正常，是无法完成系统的正常工作的，因此需要根据业务进程的运行状态决定是否需要进行主备切换，这个时候，我们可以通过编写脚本对业务进程进行检测监控。</p><p>实现步骤:</p><ol><li>在keepalived配置文件中添加对应的配置像</li></ol><pre class="line-numbers language-none"><code class="language-none">vrrp_script 脚本名称&#123;    script &quot;脚本位置&quot;    interval 3 #执行时间间隔    weight -20 #动态调整vrrp_instance的优先级&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>编写脚本</li></ol><p>ck_nginx.sh</p><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;bin&#x2F;bashnum&#x3D;&#96;ps -C nginx --no-header | wc -l&#96;if [ $num -eq 0 ];then &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx sleep 2 if [ &#96;ps -C nginx --no-header | wc -l&#96; -eq 0 ]; then  killall keepalived fifi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Linux ps命令用于显示当前进程 (process) 的状态。</p><p>-C(command) :指定命令的所有进程</p><p>–no-header 排除标题</p><ol start="3"><li>为脚本文件设置权限</li></ol><pre class="line-numbers language-none"><code class="language-none">chmod 755 ck_nginx.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>将脚本添加到</li></ol><pre class="line-numbers language-none"><code class="language-none">vrrp_script ck_nginx &#123;   script &quot;&#x2F;etc&#x2F;keepalived&#x2F;ck_nginx.sh&quot; #执行脚本的位置   interval 2#执行脚本的周期，秒为单位   weight -20#权重的计算方式&#125;vrrp_instance VI_1 &#123;    state MASTER    interface ens33    virtual_router_id 10    priority 100    advert_int 1    authentication &#123;        auth_type PASS        auth_pass 1111    &#125;    virtual_ipaddress &#123;        192.168.200.111    &#125;    track_script &#123;      ck_nginx    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>如果效果没有出来，可以使用 <code>tail -f /var/log/messages</code>查看日志信息，找对应的错误信息。</li><li>测试</li></ol><p>问题思考:</p><p>通常如果master服务死掉后backup会变成master，但是当master服务又好了的时候 master此时会抢占VIP，这样就会发生两次切换对业务繁忙的网站来说是不好的。所以我们要在配置文件加入 nopreempt 非抢占，但是这个参数只能用于state 为backup，故我们在用HA的时候最好master 和backup的state都设置成backup 让其通过priority来竞争。</p><h1 id="Nginx制作下载站点"><a href="#Nginx制作下载站点" class="headerlink" title="Nginx制作下载站点"></a>Nginx制作下载站点</h1><p>首先我们先要清楚什么是下载站点?</p><p>我们先来看一个网站<code>http://nginx.org/download/</code>这个我们刚开始学习Nginx的时候给大家看过这样的网站，该网站主要就是用来提供用户来下载相关资源的网站，就叫做下载网站。</p><p>如何制作一个下载站点:</p><p>nginx使用的是模块ngx_http_autoindex_module来实现的，该模块处理以斜杠(“/“)结尾的请求，并生成目录列表。</p><p>nginx编译的时候会自动加载该模块，但是该模块默认是关闭的，我们需要使用下来指令来完成对应的配置</p><p>（1）autoindex:启用或禁用目录列表输出</p><table><thead><tr><th>语法</th><th>autoindex on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>autoindex off;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>（2）autoindex_exact_size:对应HTLM格式，指定是否在目录列表展示文件的详细大小</p><p>默认为on，显示出文件的确切大小，单位是bytes。<br>改为off后，显示出文件的大概大小，单位是kB或者MB或者GB</p><table><thead><tr><th>语法</th><th>autoindex_exact_size  on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>autoindex_exact_size  on;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>（3）autoindex_format：设置目录列表的格式</p><table><thead><tr><th>语法</th><th>autoindex_format html|xml|json|jsonp;</th></tr></thead><tbody><tr><td>默认值</td><td>autoindex_format html;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>注意:该指令在1.7.9及以后版本中出现</p><p>（4）autoindex_localtime:对应HTML格式，是否在目录列表上显示时间。</p><p>默认为off，显示的文件时间为GMT时间。<br>改为on后，显示的文件时间为文件的服务器时间</p><table><thead><tr><th>语法</th><th>autoindex_localtime on | off;</th></tr></thead><tbody><tr><td>默认值</td><td>autoindex_localtime off;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>配置方式如下:</p><pre class="line-numbers language-none"><code class="language-none">location &#x2F;download&#123;    root &#x2F;usr&#x2F;local;    autoindex on;    autoindex_exact_size on;    autoindex_format html;    autoindex_localtime on;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Nginx的用户认证模块"><a href="#Nginx的用户认证模块" class="headerlink" title="Nginx的用户认证模块"></a>Nginx的用户认证模块</h1><p>对应系统资源的访问，我们往往需要限制谁能访问，谁不能访问。这块就是我们通常所说的认证部分，认证需要做的就是根据用户输入的用户名和密码来判定用户是否为合法用户，如果是则放行访问，如果不是则拒绝访问。</p><p>Nginx对应用户认证这块是通过ngx_http_auth_basic_module模块来实现的，它允许通过使用”HTTP基本身份验证”协议验证用户名和密码来限制对资源的访问。默认情况下nginx是已经安装了该模块，如果不需要则使用–without-http_auth_basic_module。</p><p>该模块的指令比较简单，</p><p>（1）auth_basic:使用“ HTTP基本认证”协议启用用户名和密码的验证</p><table><thead><tr><th>语法</th><th>auth_basic string|off;</th></tr></thead><tbody><tr><td>默认值</td><td>auth_basic off;</td></tr><tr><td>位置</td><td>http,server,location,limit_except</td></tr></tbody></table><p>开启后，服务端会返回401，指定的字符串会返回到客户端，给用户以提示信息，但是不同的浏览器对内容的展示不一致。</p><p>（2）auth_basic_user_file:指定用户名和密码所在文件</p><table><thead><tr><th>语法</th><th>auth_basic_user_file file;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http,server,location,limit_except</td></tr></tbody></table><p>指定文件路径，该文件中的用户名和密码的设置，密码需要进行加密。可以采用工具自动生成</p><p>实现步骤:</p><p>1.nginx.conf添加如下内容</p><pre class="line-numbers language-none"><code class="language-none">location &#x2F;download&#123;    root &#x2F;usr&#x2F;local;    autoindex on;    autoindex_exact_size on;    autoindex_format html;    autoindex_localtime on;    auth_basic &#39;please input your auth&#39;;    auth_basic_user_file htpasswd;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.我们需要使用<code>htpasswd</code>工具生成</p><pre class="line-numbers language-none"><code class="language-none">yum install -y httpd-tools<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">htpasswd -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;htpasswd username &#x2F;&#x2F;创建一个新文件记录用户名和密码htpasswd -b &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;htpasswd username password &#x2F;&#x2F;在指定文件新增一个用户名和密码htpasswd -D &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;htpasswd username &#x2F;&#x2F;从指定文件删除一个用户信息htpasswd -v &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;htpasswd username &#x2F;&#x2F;验证用户名和密码是否正确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述方式虽然能实现用户名和密码的验证，但是大家也看到了，所有的用户名和密码信息都记录在文件里面，如果用户量过大的话，这种方式就显得有点麻烦了，这时候我们就得通过后台业务代码来进行用户权限的校验了。</p><h1 id="Nginx的扩展模块"><a href="#Nginx的扩展模块" class="headerlink" title="Nginx的扩展模块"></a>Nginx的扩展模块</h1><p>Nginx是可扩展的，可用于处理各种使用场景。本节中，我们将探讨使用Lua扩展Nginx的功能。</p><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Lua是一种轻量、小巧的脚本语言，用标准C语言编写并以源代码形式开发。设计的目的是为了嵌入到其他应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>跟其他语言进行比较，Lua有其自身的特点：</p><p>（1）轻量级</p><pre class="line-numbers language-none"><code class="language-none">Lua用标准C语言编写并以源代码形式开发，编译后仅仅一百余千字节，可以很方便的嵌入到其他程序中。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）可扩展</p><pre class="line-numbers language-none"><code class="language-none">Lua提供非常丰富易于使用的扩展接口和机制，由宿主语言(通常是C或C++)提供功能，Lua可以使用它们，就像内置的功能一样。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（3）支持面向过程编程和函数式编程</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>Lua在不同的系统中得到大量应用，场景的应用场景如下:</p><p>游戏开发、独立应用脚本、web应用脚本、扩展和数据库插件、系统安全上。</p><h3 id="Lua的安装"><a href="#Lua的安装" class="headerlink" title="Lua的安装"></a>Lua的安装</h3><p>在linux上安装Lua非常简单，只需要下载源码包并在终端解压、编译即可使用。</p><p>Lua的官网地址为:<code>https://www.lua.org</code></p><ol><li>点击download可以找到对应版本的下载地址，我们本次课程采用的是lua-5.3.5,其对应的资源链接地址为<a href="https://www.lua.org/ftp/lua-5.4.1.tar.gz,%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8wget%E5%91%BD%E4%BB%A4%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD">https://www.lua.org/ftp/lua-5.4.1.tar.gz,也可以使用wget命令直接下载</a>:</li></ol><pre class="line-numbers language-none"><code class="language-none">wget https:&#x2F;&#x2F;www.lua.org&#x2F;ftp&#x2F;lua-5.4.1.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>编译安装</li></ol><pre class="line-numbers language-none"><code class="language-none">cd lua-5.4.1make linux testmake install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果在执行make linux test失败，报如下错误:</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1604650028960.png"></p><p>说明当前系统缺少libreadline-dev依赖包，需要通过命令来进行安装</p><pre class="line-numbers language-none"><code class="language-none">yum install -y readline-devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证是否安装成功</p><pre class="line-numbers language-none"><code class="language-none">lua -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Lua的语法"><a href="#Lua的语法" class="headerlink" title="Lua的语法"></a>Lua的语法</h3><p>Lua和C/C++语法非常相似，整体上比较清晰，简洁。条件语句、循环语句、函数调用都与C/C++基本一致。如果对C/C++不太熟悉的同学来说，也没关系，因为天下语言是一家，基本上理解起来都不会太困难。我们一点点来讲。</p><h4 id="第一个Lua程序"><a href="#第一个Lua程序" class="headerlink" title="第一个Lua程序"></a>第一个Lua程序</h4><p>大家需要知道的是，Lua有两种交互方式，分别是:交互式和脚本式，这两者的区别，下面我们分别来讲解下：</p><p>交互式之HELLOWORLD</p><pre class="line-numbers language-none"><code class="language-none">交互式是指可以在命令行输入程序，然后回车就可以看到运行的效果。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Lua交互式编程模式可以通过命令lua -i 或lua来启用:</p><p>在命令行中key输入如下命令，并按回车,会有输出在控制台：</p><p>脚本式之HELLOWORLD</p><p>脚本式是将代码保存到一个以lua为扩展名的文件中并执行的方式。</p><p>方式一:</p><p>我们需要一个文件名为 hello.lua,在文件中添加要执行的代码，然后通过命令 <code>lua hello.lua</code>来执行，会在控制台输出对应的结果。</p><p>hello.lua</p><pre class="line-numbers language-none"><code class="language-none">print(&quot;Hello World!!&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方式二:</p><p>将hello.lua做如下修改</p><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;usr&#x2F;local&#x2F;bin&#x2F;luaprint(&quot;Hello World!!!&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一行用来指定Lua解释器所在位置为 /usr/local/bin/lua，加上#号标记解释器会忽略它。一般情况下#!就是用来指定用哪个程序来运行本文件。但是hello.lua并不是一个可执行文件，需要通过chmod来设置可执行权限，最简单的方式为:</p><pre class="line-numbers language-none"><code class="language-none">chmod 755 hello.lua<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后执行该文件 </p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;hello.lua<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>补充一点，如果想在交互式中运行脚本式的hello.lua中的内容，我们可以使用一个dofile函数，如：</p><pre class="line-numbers language-none"><code class="language-none">dofile(&quot;lua_demo&#x2F;hello.lua&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意:在Lua语言中，连续语句之间的分隔符并不是必须的，也就是说后面不需要加分号，当然加上也不会报错，</p><p>在Lua语言中，表达式之间的换行也起不到任何作用。如以下四个写法，其实都是等效的</p><pre class="line-numbers language-none"><code class="language-none">写法一a&#x3D;1b&#x3D;a+2写法二a&#x3D;1;b&#x3D;a+2;写法三a&#x3D;1; b&#x3D;a+2;写法四a&#x3D;1 b&#x3D;a+2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不建议使用第四种方式，可读性太差。</p><h4 id="Lua的注释"><a href="#Lua的注释" class="headerlink" title="Lua的注释"></a>Lua的注释</h4><p>关于Lua的注释要分两种，第一种是单行注释，第二种是多行注释。</p><p>单行注释的语法为：</p><pre class="line-numbers language-none"><code class="language-none">--注释内容<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>多行注释的语法为:</p><pre class="line-numbers language-none"><code class="language-none">--[[注释内容注释内容--]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果想取消多行注释，只需要在第一个–之前在加一个-即可，如：</p><pre class="line-numbers language-none"><code class="language-none">---[[注释内容注释内容--]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>换句话说标识符就是我们的变量名，Lua定义变量名以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字（0到9）。这块建议大家最好不要使用下划线加大写字母的标识符，因为Lua的保留字也是这样定义的，容易发生冲突。注意Lua是区分大小写字母的。</p><p><u>A</u>0</p><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>下列是Lua的关键字，大家在定义常量、变量或其他用户自定义标识符都要避免使用以下这些关键字：</p><table><thead><tr><th>and</th><th>break</th><th>do</th><th>else</th></tr></thead><tbody><tr><td>elseif</td><td>end</td><td>false</td><td>for</td></tr><tr><td>function</td><td>if</td><td>in</td><td>local</td></tr><tr><td>nil</td><td>not</td><td>or</td><td>repeat</td></tr><tr><td>return</td><td>then</td><td>true</td><td>until</td></tr><tr><td>while</td><td>goto</td><td></td><td></td></tr></tbody></table><p>一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。这个也是上面我们不建议这么定义标识符的原因。</p><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>Lua中支持的运算符有算术运算符、关系运算符、逻辑运算符、其他运算符。</p><p>算术运算符:</p><pre class="line-numbers language-none"><code class="language-none">+   加法-减法*乘法&#x2F;除法%取余^乘幂-负号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如:</p><pre class="line-numbers language-none"><code class="language-none">10+20--&gt;3020-10--&gt;1010*20--&gt;20020&#x2F;10--&gt;23%2--&gt;110^2--&gt;100-10--&gt;-10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关系运算符</p><pre class="line-numbers language-none"><code class="language-none">&#x3D;&#x3D;等于~&#x3D;不等于&gt;大于&lt;小于&gt;&#x3D;大于等于&lt;&#x3D;小于等于<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如:</p><pre class="line-numbers language-none"><code class="language-none">10&#x3D;&#x3D;10--&gt;true10~&#x3D;10--&gt;false20&gt;10--&gt;true20&lt;10--&gt;false20&gt;&#x3D;10--&gt;true20&lt;&#x3D;10--&gt;false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逻辑运算符</p><pre class="line-numbers language-none"><code class="language-none">and逻辑与 A and B     &amp;&amp;   or逻辑或 A or B     ||not逻辑非  取反，如果为true,则返回false  !<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>逻辑运算符可以作为if的判断条件，返回的结果如下:</p><pre class="line-numbers language-none"><code class="language-none">A &#x3D; trueB &#x3D; trueA and B--&gt;trueA or  B --&gt;truenot A --&gt;falseA &#x3D; trueB &#x3D; falseA and B--&gt;falseA or  B --&gt;truenot A --&gt;falseA &#x3D; falseB &#x3D; trueA and B--&gt;falseA or  B --&gt;truenot A --&gt;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他运算符</p><pre class="line-numbers language-none"><code class="language-none">..连接两个字符串#一元预算法，返回字符串或表的长度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如:</p><pre class="line-numbers language-none"><code class="language-none">&gt; &quot;HELLO &quot;..&quot;WORLD&quot;--&gt;HELLO WORLD&gt; #&quot;HELLO&quot;--&gt;5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="全局变量-amp-局部变量"><a href="#全局变量-amp-局部变量" class="headerlink" title="全局变量&amp;局部变量"></a>全局变量&amp;局部变量</h4><p>在Lua语言中，全局变量无须声明即可使用。在默认情况下，变量总是认为是全局的，如果未提前赋值，默认为nil</p><p>要想声明一个局部变量，需要使用local来声明</p><h4 id="Lua数据类型"><a href="#Lua数据类型" class="headerlink" title="Lua数据类型"></a>Lua数据类型</h4><p>Lua有8个数据类型</p><pre class="line-numbers language-none"><code class="language-none">nil(空，无效值)boolean(布尔，true&#x2F;false)number(数值)string(字符串)function(函数)table（表）thread(线程)userdata（用户数据）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用type函数测试给定变量或者的类型：</p><pre class="line-numbers language-none"><code class="language-none">print(type(nil))--&gt;nilprint(type(true))               --&gt; booleanprint(type(1.1*1.1))             --&gt; numberprint(type(&quot;Hello world&quot;))      --&gt; stringprint(type(io.stdin))--&gt;userdataprint(type(print))              --&gt; functionprint(type(type))               --&gt;functionprint(type&#123;&#125;)--&gt;tableprint(type(type(X)))            --&gt; string<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h5><p>nil是一种只有一个nil值的类型，它的作用可以用来与其他所有值进行区分，也可以当想要移除一个变量时，只需要将该变量名赋值为nil,垃圾回收就会会释放该变量所占用的内存。</p><h5 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h5><p>boolean类型具有两个值，true和false。boolean类型一般被用来做条件判断的真与假。在Lua语言中，只会将false和nil视为假，其他的都视为真，特别是在条件检测中0和空字符串都会认为是真，这个和我们熟悉的大多数语言不太一样。</p><h5 id="number"><a href="#number" class="headerlink" title="number"></a>number</h5><p>在Lua5.3版本开始，Lua语言为数值格式提供了两种选择:integer(整型)和float(双精度浮点型)[和其他语言不太一样，float不代表单精度类型]。</p><p>数值常量的表示方式:</p><pre class="line-numbers language-none"><code class="language-none">&gt;4--&gt;4&gt;0.4--&gt;0.4&gt;4.75e-3--&gt;0.00475&gt;4.75e3--&gt;4750<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不管是整型还是双精度浮点型，使用type()函数来取其类型，都会返回的是number</p><pre class="line-numbers language-none"><code class="language-none">&gt;type(3)--&gt;number&gt;type(3.3)--&gt;number<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>所以它们之间是可以相互转换的，同时，具有相同算术值的整型值和浮点型值在Lua语言中是相等的</p><h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><p>Lua语言中的字符串即可以表示单个字符，也可以表示一整本书籍。在Lua语言中，操作100K或者1M个字母组成的字符串的程序很常见。</p><p>可以使用单引号或双引号来声明字符串</p><pre class="line-numbers language-none"><code class="language-none">&gt;a &#x3D; &quot;hello&quot;&gt;b &#x3D; &#39;world&#39;&gt;print(a)--&gt;hello&gt;print(b) --&gt;world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果声明的字符串比较长或者有多行，则可以使用如下方式进行声明</p><pre class="line-numbers language-none"><code class="language-none">html &#x3D; [[&lt;html&gt;&lt;head&gt;&lt;title&gt;Lua-string&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.lua.org&quot;&gt;Lua&lt;&#x2F;a&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p>​    table是Lua语言中最主要和强大的数据结构。使用表， Lua 语言可以以一种简单、统一且高效的方式表示数组、集合、记录和其他很多数据结构。 Lua语言中的表本质上是一种辅助数组。这种数组比Java中的数组更加灵活，可以使用数值做索引，也可以使用字符串或其他任意类型的值作索引(除nil外)。</p><p>创建表的最简单方式:</p><pre class="line-numbers language-none"><code class="language-none">&gt; a &#x3D; &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建数组:</p><p>​    我们都知道数组就是相同数据类型的元素按照一定顺序排列的集合，那么使用table如何创建一个数组呢?</p><pre class="line-numbers language-none"><code class="language-none">&gt;arr &#x3D; &#123;&quot;TOM&quot;,&quot;JERRY&quot;,&quot;ROSE&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    要想获取数组中的值，我们可以通过如下内容来获取:</p><pre class="line-numbers language-none"><code class="language-none">print(arr[0])nilprint(arr[1])TOMprint(arr[2])JERRYprint(arr[3])ROSE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    从上面的结果可以看出来，数组的下标默认是从1开始的。所以上述创建数组，也可以通过如下方式来创建</p><pre class="line-numbers language-none"><code class="language-none">&gt;arr &#x3D; &#123;&#125;&gt;arr[1] &#x3D; &quot;TOM&quot;&gt;arr[2] &#x3D; &quot;JERRY&quot;&gt;arr[3] &#x3D; &quot;ROSE&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面我们说过了，表的索引即可以是数字，也可以是字符串等其他的内容，所以我们也可以将索引更改为字符串来创建</p><pre class="line-numbers language-none"><code class="language-none">&gt;arr &#x3D; &#123;&#125;&gt;arr[&quot;X&quot;] &#x3D; 10&gt;arr[&quot;Y&quot;] &#x3D; 20&gt;arr[&quot;Z&quot;] &#x3D; 30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当然，如果想要获取这些数组中的值，可以使用下面的方式</p><pre class="line-numbers language-none"><code class="language-none">方式一&gt;print(arr[&quot;X&quot;])&gt;print(arr[&quot;Y&quot;])&gt;print(arr[&quot;Z&quot;])方式二&gt;print(arr.X)&gt;print(arr.Y)&gt;print(arr.Z)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当前table的灵活不进于此，还有更灵活的声明方式</p><pre class="line-numbers language-none"><code class="language-none">&gt;arr &#x3D; &#123;&quot;TOM&quot;,X&#x3D;10,&quot;JERRY&quot;,Y&#x3D;20,&quot;ROSE&quot;,Z&#x3D;30&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何获取上面的值?</p><pre class="line-numbers language-none"><code class="language-none">TOM :  arr[1]10  :  arr[&quot;X&quot;] | arr.XJERRY: arr[2]20  :  arr[&quot;Y&quot;] | arr.YROESE?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="function"><a href="#function" class="headerlink" title="function"></a>function</h5><p>在 Lua语言中，函数（ Function ）是对语句和表达式进行抽象的主要方式。</p><p>定义函数的语法为:</p><pre class="line-numbers language-none"><code class="language-none">function functionName(params)end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>函数被调用的时候，传入的参数个数与定义函数时使用的参数个数不一致的时候，Lua 语言会通过 抛弃多余参数和将不足的参数设为 nil 的方式来调整参数的个数。</p><pre class="line-numbers language-none"><code class="language-none">function  f(a,b)print(a,b)endf()--&gt; nil  nilf(2)--&gt; 2 nilf(2,6)--&gt; 2 6f(2.6.8)--&gt; 2 6 (8被丢弃)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可变长参数函数</p><pre class="line-numbers language-none"><code class="language-none">function add(...)a,b,c&#x3D;...print(a)print(b)print(c)endadd(1,2,3)  --&gt; 1 2 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数返回值可以有多个，这点和Java不太一样</p><pre class="line-numbers language-none"><code class="language-none">function f(a,b)return a,bendx,y&#x3D;f(11,22)--&gt; x&#x3D;11,y&#x3D;22<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h5><p>thread翻译过来是线程的意思，在Lua中，thread用来表示执行的独立线路，用来执行协同程序。</p><h5 id="userdata"><a href="#userdata" class="headerlink" title="userdata"></a>userdata</h5><p>userdata是一种用户自定义数据，用于表示一种由应用程序或C/C++语言库所创建的类型。</p><h4 id="Lua控制结构"><a href="#Lua控制结构" class="headerlink" title="Lua控制结构"></a>Lua控制结构</h4><p>Lua 语言提供了一组精简且常用的控制结构，包括用于条件执行的证 以及用于循环的 while、 repeat 和 for。 所有的控制结构语法上都有一个显式的终结符： end 用于终结 if、 for 及 while 结构， until 用于终结 repeat 结构。</p><h5 id="if-then-elseif-else"><a href="#if-then-elseif-else" class="headerlink" title="if then elseif else"></a>if then elseif else</h5><p>if语句先测试其条件，并根据条件是否满足执行相应的 then 部分或 else 部分。 else 部分 是可选的。</p><pre class="line-numbers language-none"><code class="language-none">function testif(a) if a&gt;0 then print(&quot;a是正数&quot;) endendfunction testif(a) if a&gt;0 then print(&quot;a是正数&quot;) else print(&quot;a是负数&quot;) endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要编写嵌套的 if 语句，可以使用 elseif。 它类似于在 else 后面紧跟一个if。根据传入的年龄返回不同的结果，如</p><pre class="line-numbers language-none"><code class="language-none">age&lt;&#x3D;18 青少年，age&gt;18 , age &lt;&#x3D;45 青年age&gt;45 , age&lt;&#x3D;60 中年人age&gt;60 老年人function show(age)if age&lt;&#x3D;18 then return &quot;青少年&quot;elseif age&gt;18 and age&lt;&#x3D;45 then return &quot;青年&quot;elseif age&gt;45 and age&lt;&#x3D;60 then return &quot;中年人&quot;elseif age&gt;60 then return &quot;老年人&quot;endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p>顾名思义，当条件为真时 while 循环会重复执行其循环体。 Lua 语言先测试 while 语句 的条件，若条件为假则循环结束；否则， Lua 会执行循环体并不断地重复这个过程。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">while 条件 do  循环体end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>例子:实现数组的循环</p><pre class="line-numbers language-none"><code class="language-none">function testWhile() local i &#x3D; 1 while i&lt;&#x3D;10 do  print(i)  i&#x3D;i+1 endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="repeat循环"><a href="#repeat循环" class="headerlink" title="repeat循环"></a>repeat循环</h5><p>顾名思义， repeat-until语句会重复执行其循环体直到条件为真时结束。 由于条件测试在循环体之后执行，所以循环体至少会执行一次。</p><p>语法</p><pre class="line-numbers language-none"><code class="language-none">repeat 循环体 until 条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">function testRepeat() local i &#x3D; 10 repeat  print(i)  i&#x3D;i-1 until i &lt; 1end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>数值型for循环</p><p>语法</p><pre class="line-numbers language-none"><code class="language-none">for param&#x3D;exp1,exp2,exp3 do 循环体end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>param的值从exp1变化到exp2之前的每次循环会执行 循环体，并在每次循环结束后将步长(step)exp3增加到param上。exp3可选，如果不设置默认为1</p><pre class="line-numbers language-none"><code class="language-none">for i &#x3D; 1,100,10 doprint(i)end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>泛型for循环</p><p>泛型for循环通过一个迭代器函数来遍历所有值，类似于java中的foreach语句。</p><p>语法</p><pre class="line-numbers language-none"><code class="language-none">for i,v in ipairs(x) do循环体end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>i是数组索引值，v是对应索引的数组元素值，ipairs是Lua提供的一个迭代器函数，用来迭代数组，x是要遍历的数组。</p><p>例如:</p><pre class="line-numbers language-none"><code class="language-none">arr &#x3D; &#123;&quot;TOME&quot;,&quot;JERRY&quot;,&quot;ROWS&quot;,&quot;LUCY&quot;&#125;for i,v in ipairs(arr) do print(i,v)end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述实例输出的结果为</p><pre class="line-numbers language-none"><code class="language-none">1TOM2JERRY3ROWS4LUCY<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是如果将arr的值进行修改为</p><pre class="line-numbers language-none"><code class="language-none">arr &#x3D; &#123;&quot;TOME&quot;,&quot;JERRY&quot;,&quot;ROWS&quot;,x&#x3D;&quot;JACK&quot;,&quot;LUCY&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样的代码在执行的时候，就只能看到和之前一样的结果，而其中的x为JACK就无法遍历出来，缺失了数据，如果解决呢?</p><p>我们可以将迭代器函数变成pairs,如</p><pre class="line-numbers language-none"><code class="language-none">for i,v in pairs(arr) do print(i,v)end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述实例就输出的结果为</p><pre class="line-numbers language-none"><code class="language-none">1TOM2JERRY3ROWS4LUCYxJACK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ngx-lua模块概念"><a href="#ngx-lua模块概念" class="headerlink" title="ngx_lua模块概念"></a>ngx_lua模块概念</h2><p>淘宝开发的ngx_lua模块通过将lua解释器集成进Nginx，可以采用lua脚本实现业务逻辑，由于lua的紧凑、快速以及内建协程，所以在保证高并发服务能力的同时极大地降低了业务逻辑实现成本。</p><h2 id="ngx-lua模块环境准备"><a href="#ngx-lua模块环境准备" class="headerlink" title="ngx_lua模块环境准备"></a>ngx_lua模块环境准备</h2><h3 id="方式一-lua-nginx-module"><a href="#方式一-lua-nginx-module" class="headerlink" title="方式一:lua-nginx-module"></a>方式一:lua-nginx-module</h3><ol><li>LuaJIT是采用C语言编写的Lua代表的解释器。</li></ol><p>官网地址为:<a href="http://luajit.org/">http://luajit.org/</a></p><p>在官网上找到对应的下载地址:<a href="http://luajit.org/download/LuaJIT-2.0.5.tar.gz">http://luajit.org/download/LuaJIT-2.0.5.tar.gz</a></p><p>在centos上使用wget来下载: wget <a href="http://luajit.org/download/LuaJIT-2.0.5.tar.gz">http://luajit.org/download/LuaJIT-2.0.5.tar.gz</a></p><p>将下载的资源进行解压: tar -zxf LuaJIT-2.0.5.tar.gz</p><p>进入解压的目录: cd LuaJIT-2.0.5</p><p>执行编译和安装: make &amp;&amp; make install</p><ol start="2"><li>下载lua-nginx-module</li></ol><p>下载地址:<a href="https://github.com/openresty/lua-nginx-module/archive/v0.10.16rc4.tar.gz">https://github.com/openresty/lua-nginx-module/archive/v0.10.16rc4.tar.gz</a></p><p>在centos上使用wget来下载: wget <a href="https://github.com/openresty/lua-nginx-module/archive/v0.10.16rc4.tar.gz">https://github.com/openresty/lua-nginx-module/archive/v0.10.16rc4.tar.gz</a></p><p>将下载的资源进行解压: tar -zxf lua-nginx-module-0.10.16rc4.tar.gz</p><p>更改目录名:mv lua-nginx-module-0.10.16rc4 lua-nginx-module</p><p>导入环境变量，告诉Nginx去哪里找luajit</p><pre class="line-numbers language-none"><code class="language-none">export LUAJIT_LIB&#x3D;&#x2F;usr&#x2F;local&#x2F;libexport LUAJIT_INC&#x3D;&#x2F;usr&#x2F;local&#x2F;include&#x2F;luajit-2.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>进入Nginx的目录执行如下命令:</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --add-module&#x3D;..&#x2F;lua-nginx-modulemake &amp;&amp; make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意事项:</p><p>（1）如果启动Nginx出现如下错误:</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1604636421045.png"></p><p>解决方案:</p><p>设置软链接，使用如下命令</p><pre class="line-numbers language-none"><code class="language-none">ln -s &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libluajit-5.1.so.2 &#x2F;lib64&#x2F;libluajit-5.1.so.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）如果启动Nginx出现以下错误信息</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1604636405241.png"></p><p>分析原因:因为lua-nginx-module是来自openrestry,错误中提示的resty.core是openrestry的核心模块，对其下的很多函数进行了优化等工作。以前的版本默认不会把该模块编译进去，所以需要使用的话，我们得手动安装，或者禁用就可以。但是最新的lua-nginx-module模块已经强制性安装了该模块，所以此处因为缺少resty模块导致的报错信息。</p><p>解决方案有两个:一种是下载对应的模块，另一种则是禁用掉restry模块，禁用的方式为:</p><pre class="line-numbers language-none"><code class="language-none">http&#123;lua_load_resty_core off;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li>测试</li></ol><p>在nginx.conf下配置如下内容:</p><pre class="line-numbers language-none"><code class="language-none">location &#x2F;lua&#123;    default_type &#39;text&#x2F;html&#39;;    content_by_lua &#39;ngx.say(&quot;&lt;h1&gt;HELLO,LUA&lt;&#x2F;h1&gt;&quot;)&#39;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方式二-OpenRestry"><a href="#方式二-OpenRestry" class="headerlink" title="方式二:OpenRestry"></a>方式二:OpenRestry</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>​    前面我们提到过，OpenResty是由淘宝工程师开发的，所以其官方网站(<a href="http://openresty.org/">http://openresty.org/</a>)我们读起来是非常的方便。OpenResty是一个基于Nginx与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。所以本身OpenResty内部就已经集成了Nginx和Lua，所以我们使用起来会更加方便。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre class="line-numbers language-none"><code class="language-none">(1) 下载OpenResty：https:&#x2F;&#x2F;openresty.org&#x2F;download&#x2F;openresty-1.15.8.2.tar.gz(2)使用wget下载: wget https:&#x2F;&#x2F;openresty.org&#x2F;download&#x2F;openresty-1.15.8.2.tar.gz(3)解压缩: tar -zxf openresty-1.15.8.2.tar.gz(4)进入OpenResty目录: cd openresty-1.15.8.2(5) 执行命令:.&#x2F;configure(6) 执行命令:make &amp;&amp; make install(7)进入OpenResty的目录，找到nginx：cd &#x2F;usr&#x2F;local&#x2F;openresty&#x2F;nginx&#x2F;(8)在conf目录下的nginx.conf添加如下内容location &#x2F;lua&#123;    default_type &#39;text&#x2F;html&#39;;    content_by_lua &#39;ngx.say(&quot;&lt;h1&gt;HELLO,OpenRestry&lt;&#x2F;h1&gt;&quot;)&#39;;&#125;(9)在sbin目录下启动nginx(10)通过浏览器访问测试<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ngx-lua的使用"><a href="#ngx-lua的使用" class="headerlink" title="ngx_lua的使用"></a>ngx_lua的使用</h2><p>使用Lua编写Nginx脚本的基本构建块是指令。指令用于指定何时运行用户Lua代码以及如何使用结果。下图显示了执行指令的顺序。</p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1604717983815.png" style="zoom:80%;" /><p>先来解释下*的作用</p><pre class="line-numbers language-none"><code class="language-none">*：无 ， 即 xxx_by_lua ,指令后面跟的是 lua指令*:_file，即 xxx_by_lua_file 指令后面跟的是 lua文件*:_block,即 xxx_by_lua_block 在0.9.17版后替换init_by_lua_file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="init-by-lua"><a href="#init-by-lua" class="headerlink" title="init_by_lua*"></a>init_by_lua*</h3><pre class="line-numbers language-none"><code class="language-none">该指令在每次Nginx重新加载配置时执行，可以用来完成一些耗时模块的加载，或者初始化一些全局配置。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="init-worker-by-lua"><a href="#init-worker-by-lua" class="headerlink" title="init_worker_by_lua*"></a>init_worker_by_lua*</h3><pre class="line-numbers language-none"><code class="language-none">该指令用于启动一些定时任务，如心跳检查、定时拉取服务器配置等。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="set-by-lua"><a href="#set-by-lua" class="headerlink" title="set_by_lua*"></a>set_by_lua*</h3><pre class="line-numbers language-none"><code class="language-none">该指令只要用来做变量赋值，这个指令一次只能返回一个值，并将结果赋值给Nginx中指定的变量。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="rewrite-by-lua"><a href="#rewrite-by-lua" class="headerlink" title="rewrite_by_lua*"></a>rewrite_by_lua*</h3><pre class="line-numbers language-none"><code class="language-none">该指令用于执行内部URL重写或者外部重定向，典型的如伪静态化URL重写，本阶段在rewrite处理阶段的最后默认执行。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="access-by-lua"><a href="#access-by-lua" class="headerlink" title="access_by_lua*"></a>access_by_lua*</h3><pre class="line-numbers language-none"><code class="language-none">该指令用于访问控制。例如，如果只允许内网IP访问。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="content-by-lua"><a href="#content-by-lua" class="headerlink" title="content_by_lua*"></a>content_by_lua*</h3><pre class="line-numbers language-none"><code class="language-none">该指令是应用最多的指令，大部分任务是在这个阶段完成的，其他的过程往往为这个阶段准备数据，正式处理基本都在本阶段。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="header-filter-by-lua"><a href="#header-filter-by-lua" class="headerlink" title="header_filter_by_lua*"></a>header_filter_by_lua*</h3><pre class="line-numbers language-none"><code class="language-none">该指令用于设置应答消息的头部信息。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="body-filter-by-lua"><a href="#body-filter-by-lua" class="headerlink" title="body_filter_by_lua*"></a>body_filter_by_lua*</h3><pre class="line-numbers language-none"><code class="language-none">该指令是对响应数据进行过滤，如截断、替换。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="log-by-lua"><a href="#log-by-lua" class="headerlink" title="log_by_lua*"></a>log_by_lua*</h3><pre class="line-numbers language-none"><code class="language-none">该指令用于在log请求处理阶段，用Lua代码处理日志，但并不替换原有log处理。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="balancer-by-lua"><a href="#balancer-by-lua" class="headerlink" title="balancer_by_lua*"></a>balancer_by_lua*</h3><pre class="line-numbers language-none"><code class="language-none">该指令主要的作用是用来实现上游服务器的负载均衡器算法<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="ssl-certificate-by"><a href="#ssl-certificate-by" class="headerlink" title="ssl_certificate_by_*"></a>ssl_certificate_by_*</h3><pre class="line-numbers language-none"><code class="language-none">该指令作用在Nginx和下游服务开始一个SSL握手操作时将允许本配置项的Lua代码。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="需求"><a href="#需求" class="headerlink" title="需求:"></a>需求:</h3><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;192.168.200.133?name&#x3D;张三&amp;gender&#x3D;1Nginx接收到请求后，根据gender传入的值，如果gender传入的是1，则在页面上展示张三先生,如果gender传入的是0，则在页面上展示张三女士,如果未传或者传入的不是1和2则在页面上展示张三。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>实现代码</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">location <span class="token operator">/</span><span class="token function">getByGender</span> <span class="token punctuation">&#123;</span>default_type <span class="token string">'text/html'</span><span class="token punctuation">;</span>set_by_lua $name "<span class="token keyword">local</span> uri_args <span class="token operator">=</span> ngx<span class="token punctuation">.</span>req<span class="token punctuation">.</span><span class="token function">get_uri_args</span><span class="token punctuation">(</span><span class="token punctuation">)</span>gender <span class="token operator">=</span> uri_args<span class="token punctuation">[</span><span class="token string">'gender'</span><span class="token punctuation">]</span>name <span class="token operator">=</span> uri_args<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token keyword">if</span> gender<span class="token operator">==</span><span class="token string">'1'</span> <span class="token keyword">then</span><span class="token keyword">return</span> name<span class="token operator">..</span><span class="token string">'先生'</span><span class="token keyword">elseif</span> gender<span class="token operator">==</span><span class="token string">'0'</span> <span class="token keyword">then</span><span class="token keyword">return</span> name<span class="token operator">..</span><span class="token string">'女士'</span><span class="token keyword">else</span><span class="token keyword">return</span> name<span class="token keyword">end</span>"<span class="token punctuation">;</span>header_filter_by_lua "ngx<span class="token punctuation">.</span>header<span class="token punctuation">.</span>aaa<span class="token operator">=</span><span class="token string">'bbb'</span>"<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">200</span> $name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ngx-lua操作Redis"><a href="#ngx-lua操作Redis" class="headerlink" title="ngx_lua操作Redis"></a>ngx_lua操作Redis</h2><p>Redis在系统中经常作为数据缓存、内存数据库使用，在大型系统中扮演着非常重要的作用。在Nginx核心系统中，Redis是常备组件。Nginx支持3种方法访问Redis,分别是HttpRedis模块、HttpRedis2Module、lua-resty-redis库。这三种方式中HttpRedis模块提供的指令少，功能单一，适合做简单缓存，HttpRedis2Module模块比HttpRedis模块操作更灵活，功能更强大。而Lua-resty-redis库是OpenResty提供的一个操作Redis的接口库，可根据自己的业务情况做一些逻辑处理，适合做复杂的业务逻辑。所以本次课程将主要以Lua-resty-redis来进行讲解。</p><h3 id="lua-resty-redis环境准备"><a href="#lua-resty-redis环境准备" class="headerlink" title="lua-resty-redis环境准备"></a>lua-resty-redis环境准备</h3><p>步骤一:准备一个Redis环境</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">连接地址host<span class="token operator">=</span> <span class="token number">192.168</span><span class="token number">.200</span><span class="token number">.111</span>port<span class="token operator">=</span><span class="token number">6379</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>步骤二:准备对应的API</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">lua<span class="token operator">-</span>resty<span class="token operator">-</span>redis提供了访问Redis的详细API，包括创建对接、连接、操作、数据处理等。这些API基本上与Redis的操作一一对应。（<span class="token number">1</span>）redis <span class="token operator">=</span> require <span class="token string">"resty.redis"</span>（<span class="token number">2</span>）new语法<span class="token punctuation">:</span> redis<span class="token punctuation">,</span>err <span class="token operator">=</span> redis<span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>创建一个Redis对象。（<span class="token number">3</span>）connect语法<span class="token punctuation">:</span>ok<span class="token punctuation">,</span>err<span class="token operator">=</span>redis<span class="token punctuation">:</span><span class="token function">connect</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span>port<span class="token punctuation">[</span><span class="token punctuation">,</span>options_table<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>设置连接Redis的连接信息。ok<span class="token punctuation">:</span>连接成功返回 <span class="token number">1</span>，连接失败返回<span class="token keyword">nil</span>err<span class="token punctuation">:</span>返回对应的错误信息（<span class="token number">4</span>）set_timeout语法<span class="token punctuation">:</span> redis<span class="token punctuation">:</span><span class="token function">set_timeout</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span> ，设置请求操作Redis的超时时间。（<span class="token number">5</span>）close语法<span class="token punctuation">:</span> ok<span class="token punctuation">,</span>err <span class="token operator">=</span> redis<span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>关闭当前连接，成功返回<span class="token number">1</span>，失败返回<span class="token keyword">nil</span>和错误信息（<span class="token number">6</span>）redis命令对应的方法在lua<span class="token operator">-</span>resty<span class="token operator">-</span>redis中，所有的Redis命令都有自己的方法，方法名字和命令名字相同，只是全部为小写。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>步骤三:效果实现</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">location <span class="token operator">/</span> <span class="token punctuation">&#123;</span>    default_type <span class="token string">"text/html"</span><span class="token punctuation">;</span>    <span class="token function">content_by_lua_block</span><span class="token punctuation">&#123;</span>        <span class="token keyword">local</span> redis <span class="token operator">=</span> require <span class="token string">"resty.redis"</span> <span class="token comment">-- 引入Redis</span>        <span class="token keyword">local</span> redisObj <span class="token operator">=</span> redis<span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">--创建Redis对象</span>        redisObj<span class="token punctuation">:</span><span class="token function">set_timeout</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment">--设置超时数据为1s</span>        <span class="token keyword">local</span> ok<span class="token punctuation">,</span>err <span class="token operator">=</span> redisObj<span class="token punctuation">:</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token string">"192.168.200.1"</span><span class="token punctuation">,</span><span class="token number">6379</span><span class="token punctuation">)</span> <span class="token comment">--设置redis连接信息</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> ok <span class="token keyword">then</span> <span class="token comment">--判断是否连接成功</span>         ngx<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token string">"failed to connection redis"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span>         <span class="token keyword">return</span>        <span class="token keyword">end</span>        ok<span class="token punctuation">,</span>err <span class="token operator">=</span> redisObj<span class="token punctuation">:</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">,</span><span class="token string">"TOM"</span><span class="token punctuation">)</span><span class="token comment">--存入数据</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> ok <span class="token keyword">then</span> <span class="token comment">--判断是否存入成功</span>         ngx<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token string">"failed to set username"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span>         <span class="token keyword">return</span>        <span class="token keyword">end</span>        <span class="token keyword">local</span> res<span class="token punctuation">,</span>err <span class="token operator">=</span> redisObj<span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span> <span class="token comment">--从redis中获取数据</span>        ngx<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token comment">--将数据写会消息体中</span>        redisObj<span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>步骤四:运行测试效果</p><h2 id="ngx-lua操作Mysql"><a href="#ngx-lua操作Mysql" class="headerlink" title="ngx_lua操作Mysql"></a>ngx_lua操作Mysql</h2><p>MySQL是一个使用广泛的关系型数据库。在ngx_lua中，MySQL有两种访问模式,分别是使</p><p>（1）用ngx_lua模块和lua-resty-mysql模块：这两个模块是安装OpenResty时默认安装的。</p><p>（2）使用drizzle_nginx_module(HttpDrizzleModule)模块：需要单独安装，这个库现不在OpenResty中。</p><h3 id="lua-resty-mysql"><a href="#lua-resty-mysql" class="headerlink" title="lua-resty-mysql"></a>lua-resty-mysql</h3><p>lua-resty-mysql是OpenResty开发的模块，使用灵活、功能强大，适合复杂的业务场景，同时支持存储过程的访问。</p><h4 id="使用lua-resty-mysql实现数据库的查询"><a href="#使用lua-resty-mysql实现数据库的查询" class="headerlink" title="使用lua-resty-mysql实现数据库的查询"></a>使用lua-resty-mysql实现数据库的查询</h4><p>步骤一:</p><p>准备MYSQL</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">host: <span class="token number">192.168</span><span class="token number">.200</span><span class="token number">.111</span>port: <span class="token number">3306</span>username:rootpassword:<span class="token number">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>创建一个数据库表及表中的数据。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">database</span> nginx_db<span class="token punctuation">;</span><span class="token keyword">use</span> nginx_db<span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">table</span> users<span class="token punctuation">(</span>   id <span class="token keyword">int</span> <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span>   username <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   birthday <span class="token keyword">date</span><span class="token punctuation">,</span>   salary <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> users<span class="token punctuation">(</span>id<span class="token punctuation">,</span>username<span class="token punctuation">,</span>birthday<span class="token punctuation">,</span>salary<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span><span class="token string">"TOM"</span><span class="token punctuation">,</span><span class="token string">"1988-11-11"</span><span class="token punctuation">,</span><span class="token number">10000.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> users<span class="token punctuation">(</span>id<span class="token punctuation">,</span>username<span class="token punctuation">,</span>birthday<span class="token punctuation">,</span>salary<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span><span class="token string">"JERRY"</span><span class="token punctuation">,</span><span class="token string">"1989-11-11"</span><span class="token punctuation">,</span><span class="token number">20000.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> users<span class="token punctuation">(</span>id<span class="token punctuation">,</span>username<span class="token punctuation">,</span>birthday<span class="token punctuation">,</span>salary<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span><span class="token string">"ROWS"</span><span class="token punctuation">,</span><span class="token string">"1990-11-11"</span><span class="token punctuation">,</span><span class="token number">30000.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> users<span class="token punctuation">(</span>id<span class="token punctuation">,</span>username<span class="token punctuation">,</span>birthday<span class="token punctuation">,</span>salary<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span><span class="token string">"LUCY"</span><span class="token punctuation">,</span><span class="token string">"1991-11-11"</span><span class="token punctuation">,</span><span class="token number">40000.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> users<span class="token punctuation">(</span>id<span class="token punctuation">,</span>username<span class="token punctuation">,</span>birthday<span class="token punctuation">,</span>salary<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span><span class="token string">"JACK"</span><span class="token punctuation">,</span><span class="token string">"1992-11-11"</span><span class="token punctuation">,</span><span class="token number">50000.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据库连接四要素:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">driverClass<span class="token operator">=</span>com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driverurl<span class="token operator">=</span>jdbc:mysql:<span class="token comment">//192.168.200.111:3306/nginx_db</span>username<span class="token operator">=</span>rootpassword<span class="token operator">=</span><span class="token number">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>步骤二:API学习</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">（<span class="token number">1</span>）引入<span class="token string">"resty.mysql"</span>模块<span class="token keyword">local</span> mysql <span class="token operator">=</span> require <span class="token string">"resty.mysql"</span>（<span class="token number">2</span>）new创建一个MySQL连接对象，遇到错误时，db为<span class="token keyword">nil</span>，err为错误描述信息语法<span class="token punctuation">:</span> db<span class="token punctuation">,</span>err <span class="token operator">=</span> mysql<span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span>（<span class="token number">3</span>）connect尝试连接到一个MySQL服务器语法<span class="token punctuation">:</span>ok<span class="token punctuation">,</span>err<span class="token operator">=</span>db<span class="token punctuation">:</span><span class="token function">connect</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">,</span>options是一个参数的Lua表结构，里面包含数据库连接的相关信息    host<span class="token punctuation">:</span>服务器主机名或IP地址    port<span class="token punctuation">:</span>服务器监听端口，默认为<span class="token number">3306</span>    user<span class="token punctuation">:</span>登录的用户名    password<span class="token punctuation">:</span>登录密码    database<span class="token punctuation">:</span>使用的数据库名（<span class="token number">4</span>）set_timeout设置子请求的超时时间<span class="token punctuation">(</span>ms<span class="token punctuation">)</span>，包括connect方法语法<span class="token punctuation">:</span>db<span class="token punctuation">:</span><span class="token function">set_timeout</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span>（<span class="token number">5</span>）close关闭当前MySQL连接并返回状态。如果成功，则返回<span class="token number">1</span>；如果出现任何错误，则将返回<span class="token keyword">nil</span>和错误描述。语法<span class="token punctuation">:</span>db<span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>（<span class="token number">6</span>）send_query异步向远程MySQL发送一个查询。如果成功则返回成功发送的字节数；如果错误，则返回<span class="token keyword">nil</span>和错误描述语法<span class="token punctuation">:</span>bytes<span class="token punctuation">,</span>err<span class="token operator">=</span>db<span class="token punctuation">:</span><span class="token function">send_query</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span>（<span class="token number">7</span>）read_result从MySQL服务器返回结果中读取一行数据。res返回一个描述OK包或结果集包的Lua表<span class="token punctuation">,</span>语法<span class="token punctuation">:</span>res<span class="token punctuation">,</span> err<span class="token punctuation">,</span> errcode<span class="token punctuation">,</span> sqlstate <span class="token operator">=</span> db<span class="token punctuation">:</span><span class="token function">read_result</span><span class="token punctuation">(</span><span class="token punctuation">)</span> res<span class="token punctuation">,</span> err<span class="token punctuation">,</span> errcode<span class="token punctuation">,</span> sqlstate <span class="token operator">=</span> db<span class="token punctuation">:</span><span class="token function">read_result</span><span class="token punctuation">(</span>rows<span class="token punctuation">)</span> <span class="token punctuation">:</span>rows指定返回结果集的最大值，默认为<span class="token number">4</span>如果是查询，则返回一个容纳多行的数组。每行是一个数据列的key<span class="token operator">-</span>value对，如    <span class="token punctuation">&#123;</span>      <span class="token punctuation">&#123;</span>id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>username<span class="token operator">=</span><span class="token string">"TOM"</span><span class="token punctuation">,</span>birthday<span class="token operator">=</span><span class="token string">"1988-11-11"</span><span class="token punctuation">,</span>salary<span class="token operator">=</span><span class="token number">10000.0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token punctuation">&#123;</span>id<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>username<span class="token operator">=</span><span class="token string">"JERRY"</span><span class="token punctuation">,</span>birthday<span class="token operator">=</span><span class="token string">"1989-11-11"</span><span class="token punctuation">,</span>salary<span class="token operator">=</span><span class="token number">20000.0</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>如果是增删改，则返回类上如下数据    <span class="token punctuation">&#123;</span>    insert_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    server_status<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>    warning_count<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>    affected_rows<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>    message<span class="token operator">=</span><span class="token keyword">nil</span>    <span class="token punctuation">&#125;</span>返回值<span class="token punctuation">:</span>res<span class="token punctuation">:</span>操作的结果集err<span class="token punctuation">:</span>错误信息errcode<span class="token punctuation">:</span>MySQL的错误码，比如<span class="token number">1064</span>sqlstate<span class="token punctuation">:</span>返回由<span class="token number">5</span>个字符组成的标准SQL错误码，比如<span class="token number">42000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>步骤三:效果实现</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">location <span class="token operator">/</span><span class="token punctuation">&#123;</span>    <span class="token function">content_by_lua_block</span><span class="token punctuation">&#123;</span>        <span class="token keyword">local</span> mysql <span class="token operator">=</span> require <span class="token string">"resty.mysql"</span>        <span class="token keyword">local</span> db <span class="token operator">=</span> mysql<span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">local</span> ok<span class="token punctuation">,</span>err <span class="token operator">=</span> db<span class="token punctuation">:</span><span class="token function">connect</span><span class="token punctuation">&#123;</span>            host<span class="token operator">=</span><span class="token string">"192.168.200.111"</span><span class="token punctuation">,</span>            port<span class="token operator">=</span><span class="token number">3306</span><span class="token punctuation">,</span>            user<span class="token operator">=</span><span class="token string">"root"</span><span class="token punctuation">,</span>            password<span class="token operator">=</span><span class="token string">"123456"</span><span class="token punctuation">,</span>            database<span class="token operator">=</span><span class="token string">"nginx_db"</span>        <span class="token punctuation">&#125;</span>        db<span class="token punctuation">:</span><span class="token function">set_timeout</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>        db<span class="token punctuation">:</span><span class="token function">send_query</span><span class="token punctuation">(</span><span class="token string">"select * from users where id =1"</span><span class="token punctuation">)</span>        <span class="token keyword">local</span> res<span class="token punctuation">,</span>err<span class="token punctuation">,</span>errcode<span class="token punctuation">,</span>sqlstate <span class="token operator">=</span> db<span class="token punctuation">:</span><span class="token function">read_result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        ngx<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token operator">..</span><span class="token string">","</span><span class="token operator">..</span>res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>username<span class="token operator">..</span><span class="token string">","</span><span class="token operator">..</span>res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>birthday<span class="token operator">..</span><span class="token string">","</span><span class="token operator">..</span>res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>salary<span class="token punctuation">)</span>    db<span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题:</p><pre class="line-numbers language-none"><code class="language-none">1.如何获取返回数据的内容2.如何实现查询多条数据3.如何实现数据库的增删改操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="使用lua-cjson处理查询结果"><a href="#使用lua-cjson处理查询结果" class="headerlink" title="使用lua-cjson处理查询结果"></a>使用lua-cjson处理查询结果</h4><p>通过上述的案例学习，read_result()得到的结果res都是table类型，要想在页面上展示，就必须知道table的具体数据结构才能进行遍历获取。处理起来比较麻烦，接下来我们介绍一种简单方式cjson，使用它就可以将table类型的数据转换成json字符串，把json字符串展示在页面上即可。具体如何使用?</p><p>步骤一：引入cjson</p><pre class="line-numbers language-none"><code class="language-none">local cjson &#x3D; require &quot;cjson&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>步骤二：调用cjson的encode方法进行类型转换</p><pre class="line-numbers language-none"><code class="language-none">cjson.encode(res) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>步骤三:使用</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">location <span class="token operator">/</span><span class="token punctuation">&#123;</span>    <span class="token function">content_by_lua_block</span><span class="token punctuation">&#123;</span>        <span class="token keyword">local</span> mysql <span class="token operator">=</span> require <span class="token string">"resty.mysql"</span>        <span class="token keyword">local</span> cjson <span class="token operator">=</span> require <span class="token string">"cjson"</span>        <span class="token keyword">local</span> db <span class="token operator">=</span> mysql<span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">local</span> ok<span class="token punctuation">,</span>err <span class="token operator">=</span> db<span class="token punctuation">:</span><span class="token function">connect</span><span class="token punctuation">&#123;</span>            host<span class="token operator">=</span><span class="token string">"192.168.200.111"</span><span class="token punctuation">,</span>            port<span class="token operator">=</span><span class="token number">3306</span><span class="token punctuation">,</span>            user<span class="token operator">=</span><span class="token string">"root"</span><span class="token punctuation">,</span>            password<span class="token operator">=</span><span class="token string">"123456"</span><span class="token punctuation">,</span>            database<span class="token operator">=</span><span class="token string">"nginx_db"</span>        <span class="token punctuation">&#125;</span>        db<span class="token punctuation">:</span><span class="token function">set_timeout</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>        <span class="token comment">--db:send_query("select * from users where id = 2")</span>        db<span class="token punctuation">:</span><span class="token function">send_query</span><span class="token punctuation">(</span><span class="token string">"select * from users"</span><span class="token punctuation">)</span>        <span class="token keyword">local</span> res<span class="token punctuation">,</span>err<span class="token punctuation">,</span>errcode<span class="token punctuation">,</span>sqlstate <span class="token operator">=</span> db<span class="token punctuation">:</span><span class="token function">read_result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        ngx<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span>cjson<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token keyword">for</span> i<span class="token punctuation">,</span>v <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token keyword">do</span>       ngx<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>id<span class="token operator">..</span><span class="token string">","</span><span class="token operator">..</span>v<span class="token punctuation">.</span>username<span class="token operator">..</span><span class="token string">","</span><span class="token operator">..</span>v<span class="token punctuation">.</span>birthday<span class="token operator">..</span><span class="token string">","</span><span class="token operator">..</span>v<span class="token punctuation">.</span>salary<span class="token punctuation">)</span>        <span class="token keyword">end</span>    db<span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="lua-resty-mysql实现数据库的增删改"><a href="#lua-resty-mysql实现数据库的增删改" class="headerlink" title="lua-resty-mysql实现数据库的增删改"></a>lua-resty-mysql实现数据库的增删改</h4><p>优化send_query和read_result</p><p>本方法是send_query和read_result组合的快捷方法。</p><p>语法:</p><pre class="line-numbers language-none"><code class="language-none">res, err, errcode, sqlstate &#x3D; db:query(sql[,rows])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有了该API，上面的代码我们就可以进行对应的优化，如下:</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">location <span class="token operator">/</span><span class="token punctuation">&#123;</span>    <span class="token function">content_by_lua_block</span><span class="token punctuation">&#123;</span>        <span class="token keyword">local</span> mysql <span class="token operator">=</span> require <span class="token string">"resty.mysql"</span>        <span class="token keyword">local</span> db <span class="token operator">=</span> mysql<span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">local</span> ok<span class="token punctuation">,</span>err <span class="token operator">=</span> db<span class="token punctuation">:</span><span class="token function">connect</span><span class="token punctuation">&#123;</span>        host<span class="token operator">=</span><span class="token string">"192.168.200.1"</span><span class="token punctuation">,</span>        port<span class="token operator">=</span><span class="token number">3306</span><span class="token punctuation">,</span>        user<span class="token operator">=</span><span class="token string">"root"</span><span class="token punctuation">,</span>        password<span class="token operator">=</span><span class="token string">"123456"</span><span class="token punctuation">,</span>        database<span class="token operator">=</span><span class="token string">"nginx_db"</span><span class="token punctuation">,</span>        max_packet_size<span class="token operator">=</span><span class="token number">1024</span><span class="token punctuation">,</span>        compact_arrays<span class="token operator">=</span><span class="token keyword">false</span>        <span class="token punctuation">&#125;</span>        db<span class="token punctuation">:</span><span class="token function">set_timeout</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>        <span class="token keyword">local</span> res<span class="token punctuation">,</span>err<span class="token punctuation">,</span>errcode<span class="token punctuation">,</span>sqlstate <span class="token operator">=</span> db<span class="token punctuation">:</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token string">"select * from users"</span><span class="token punctuation">)</span>        <span class="token comment">--local res,err,errcode,sqlstate = db:query("insert into users(id,username,birthday,salary) values(null,'zhangsan','2020-11-11',32222.0)")</span>        <span class="token comment">--local res,err,errcode,sqlstate = db:query("update users set username='lisi' where id = 6")</span>        <span class="token comment">--local res,err,errcode,sqlstate = db:query("delete from users where id = 6")</span>        db<span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="综合小案例"><a href="#综合小案例" class="headerlink" title="综合小案例"></a>综合小案例</h3><p>使用ngx_lua模块完成Redis缓存预热。</p><p>分析: </p><p>（1）先得有一张表(users)</p><p>（2）浏览器输入如下地址</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;191.168.200.133?username&#x3D;TOM<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（3）从表中查询出符合条件的记录，此时获取的结果为table类型</p><p>（4）使用cjson将table数据转换成json字符串</p><p>（5）将查询的结果数据存入Redis中</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token function">init_by_lua_block</span><span class="token punctuation">&#123;</span>redis <span class="token operator">=</span> require <span class="token string">"resty.redis"</span>    mysql <span class="token operator">=</span> require <span class="token string">"resty.mysql"</span>    cjson <span class="token operator">=</span> require <span class="token string">"cjson"</span><span class="token punctuation">&#125;</span>location <span class="token operator">/</span><span class="token punctuation">&#123;</span>default_type <span class="token string">"text/html"</span><span class="token punctuation">;</span><span class="token function">content_by_lua_block</span><span class="token punctuation">&#123;</span><span class="token comment">--获取请求的参数username</span><span class="token keyword">local</span> param <span class="token operator">=</span> ngx<span class="token punctuation">.</span>req<span class="token punctuation">.</span><span class="token function">get_uri_args</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">"username"</span><span class="token punctuation">]</span><span class="token comment">--建立mysql数据库的连接</span><span class="token keyword">local</span> db <span class="token operator">=</span> mysql<span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">local</span> ok<span class="token punctuation">,</span>err <span class="token operator">=</span> db<span class="token punctuation">:</span><span class="token function">connect</span><span class="token punctuation">&#123;</span>host<span class="token operator">=</span><span class="token string">"192.168.200.111"</span><span class="token punctuation">,</span>port<span class="token operator">=</span><span class="token number">3306</span><span class="token punctuation">,</span>user<span class="token operator">=</span><span class="token string">"root"</span><span class="token punctuation">,</span>password<span class="token operator">=</span><span class="token string">"123456"</span><span class="token punctuation">,</span>database<span class="token operator">=</span><span class="token string">"nginx_db"</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token keyword">not</span> ok <span class="token keyword">then</span> ngx<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token string">"failed connect to mysql:"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token keyword">end</span><span class="token comment">--设置连接超时时间</span>db<span class="token punctuation">:</span><span class="token function">set_timeout</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment">--查询数据</span><span class="token keyword">local</span> sql <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token keyword">not</span> param <span class="token keyword">then</span>sql<span class="token operator">=</span><span class="token string">"select * from users"</span><span class="token keyword">else</span>sql<span class="token operator">=</span><span class="token string">"select * from users where username="</span><span class="token operator">..</span><span class="token string">"'"</span><span class="token operator">..</span>param<span class="token operator">..</span><span class="token string">"'"</span><span class="token keyword">end</span><span class="token keyword">local</span> res<span class="token punctuation">,</span>err<span class="token punctuation">,</span>errcode<span class="token punctuation">,</span>sqlstate<span class="token operator">=</span>db<span class="token punctuation">:</span><span class="token function">query</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token keyword">not</span> res <span class="token keyword">then</span> ngx<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token string">"failed to query from mysql:"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token keyword">end</span><span class="token comment">--连接redis</span><span class="token keyword">local</span> rd <span class="token operator">=</span> redis<span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ok<span class="token punctuation">,</span>err <span class="token operator">=</span> rd<span class="token punctuation">:</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token string">"192.168.200.111"</span><span class="token punctuation">,</span><span class="token number">6379</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token keyword">not</span> ok <span class="token keyword">then</span> ngx<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token string">"failed to connect to redis:"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token keyword">end</span>rd<span class="token punctuation">:</span><span class="token function">set_timeout</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment">--循环遍历数据</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>v <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token keyword">do</span> rd<span class="token punctuation">:</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"user_"</span><span class="token operator">..</span>v<span class="token punctuation">.</span>username<span class="token punctuation">,</span>cjson<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">end</span>ngx<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span>rd<span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>db<span class="token punctuation">:</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx负载均衡</title>
      <link href="/2021/07/25/Nginx/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2021/07/25/Nginx/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx负载均衡"><a href="#Nginx负载均衡" class="headerlink" title="Nginx负载均衡"></a>Nginx负载均衡</h1><h2 id="负载均衡概述"><a href="#负载均衡概述" class="headerlink" title="负载均衡概述"></a>负载均衡概述</h2><p>早期的网站流量和业务功能都比较简单，单台服务器足以满足基本的需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也跟着越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器进行性能的水平扩展及避免单点故障出现。那么如何将不同用户的请求流量分发到不同的服务器上呢？</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1591631182469.png"></p><h2 id="负载均衡的原理及处理流程"><a href="#负载均衡的原理及处理流程" class="headerlink" title="负载均衡的原理及处理流程"></a>负载均衡的原理及处理流程</h2><p>系统的扩展可以分为纵向扩展和横向扩展。</p><p>纵向扩展是从单机的角度出发，通过增加系统的硬件处理能力来提升服务器的处理能力</p><p>横向扩展是通过添加机器来满足大型网站服务的处理能力。</p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1584602513812.png" style="zoom:67%;" /><p>这里面涉及到两个重要的角色分别是”应用集群”和”负载均衡器”。</p><p>应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理并返回响应的数据。</p><p>负载均衡器:将用户访问的请求根据对应的负载均衡算法，分发到集群中的一台服务器进行处理。</p><h3 id="负载均衡的作用"><a href="#负载均衡的作用" class="headerlink" title="负载均衡的作用"></a>负载均衡的作用</h3><p>1、解决服务器的高并发压力，提高应用程序的处理性能。</p><p>2、提供故障转移，实现高可用。</p><p>3、通过添加或减少服务器数量，增强网站的可扩展性。</p><p>4、在负载均衡器上进行过滤，可以提高系统的安全性。</p><h2 id="负载均衡常用的处理方式"><a href="#负载均衡常用的处理方式" class="headerlink" title="负载均衡常用的处理方式"></a>负载均衡常用的处理方式</h2><h4 id="方式一-用户手动选择"><a href="#方式一-用户手动选择" class="headerlink" title="方式一:用户手动选择"></a>方式一:用户手动选择</h4><p>这种方式比较原始，只要实现的方式就是在网站主页上面提供不同线路、不同服务器链接方式，让用户来选择自己访问的具体服务器，来实现负载均衡。</p><h4 id="方式二-DNS轮询方式"><a href="#方式二-DNS轮询方式" class="headerlink" title="方式二:DNS轮询方式"></a>方式二:DNS轮询方式</h4><p>DNS</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">域名系统（服务）协议（DNS）是一种分布式网络目录服务，主要用于域名与 IP 地址的相互转换。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>大多域名注册商都支持对同一个主机名添加多条A记录，这就是DNS轮询，DNS服务器将解析请求按照A记录的顺序，随机分配到不同的IP上，这样就能完成简单的负载均衡。DNS轮询的成本非常低，在一些不重要的服务器，被经常使用。</p><p>如下是我们为某一个域名添加的IP地址，用2台服务器来做负载均衡。</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1590064506355.png"></p><p>验证:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ping</span> www.nginx521.cn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>清空本地的dns缓存</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipconfig/flushdns<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们发现使用DNS来实现轮询，不需要投入过多的成本，虽然DNS轮询成本低廉，但是DNS负载均衡存在明显的缺点。</p><p>1.可靠性低</p><p>假设一个域名DNS轮询多台服务器，如果其中的一台服务器发生故障，那么所有的访问该服务器的请求将不会有所回应，即使你将该服务器的IP从DNS中去掉，但是由于各大宽带接入商将众多的DNS存放在缓存中，以节省访问时间，导致DNS不会实时更新。所以DNS轮流上一定程度上解决了负载均衡问题，但是却存在可靠性不高的缺点。</p><p>2.负载均衡不均衡</p><p>DNS负载均衡采用的是简单的轮询负载算法，不能区分服务器的差异，不能反映服务器的当前运行状态，不能做到为性能好的服务器多分配请求，另外本地计算机也会缓存已经解析的域名到IP地址的映射，这也会导致使用该DNS服务器的用户在一定时间内访问的是同一台Web服务器，从而引发Web服务器减的负载不均衡。</p><p>负载不均衡则会导致某几台服务器负荷很低，而另外几台服务器负荷确很高，处理请求的速度慢，配置高的服务器分配到的请求少，而配置低的服务器分配到的请求多。</p><h4 id="方式三-四-七层负载均衡"><a href="#方式三-四-七层负载均衡" class="headerlink" title="方式三:四/七层负载均衡"></a>方式三:四/七层负载均衡</h4><p>介绍四/七层负载均衡之前，我们先了解一个概念，OSI(open system interconnection),叫开放式系统互联模型，这个是由国际标准化组织ISO指定的一个不基于具体机型、操作系统或公司的网络体系结构。该模型将网络通信的工作分为七层。</p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1584693830966.png" style="zoom:67%;" /><p>应用层：为应用程序提供网络服务。</p><p>表示层：对数据进行格式化、编码、加密、压缩等操作。</p><p>会话层：建立、维护、管理会话连接。</p><p>传输层：建立、维护、管理端到端的连接，常见的有TCP/UDP。</p><p>网络层：IP寻址和路由选择</p><p>数据链路层：控制网络层与物理层之间的通信。</p><p>物理层：比特流传输。</p><p>所谓四层负载均衡指的是OSI七层模型中的传输层，主要是基于IP+PORT的负载均衡</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">实现四层负载均衡的方式：硬件：F5 BIG-IP、Radware等软件：LVS、Nginx、Hayproxy等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所谓的七层负载均衡指的是在应用层，主要是基于虚拟的URL或主机IP的负载均衡</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">实现七层负载均衡的方式：软件：Nginx、Hayproxy等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>四层和七层负载均衡的区别</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">四层负载均衡数据包是在底层就进行了分发，而七层负载均衡数据包则在最顶端进行分发，所以四层负载均衡的效率比七层负载均衡的要高。四层负载均衡不识别域名，而七层负载均衡识别域名。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>处理四层和七层负载以为其实还有二层、三层负载均衡，二层是在数据链路层基于mac地址来实现负载均衡，三层是在网络层一般采用虚拟IP地址的方式实现负载均衡。</p><p>实际环境采用的模式</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">四层负载<span class="token punctuation">(</span>LVS<span class="token punctuation">)</span>+七层负载<span class="token punctuation">(</span>Nginx<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Nginx七层负载均衡"><a href="#Nginx七层负载均衡" class="headerlink" title="Nginx七层负载均衡"></a>Nginx七层负载均衡</h3><p>Nginx要实现七层负载均衡需要用到proxy_pass代理模块配置。Nginx默认安装支持这个模块，我们不需要再做任何处理。Nginx的负载均衡是在Nginx的反向代理基础上把用户的请求根据指定的算法分发到一组【upstream虚拟服务池】。</p><h4 id="Nginx七层负载均衡的指令"><a href="#Nginx七层负载均衡的指令" class="headerlink" title="Nginx七层负载均衡的指令"></a>Nginx七层负载均衡的指令</h4><h5 id="upstream指令"><a href="#upstream指令" class="headerlink" title="upstream指令"></a>upstream指令</h5><p>该指令是用来定义一组服务器，它们可以是监听不同端口的服务器，并且也可以是同时监听TCP和Unix socket的服务器。服务器可以指定不同的权重，默认为1。</p><table><thead><tr><th>语法</th><th>upstream name {…}</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http</td></tr></tbody></table><h5 id="server指令"><a href="#server指令" class="headerlink" title="server指令"></a>server指令</h5><p>该指令用来指定后端服务器的名称和一些参数，可以使用域名、IP、端口或者unix socket</p><table><thead><tr><th>语法</th><th>server name [paramerters]</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>upstream</td></tr></tbody></table><h4 id="Nginx七层负载均衡的实现流程"><a href="#Nginx七层负载均衡的实现流程" class="headerlink" title="Nginx七层负载均衡的实现流程"></a>Nginx七层负载均衡的实现流程</h4><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1590248160635.png"></p><p>服务端设置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>    listen   <span class="token number">9001</span><span class="token punctuation">;</span>    server_name localhost<span class="token punctuation">;</span>    default_type text/html<span class="token punctuation">;</span>    location /<span class="token punctuation">&#123;</span>    <span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token string">'&lt;h1>192.168.200.146:9001&lt;/h1>'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>    listen   <span class="token number">9002</span><span class="token punctuation">;</span>    server_name localhost<span class="token punctuation">;</span>    default_type text/html<span class="token punctuation">;</span>    location /<span class="token punctuation">&#123;</span>    <span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token string">'&lt;h1>192.168.200.146:9002&lt;/h1>'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>    listen   <span class="token number">9003</span><span class="token punctuation">;</span>    server_name localhost<span class="token punctuation">;</span>    default_type text/html<span class="token punctuation">;</span>    location /<span class="token punctuation">&#123;</span>    <span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token string">'&lt;h1>192.168.200.146:9003&lt;/h1>'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>负载均衡器设置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">upstream backend<span class="token punctuation">&#123;</span>server <span class="token number">192.168</span>.200.146:9091<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9092<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9093<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen <span class="token number">8083</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /<span class="token punctuation">&#123;</span>proxy_pass http://backend<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="负载均衡状态"><a href="#负载均衡状态" class="headerlink" title="负载均衡状态"></a>负载均衡状态</h4><p>代理服务器在负责均衡调度中的状态有以下几个：</p><table><thead><tr><th>状态</th><th>概述</th></tr></thead><tbody><tr><td>down</td><td>当前的server暂时不参与负载均衡</td></tr><tr><td>backup</td><td>预留的备份服务器</td></tr><tr><td>max_fails</td><td>允许请求失败的次数</td></tr><tr><td>fail_timeout</td><td>经过max_fails失败后, 服务暂停时间</td></tr><tr><td>max_conns</td><td>限制最大的接收连接数</td></tr></tbody></table><h5 id="down"><a href="#down" class="headerlink" title="down"></a>down</h5><p>down:将该服务器标记为永久不可用，那么该代理服务器将不参与负载均衡。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">upstream backend<span class="token punctuation">&#123;</span>server <span class="token number">192.168</span>.200.146:9001 down<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9002server <span class="token number">192.168</span>.200.146:9003<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen <span class="token number">8083</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /<span class="token punctuation">&#123;</span>proxy_pass http://backend<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该状态一般会对需要停机维护的服务器进行设置。</p><h5 id="backup"><a href="#backup" class="headerlink" title="backup"></a>backup</h5><p>backup:将该服务器标记为备份服务器，当主服务器不可用时，将用来传递请求。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">upstream backend<span class="token punctuation">&#123;</span>server <span class="token number">192.168</span>.200.146:9001 down<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9002 backup<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9003<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen <span class="token number">8083</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /<span class="token punctuation">&#123;</span>proxy_pass http://backend<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时需要将9094端口的访问禁止掉来模拟下唯一能对外提供访问的服务宕机以后，backup的备份服务器就要开始对外提供服务，此时为了测试验证，我们需要使用防火墙来进行拦截。</p><p>介绍一个工具<code>firewall-cmd</code>,该工具是Linux提供的专门用来操作firewall的。</p><p>查询防火墙中指定的端口是否开放</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --query-port<span class="token operator">=</span><span class="token number">9001</span>/tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何开放一个指定的端口</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --permanent --add-port<span class="token operator">=</span><span class="token number">9002</span>/tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>批量添加开发端口</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --permanent --add-port<span class="token operator">=</span><span class="token number">9001</span>-9003/tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何移除一个指定的端口</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --permanent --remove-port<span class="token operator">=</span><span class="token number">9003</span>/tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重新加载</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">firewall-cmd --reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中</p><p>​     –permanent表示设置为持久</p><p>​     –add-port表示添加指定端口</p><p>​     –remove-port表示移除指定端口</p><h5 id="max-conns"><a href="#max-conns" class="headerlink" title="max_conns"></a>max_conns</h5><p>max_conns=number:用来设置代理服务器同时活动链接的最大数量，默认为0，表示不限制，使用该配置可以根据后端服务器处理请求的并发量来进行设置，防止后端服务器被压垮。</p><h5 id="max-fails和fail-timeout"><a href="#max-fails和fail-timeout" class="headerlink" title="max_fails和fail_timeout"></a>max_fails和fail_timeout</h5><p>max_fails=number:设置允许请求代理服务器失败的次数，默认为1。</p><p>fail_timeout=time:设置经过max_fails失败后，服务暂停的时间，默认是10秒。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">upstream backend<span class="token punctuation">&#123;</span>server <span class="token number">192.168</span>.200.133:9001 down<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.133:9002 backup<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.133:9003 <span class="token assign-left variable">max_fails</span><span class="token operator">=</span><span class="token number">3</span> <span class="token assign-left variable">fail_timeout</span><span class="token operator">=</span><span class="token number">15</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen <span class="token number">8083</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /<span class="token punctuation">&#123;</span>proxy_pass http://backend<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h4><p>介绍完Nginx负载均衡的相关指令后，我们已经能实现将用户的请求分发到不同的服务器上，那么除了采用默认的分配方式以外，我们还能采用什么样的负载算法?</p><p>Nginx的upstream支持如下六种方式的分配算法，分别是:</p><table><thead><tr><th>算法名称</th><th>说明</th></tr></thead><tbody><tr><td>轮询</td><td>默认方式</td></tr><tr><td>weight</td><td>权重方式</td></tr><tr><td>ip_hash</td><td>依据ip分配方式</td></tr><tr><td>least_conn</td><td>依据最少连接方式</td></tr><tr><td>url_hash</td><td>依据URL分配方式</td></tr><tr><td>fair</td><td>依据响应时间方式</td></tr></tbody></table><h5 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h5><p>是upstream模块负载均衡默认的策略。每个请求会按时间顺序逐个分配到不同的后端服务器。轮询不需要额外的配置。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">upstream backend<span class="token punctuation">&#123;</span>server <span class="token number">192.168</span>.200.146:9001 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9002<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9003<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen <span class="token number">8083</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /<span class="token punctuation">&#123;</span>proxy_pass http://backend<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="weight加权-加权轮询"><a href="#weight加权-加权轮询" class="headerlink" title="weight加权[加权轮询]"></a>weight加权[加权轮询]</h5><p>weight=number:用来设置服务器的权重，默认为1，权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的，所有此策略比较适合服务器的硬件配置差别比较大的情况。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">upstream backend<span class="token punctuation">&#123;</span>server <span class="token number">192.168</span>.200.146:9001 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9002 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9003 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen <span class="token number">8083</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /<span class="token punctuation">&#123;</span>proxy_pass http://backend<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h5><p>当对后端的多台动态应用服务器做负载均衡时，ip_hash指令能够将某个客户端IP的请求通过哈希算法定位到同一台后端服务器上。这样，当来自某一个IP的用户在后端Web服务器A上登录后，在访问该站点的其他URL，能保证其访问的还是后端web服务器A。</p><table><thead><tr><th>语法</th><th>ip_hash;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>upstream</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">upstream backend&#123;ip_hash;server 192.168.200.146:9001;server 192.168.200.146:9002;server 192.168.200.146:9003;&#125;server &#123;listen 8083;server_name localhost;location &#x2F;&#123;proxy_pass http:&#x2F;&#x2F;backend;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要额外多说一点的是使用ip_hash指令无法保证后端服务器的负载均衡，可能导致有些后端服务器接收到的请求多，有些后端服务器接收的请求少，而且设置后端服务器权重等方法将不起作用。</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1591706748677.png"></p><h5 id="least-conn"><a href="#least-conn" class="headerlink" title="least_conn"></a>least_conn</h5><p>最少连接，把请求转发给连接数较少的后端服务器。轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同；但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下，least_conn这种方式就可以达到更好的负载均衡效果。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">upstream backend<span class="token punctuation">&#123;</span>least_conn<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9001<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9002<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9003<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen <span class="token number">8083</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /<span class="token punctuation">&#123;</span>proxy_pass http://backend<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此负载均衡策略适合请求处理时间长短不一造成服务器过载的情况。</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1591809623736.png"></p><h5 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h5><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，要配合缓存命中来使用。同一个资源多次请求，可能会到达不同的服务器上，导致不必要的多次下载，缓存命中率不高，以及一些资源时间的浪费。而使用url_hash，可以使得同一个url（也就是同一个资源请求）会到达同一台服务器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">upstream backend<span class="token punctuation">&#123;</span><span class="token builtin class-name">hash</span> <span class="token operator">&amp;</span>request_uri<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9001<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9002<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9003<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen <span class="token number">8083</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /<span class="token punctuation">&#123;</span>proxy_pass http://backend<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问如下地址：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http://192.168.200.133:8083/ahttp://192.168.200.133:8083/bhttp://192.168.200.133:8083/c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1591812222306.png"></p><h5 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h5><p>fair采用的不是内建负载均衡使用的轮换的均衡算法，而是可以根据页面大小、加载时间长短智能的进行负载均衡。那么如何使用第三方模块的fair负载均衡策略。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">upstream backend<span class="token punctuation">&#123;</span>fair<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9001<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9002<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9003<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen <span class="token number">8083</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /<span class="token punctuation">&#123;</span>proxy_pass http://backend<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是如何直接使用会报错，因为fair属于第三方模块实现的负载均衡。需要添加<code>nginx-upstream-fair</code>,如何添加对应的模块:</p><ol><li>下载nginx-upstream-fair模块</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">下载地址为:https://github.com/gnosek/nginx-upstream-fair<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>将下载的文件上传到服务器并进行解压缩</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">unzip</span> nginx-upstream-fair-master.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>重命名资源</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> nginx-upstream-fair-master fair<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>使用./configure命令将资源添加到Nginx模块中</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure --add-module<span class="token operator">=</span>/root/fair<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li>编译</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译可能会出现如下错误，ngx_http_upstream_srv_conf_t结构中缺少default_port</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1584941470457.png"></p><p>解决方案:</p><p>在Nginx的源码中 src/http/ngx_http_upstream.h,找到<code>ngx_http_upstream_srv_conf_s</code>，在模块中添加添加default_port属性</p><pre class="line-numbers language-none"><code class="language-none">in_port_t   default_port<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1584943399597.png"></p><p>然后再进行make.</p><ol start="6"><li>更新Nginx</li></ol><p>​     6.1 将sbin目录下的nginx进行备份</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginxold<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    6.2 将安装目录下的objs中的nginx拷贝到sbin目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> objs<span class="token function">cp</span> nginx /usr/local/nginx/sbin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​     6.3 更新Nginx</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token punctuation">..</span>/<span class="token function">make</span> upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="7"><li>编译测试使用Nginx</li></ol><p>上面介绍了Nginx常用的负载均衡的策略，有人说是5种，是把轮询和加权轮询归为一种，也有人说是6种。那么在咱们以后的开发中到底使用哪种，这个需要根据实际项目的应用场景来决定的。</p><h4 id="负载均衡案例"><a href="#负载均衡案例" class="headerlink" title="负载均衡案例"></a>负载均衡案例</h4><h5 id="案例一：对所有请求实现一般轮询规则的负载均衡"><a href="#案例一：对所有请求实现一般轮询规则的负载均衡" class="headerlink" title="案例一：对所有请求实现一般轮询规则的负载均衡"></a>案例一：对所有请求实现一般轮询规则的负载均衡</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">upstream backend<span class="token punctuation">&#123;</span>server <span class="token number">192.168</span>.200.146:9001<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9002<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9003<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen <span class="token number">8083</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /<span class="token punctuation">&#123;</span>proxy_pass http://backend<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="案例二：对所有请求实现加权轮询规则的负载均衡"><a href="#案例二：对所有请求实现加权轮询规则的负载均衡" class="headerlink" title="案例二：对所有请求实现加权轮询规则的负载均衡"></a>案例二：对所有请求实现加权轮询规则的负载均衡</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">upstream backend<span class="token punctuation">&#123;</span>server <span class="token number">192.168</span>.200.146:9001 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9002 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9003 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen <span class="token number">8083</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /<span class="token punctuation">&#123;</span>proxy_pass http://backend<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="案例三：对特定资源实现负载均衡"><a href="#案例三：对特定资源实现负载均衡" class="headerlink" title="案例三：对特定资源实现负载均衡"></a>案例三：对特定资源实现负载均衡</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">upstream videobackend<span class="token punctuation">&#123;</span>server <span class="token number">192.168</span>.200.146:9001<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9002<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>upstream filebackend<span class="token punctuation">&#123;</span>server <span class="token number">192.168</span>.200.146:9003<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9004<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen <span class="token number">8084</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /video/ <span class="token punctuation">&#123;</span>proxy_pass http://videobackend<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>location /file/ <span class="token punctuation">&#123;</span>proxy_pass http://filebackend<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="案例四：对不同域名实现负载均衡"><a href="#案例四：对不同域名实现负载均衡" class="headerlink" title="案例四：对不同域名实现负载均衡"></a>案例四：对不同域名实现负载均衡</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">upstream itcastbackend<span class="token punctuation">&#123;</span>server <span class="token number">192.168</span>.200.146:9001<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9002<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>upstream itheimabackend<span class="token punctuation">&#123;</span>server <span class="token number">192.168</span>.200.146:9003<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9004<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen<span class="token number">8085</span><span class="token punctuation">;</span>server_name www.itcast.cn<span class="token punctuation">;</span>location / <span class="token punctuation">&#123;</span>proxy_pass http://itcastbackend<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen<span class="token number">8086</span><span class="token punctuation">;</span>server_name www.itheima.cn<span class="token punctuation">;</span>location / <span class="token punctuation">&#123;</span>proxy_pass http://itheimabackend<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="案例五：实现带有URL重写的负载均衡"><a href="#案例五：实现带有URL重写的负载均衡" class="headerlink" title="案例五：实现带有URL重写的负载均衡"></a>案例五：实现带有URL重写的负载均衡</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">upstream backend<span class="token punctuation">&#123;</span>server <span class="token number">192.168</span>.200.146:9001<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9002<span class="token punctuation">;</span>server <span class="token number">192.168</span>.200.146:9003<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen<span class="token number">80</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /file/ <span class="token punctuation">&#123;</span>rewrite ^<span class="token punctuation">(</span>/file/.*<span class="token punctuation">)</span> /server/<span class="token variable">$1</span> last<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>location / <span class="token punctuation">&#123;</span>proxy_pass http://backend<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Nginx四层负载均衡"><a href="#Nginx四层负载均衡" class="headerlink" title="Nginx四层负载均衡"></a>Nginx四层负载均衡</h3><p>Nginx在1.9之后，增加了一个stream模块，用来实现四层协议的转发、代理、负载均衡等。stream模块的用法跟http的用法类似，允许我们配置一组TCP或者UDP等协议的监听，然后通过proxy_pass来转发我们的请求，通过upstream添加多个后端服务，实现负载均衡。</p><p>四层协议负载均衡的实现，一般都会用到LVS、HAProxy、F5等，要么很贵要么配置很麻烦，而Nginx的配置相对来说更简单，更能快速完成工作。</p><h4 id="添加stream模块的支持"><a href="#添加stream模块的支持" class="headerlink" title="添加stream模块的支持"></a>添加stream模块的支持</h4><p>Nginx默认是没有编译这个模块的，需要使用到stream模块，那么需要在编译的时候加上<code>--with-stream</code>。</p><p>完成添加<code>--with-stream</code>的实现步骤:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">》将原有/usr/local/nginx/sbin/nginx进行备份》拷贝nginx之前的配置信息》在nginx的安装源码进行配置指定对应模块  ./configure --with-stream》通过make模板进行编译》将objs下面的nginx移动到/usr/local/nginx/sbin下》在源码目录下执行  <span class="token function">make</span> upgrade进行升级，这个可以实现不停机添加新模块的功能<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Nginx四层负载均衡的指令"><a href="#Nginx四层负载均衡的指令" class="headerlink" title="Nginx四层负载均衡的指令"></a>Nginx四层负载均衡的指令</h4><h5 id="stream指令"><a href="#stream指令" class="headerlink" title="stream指令"></a>stream指令</h5><p>该指令提供在其中指定流服务器指令的配置文件上下文。和http指令同级。</p><table><thead><tr><th>语法</th><th>stream { … }</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>main</td></tr></tbody></table><h5 id="upstream指令-1"><a href="#upstream指令-1" class="headerlink" title="upstream指令"></a>upstream指令</h5><p>该指令和http的upstream指令是类似的。</p><h4 id="四层负载均衡的案例"><a href="#四层负载均衡的案例" class="headerlink" title="四层负载均衡的案例"></a>四层负载均衡的案例</h4><h5 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h5><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1591897178807.png"></p><p>实现步骤</p><p>(1)准备Redis服务器,在一条服务器上准备三个Redis，端口分别是6379,6378</p><p>1.上传redis的安装包，<code>redis-4.0.14.tar.gz</code></p><p>2.将安装包进行解压缩</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> -zxf redis-4.0.14.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.进入redis的安装包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> redis-4.0.14<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.使用make和install进行编译和安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">PREFIX</span><span class="token operator">=</span>/usr/local/redis/redis01 <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5.拷贝redis配置文件<code>redis.conf</code>到/usr/local/redis/redis01/bin目录中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> redis.conf/usr/local/redis/redis01/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>6.修改redis.conf配置文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">port  <span class="token number">6379</span>      <span class="token comment">#redis的端口</span>daemonize <span class="token function">yes</span>   <span class="token comment">#后台启动redis</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>7.将redis01复制一份为redis02</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/redis<span class="token function">cp</span> -r redis01 redis02<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>8.将redis02文件文件夹中的redis.conf进行修改</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">port  <span class="token number">6378</span>      <span class="token comment">#redis的端口</span>daemonize <span class="token function">yes</span>   <span class="token comment">#后台启动redis</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>9.分别启动，即可获取两个Redis.并查看</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用Nginx将请求分发到不同的Redis服务器上。</p><p>(2)准备Tomcat服务器.</p><p>1.上传tomcat的安装包，<code>apache-tomcat-8.5.56.tar.gz</code></p><p>2.将安装包进行解压缩</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> -zxf apache-tomcat-8.5.56.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.进入tomcat的bin目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> apache-tomcat-8.5.56/bin./startup<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>nginx.conf配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stream <span class="token punctuation">&#123;</span>        upstream redisbackend <span class="token punctuation">&#123;</span>                server <span class="token number">192.168</span>.200.146:6379<span class="token punctuation">;</span>                server <span class="token number">192.168</span>.200.146:6378<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        upstream tomcatbackend <span class="token punctuation">&#123;</span>        server <span class="token number">192.168</span>.200.146:8080<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        server <span class="token punctuation">&#123;</span>                listen  <span class="token number">81</span><span class="token punctuation">;</span>                proxy_pass redisbackend<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        server <span class="token punctuation">&#123;</span>        listen<span class="token number">82</span><span class="token punctuation">;</span>        proxy_pass tomcatbackend<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问测试。</p><h1 id="Nginx缓存集成"><a href="#Nginx缓存集成" class="headerlink" title="Nginx缓存集成"></a>Nginx缓存集成</h1><h2 id="缓存的概念"><a href="#缓存的概念" class="headerlink" title="缓存的概念"></a>缓存的概念</h2><p>缓存就是数据交换的缓冲区(称作:Cache),当用户要获取数据的时候，会先从缓存中去查询获取数据，如果缓存中有就会直接返回给用户，如果缓存中没有，则会发请求从服务器重新查询数据，将数据返回给用户的同时将数据放入缓存，下次用户就会直接从缓存中获取数据。</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1591944051969.png"></p><p>缓存其实在很多场景中都有用到，比如：</p><table><thead><tr><th>场景</th><th>作用</th></tr></thead><tbody><tr><td>操作系统磁盘缓存</td><td>减少磁盘机械操作</td></tr><tr><td>数据库缓存</td><td>减少文件系统的IO操作</td></tr><tr><td>应用程序缓存</td><td>减少对数据库的查询</td></tr><tr><td>Web服务器缓存</td><td>减少对应用服务器请求次数</td></tr><tr><td>浏览器缓存</td><td>减少与后台的交互次数</td></tr></tbody></table><p>缓存的优点</p><p>​    1.减少数据传输，节省网络流量，加快响应速度，提升用户体验；</p><p>​    2.减轻服务器压力；</p><p>​    3.提供服务端的高可用性；</p><p>缓存的缺点</p><p>​    1.数据的不一致</p><p>​    2.增加成本</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1582295367198.png"></p><p>本次课程注解讲解的是Nginx,Nginx作为web服务器，Nginx作为Web缓存服务器，它介于客户端和应用服务器之间，当用户通过浏览器访问一个URL时，web缓存服务器会去应用服务器获取要展示给用户的内容，将内容缓存到自己的服务器上，当下一次请求到来时，如果访问的是同一个URL，web缓存服务器就会直接将之前缓存的内容返回给客户端，而不是向应用服务器再次发送请求。web缓存降低了应用服务器、数据库的负载，减少了网络延迟，提高了用户访问的响应速度，增强了用户的体验。</p><h2 id="Nginx的web缓存服务"><a href="#Nginx的web缓存服务" class="headerlink" title="Nginx的web缓存服务"></a>Nginx的web缓存服务</h2><p>Nginx是从0.7.48版开始提供缓存功能。Nginx是基于Proxy Store来实现的，其原理是把URL及相关组合当做Key,在使用MD5算法对Key进行哈希，得到硬盘上对应的哈希目录路径，从而将缓存内容保存在该目录中。它可以支持任意URL连接，同时也支持404/301/302这样的非200状态码。Nginx即可以支持对指定URL或者状态码设置过期时间，也可以使用purge命令来手动清除指定URL的缓存。</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1591947990200.png"></p><h2 id="Nginx缓存设置的相关指令"><a href="#Nginx缓存设置的相关指令" class="headerlink" title="Nginx缓存设置的相关指令"></a>Nginx缓存设置的相关指令</h2><p>Nginx的web缓存服务主要是使用<code>ngx_http_proxy_module</code>模块相关指令集来完成，接下来我们把常用的指令来进行介绍下。</p><h3 id="proxy-cache-path"><a href="#proxy-cache-path" class="headerlink" title="proxy_cache_path"></a>proxy_cache_path</h3><p>该指定用于设置缓存文件的存放路径</p><table><thead><tr><th>语法</th><th>proxy_cache_path path [levels=number] <br/>keys_zone=zone_name:zone_size [inactive=time][max_size=size];</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http</td></tr></tbody></table><p>path:缓存路径地址,如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/local/proxy_cache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>levels: 指定该缓存空间对应的目录，最多可以设置3层，每层取值为1|2如 :</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">levels</span><span class="token operator">=</span><span class="token number">1</span>:2   缓存空间有两层目录，第一次是1个字母，第二次是2个字母举例说明:itheima<span class="token punctuation">[</span>key<span class="token punctuation">]</span>通过MD5加密以后的值为 43c8233266edce38c2c9af0694e2107d<span class="token assign-left variable">levels</span><span class="token operator">=</span><span class="token number">1</span>:2   最终的存储路径为/usr/local/proxy_cache/d/07<span class="token assign-left variable">levels</span><span class="token operator">=</span><span class="token number">2</span>:1:2 最终的存储路径为/usr/local/proxy_cache/7d/0/21<span class="token assign-left variable">levels</span><span class="token operator">=</span><span class="token number">2</span>:2:2 最终的存储路径为??/usr/local/proxy_cache/7d/10/e2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>keys_zone:用来为这个缓存区设置名称和指定大小，如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">keys_zone</span><span class="token operator">=</span>itcast:200m  缓存区的名称是itcast,大小为200M,1M大概能存储8000个keys<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>inactive:指定缓存的数据多次时间未被访问就将被删除，如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">inactive</span><span class="token operator">=</span>1d   缓存数据在1天内没有被访问就会被删除<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>max_size:设置最大缓存空间，如果缓存空间存满，默认会覆盖缓存时间最长的资源，如:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">max_size</span><span class="token operator">=</span>20g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置实例:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http<span class="token punctuation">&#123;</span>proxy_cache_path /usr/local/proxy_cache <span class="token assign-left variable">keys_zone</span><span class="token operator">=</span>itcast:200m  <span class="token assign-left variable">levels</span><span class="token operator">=</span><span class="token number">1</span>:2:1 <span class="token assign-left variable">inactive</span><span class="token operator">=</span>1d <span class="token assign-left variable">max_size</span><span class="token operator">=</span>20g<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="proxy-cache"><a href="#proxy-cache" class="headerlink" title="proxy_cache"></a>proxy_cache</h3><p>该指令用来开启或关闭代理缓存，如果是开启则自定使用哪个缓存区来进行缓存。</p><table><thead><tr><th>语法</th><th>proxy_cache zone_name|off;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_cache off;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>zone_name：指定使用缓存区的名称</p><h3 id="proxy-cache-key"><a href="#proxy-cache-key" class="headerlink" title="proxy_cache_key"></a>proxy_cache_key</h3><p>该指令用来设置web缓存的key值，Nginx会根据key值MD5哈希存缓存。</p><table><thead><tr><th>语法</th><th>proxy_cache_key key;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_cache_key $scheme$proxy_host$request_uri;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><h3 id="proxy-cache-valid"><a href="#proxy-cache-valid" class="headerlink" title="proxy_cache_valid"></a>proxy_cache_valid</h3><p>该指令用来对不同返回状态码的URL设置不同的缓存时间</p><table><thead><tr><th>语法</th><th>proxy_cache_valid [code …] time;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">proxy_cache_valid <span class="token number">200</span> <span class="token number">302</span> 10m<span class="token punctuation">;</span>proxy_cache_valid <span class="token number">404</span> 1m<span class="token punctuation">;</span>为200和302的响应URL设置10分钟缓存，为404的响应URL设置1分钟缓存proxy_cache_valid any 1m<span class="token punctuation">;</span>对所有响应状态码的URL都设置1分钟缓存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="proxy-cache-min-uses"><a href="#proxy-cache-min-uses" class="headerlink" title="proxy_cache_min_uses"></a>proxy_cache_min_uses</h3><p>该指令用来设置资源被访问多少次后被缓存</p><table><thead><tr><th>语法</th><th>proxy_cache_min_uses number;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_cache_min_uses 1;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><h3 id="proxy-cache-methods"><a href="#proxy-cache-methods" class="headerlink" title="proxy_cache_methods"></a>proxy_cache_methods</h3><p>该指令用户设置缓存哪些HTTP方法</p><table><thead><tr><th>语法</th><th>proxy_cache_methods GET|HEAD|POST;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_cache_methods GET HEAD;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>默认缓存HTTP的GET和HEAD方法，不缓存POST方法。</p><h2 id="Nginx缓存设置案例"><a href="#Nginx缓存设置案例" class="headerlink" title="Nginx缓存设置案例"></a>Nginx缓存设置案例</h2><h4 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h4><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1591959569463.png"></p><h4 id="步骤实现"><a href="#步骤实现" class="headerlink" title="步骤实现"></a>步骤实现</h4><p>1.环境准备</p><p>应用服务器的环境准备</p><p>（1）在192.168.200.146服务器上的tomcat的webapps下面添加一个js目录，并在js目录中添加一个jquery.js文件</p><p>（2）启动tomcat</p><p>（3）访问测试</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http://192.168.200.146:8080/js/jquery.js<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Nginx的环境准备</p><p>（1）完成Nginx反向代理配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http<span class="token punctuation">&#123;</span>upstream backend<span class="token punctuation">&#123;</span>server <span class="token number">192.168</span>.200.146:8080<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen       <span class="token number">8080</span><span class="token punctuation">;</span>        server_name  localhost<span class="token punctuation">;</span>        location / <span class="token punctuation">&#123;</span>        proxy_pass http://backend/js/<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）完成Nginx缓存配置</p><p>4.添加缓存配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http<span class="token punctuation">&#123;</span>proxy_cache_path /usr/local/proxy_cache <span class="token assign-left variable">levels</span><span class="token operator">=</span><span class="token number">2</span>:1 <span class="token assign-left variable">keys_zone</span><span class="token operator">=</span>itcast:200m <span class="token assign-left variable">inactive</span><span class="token operator">=</span>1d <span class="token assign-left variable">max_size</span><span class="token operator">=</span>20g<span class="token punctuation">;</span>upstream backend<span class="token punctuation">&#123;</span>server <span class="token number">192.168</span>.200.146:8080<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen       <span class="token number">8080</span><span class="token punctuation">;</span>        server_name  localhost<span class="token punctuation">;</span>        location / <span class="token punctuation">&#123;</span>        proxy_cache itcast<span class="token punctuation">;</span>            proxy_cache_key itheima<span class="token punctuation">;</span>            proxy_cache_min_uses <span class="token number">5</span><span class="token punctuation">;</span>            proxy_cache_valid <span class="token number">200</span> 5d<span class="token punctuation">;</span>            proxy_cache_valid <span class="token number">404</span> 30s<span class="token punctuation">;</span>            proxy_cache_valid any 1m<span class="token punctuation">;</span>            add_header nginx-cache <span class="token string">"<span class="token variable">$upstream_cache_status</span>"</span><span class="token punctuation">;</span>        proxy_pass http://backend/js/<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Nginx缓存的清除"><a href="#Nginx缓存的清除" class="headerlink" title="Nginx缓存的清除"></a>Nginx缓存的清除</h2><h3 id="方式一-删除对应的缓存目录"><a href="#方式一-删除对应的缓存目录" class="headerlink" title="方式一:删除对应的缓存目录"></a>方式一:删除对应的缓存目录</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> -rf /usr/local/proxy_cache/<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="方式二-使用第三方扩展模块"><a href="#方式二-使用第三方扩展模块" class="headerlink" title="方式二:使用第三方扩展模块"></a>方式二:使用第三方扩展模块</h3><h4 id="ngx-cache-purge"><a href="#ngx-cache-purge" class="headerlink" title="ngx_cache_purge"></a>ngx_cache_purge</h4><p>（1）下载ngx_cache_purge模块对应的资源包，并上传到服务器上。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ngx_cache_purge-2.3.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）对资源文件进行解压缩</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> -zxf ngx_cache_purge-2.3.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（3）修改文件夹名称，方便后期配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> ngx_cache_purge-2.3 purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（4）查询Nginx的配置参数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx -V<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（5）进入Nginx的安装目录，使用./configure进行参数配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure --add-module<span class="token operator">=</span>/root/nginx/module/purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（6）使用make进行编译</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（7）将nginx安装目录的nginx二级制可执行文件备份</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginxold<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（8）将编译后的objs中的nginx拷贝到nginx的sbin目录下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> objs/nginx /usr/local/nginx/sbin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（9）使用make进行升级</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（10）在nginx配置文件中进行如下配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span>location ~/purge<span class="token punctuation">(</span>/.*<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>proxy_cache_purge itcast itheima<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Nginx设置资源不缓存"><a href="#Nginx设置资源不缓存" class="headerlink" title="Nginx设置资源不缓存"></a>Nginx设置资源不缓存</h2><p>前面咱们已经完成了Nginx作为web缓存服务器的使用。但是我们得思考一个问题就是不是所有的数据都适合进行缓存。比如说对于一些经常发生变化的数据。如果进行缓存的话，就很容易出现用户访问到的数据不是服务器真实的数据。所以对于这些资源我们在缓存的过程中就需要进行过滤，不进行缓存。</p><p>Nginx也提供了这块的功能设置，需要使用到如下两个指令</p><p>proxy_no_cache</p><p>该指令是用来定义不将数据进行缓存的条件。</p><table><thead><tr><th>语法</th><th>proxy_no_cache string …;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>配置实例</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">proxy_no_cache <span class="token variable">$cookie_nocache</span> <span class="token variable">$arg_nocache</span> <span class="token variable">$arg_comment</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>proxy_cache_bypass</p><p>该指令是用来设置不从缓存中获取数据的条件。</p><table><thead><tr><th>语法</th><th>proxy_cache_bypass string …;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>配置实例</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">proxy_cache_bypass <span class="token variable">$cookie_nocache</span> <span class="token variable">$arg_nocache</span> <span class="token variable">$arg_comment</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述两个指令都有一个指定的条件，这个条件可以是多个，并且多个条件中至少有一个不为空且不等于”0”,则条件满足成立。上面给的配置实例是从官方网站获取的，里面使用到了三个变量，分别是$cookie_nocache、$arg_nocache、$arg_comment</p><h3 id="cookie-nocache、-arg-nocache、-arg-comment"><a href="#cookie-nocache、-arg-nocache、-arg-comment" class="headerlink" title="$cookie_nocache、$arg_nocache、$arg_comment"></a>$cookie_nocache、$arg_nocache、$arg_comment</h3><p>这三个参数分别代表的含义是:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$cookie_nocache</span>指的是当前请求的cookie中键的名称为nocache对应的值<span class="token variable">$arg_nocache</span>和<span class="token variable">$arg_comment</span>指的是当前请求的参数中属性名为nocache和comment对应的属性值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>案例演示下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">log_format params <span class="token variable">$cookie_nocache</span> <span class="token operator">|</span> <span class="token variable">$arg_nocache</span> <span class="token operator">|</span> <span class="token variable">$arg_comment</span>；server<span class="token punctuation">&#123;</span>listen<span class="token number">8081</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /<span class="token punctuation">&#123;</span>access_log logs/access_params.log params<span class="token punctuation">;</span>add_header Set-Cookie <span class="token string">'nocache=999'</span><span class="token punctuation">;</span>root html<span class="token punctuation">;</span>index index.html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>设置不缓存资源的配置方案</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span>listen<span class="token number">8080</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location / <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$request_uri</span> ~ /.*<span class="token punctuation">\</span>.js$<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token builtin class-name">set</span> <span class="token variable">$nocache</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>proxy_no_cache <span class="token variable">$nocache</span> <span class="token variable">$cookie_nocache</span> <span class="token variable">$arg_nocache</span> <span class="token variable">$arg_comment</span><span class="token punctuation">;</span>        proxy_cache_bypass <span class="token variable">$nocache</span> <span class="token variable">$cookie_nocache</span> <span class="token variable">$arg_nocache</span> <span class="token variable">$arg_comment</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx进阶篇（二）</title>
      <link href="/2021/07/25/Nginx/Nginx%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2021/07/25/Nginx/Nginx%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Rewrite功能配置"><a href="#Rewrite功能配置" class="headerlink" title="Rewrite功能配置"></a>Rewrite功能配置</h2><p>Rewrite是Nginx服务器提供的一个重要基本功能，是Web服务器产品中几乎必备的功能。主要的作用是用来实现URL的重写。<a href="http://www.jd.com/">www.jd.com</a><br>注意:Nginx服务器的Rewrite功能的实现依赖于PCRE的支持，因此在编译安装Nginx服务器之前，需要安装PCRE库。Nginx使用的是ngx_http_rewrite_module模块来解析和处理Rewrite功能的相关配置。</p><p>Rewrite的相关命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">set指令if指令break指令return指令rewrite指令rewrite_log指令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Rewrite的应用场景</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">域名跳转域名镜像独立域名目录自动添加<span class="token string">"/"</span>合并目录防盗链的实现<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Rewrite的相关指令"><a href="#Rewrite的相关指令" class="headerlink" title="Rewrite的相关指令"></a>Rewrite的相关指令</h3><h4 id="set指令"><a href="#set指令" class="headerlink" title="set指令"></a>set指令</h4><p>该指令用来设置一个新的变量。</p><table><thead><tr><th>语法</th><th>set $variable value;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location、if</td></tr></tbody></table><p>variable:变量的名称，该变量名称要用”$”作为变量的第一个字符，且不要与Nginx服务器预设的全局变量同名。</p><p>value:变量的值，可以是字符串、其他变量或者变量的组合等。</p><h4 id="Rewrite常用全局变量"><a href="#Rewrite常用全局变量" class="headerlink" title="Rewrite常用全局变量"></a>Rewrite常用全局变量</h4><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>$args</td><td>变量中存放了请求URL中的请求参数。比如<a href="http://192.168.200.133/server?arg1=value1&amp;args2=value2%E4%B8%AD%E7%9A%84&quot;arg1=value1&amp;arg2=value2&quot;%EF%BC%8C%E5%8A%9F%E8%83%BD%E5%92%8C$query_string%E4%B8%80%E6%A0%B7">http://192.168.200.133/server?arg1=value1&amp;args2=value2中的&quot;arg1=value1&amp;arg2=value2&quot;，功能和$query_string一样</a></td></tr><tr><td>$http_user_agent</td><td>变量存储的是用户访问服务的代理信息(如果通过浏览器访问，记录的是浏览器的相关版本信息)</td></tr><tr><td>$host</td><td>变量存储的是访问服务器的server_name值</td></tr><tr><td>$document_uri</td><td>变量存储的是当前访问地址的URI。比如<a href="http://192.168.200.133/server?id=10&amp;name=zhangsan%E4%B8%AD%E7%9A%84&quot;/server&quot;%EF%BC%8C%E5%8A%9F%E8%83%BD%E5%92%8C$uri%E4%B8%80%E6%A0%B7">http://192.168.200.133/server?id=10&amp;name=zhangsan中的&quot;/server&quot;，功能和$uri一样</a></td></tr><tr><td>$document_root</td><td>变量存储的是当前请求对应location的root值，如果未设置，默认指向Nginx自带html目录所在位置</td></tr><tr><td>$content_length</td><td>变量存储的是请求头中的Content-Length的值</td></tr><tr><td>$content_type</td><td>变量存储的是请求头中的Content-Type的值</td></tr><tr><td>$http_cookie</td><td>变量存储的是客户端的cookie信息，可以通过add_header Set-Cookie ‘cookieName=cookieValue’来添加cookie数据</td></tr><tr><td>$limit_rate</td><td>变量中存储的是Nginx服务器对网络连接速率的限制，也就是Nginx配置中对limit_rate指令设置的值，默认是0，不限制。</td></tr><tr><td>$remote_addr</td><td>变量中存储的是客户端的IP地址</td></tr><tr><td>$remote_port</td><td>变量中存储了客户端与服务端建立连接的端口号</td></tr><tr><td>$remote_user</td><td>变量中存储了客户端的用户名，需要有认证模块才能获取</td></tr><tr><td>$scheme</td><td>变量中存储了访问协议</td></tr><tr><td>$server_addr</td><td>变量中存储了服务端的地址</td></tr><tr><td>$server_name</td><td>变量中存储了客户端请求到达的服务器的名称</td></tr><tr><td>$server_port</td><td>变量中存储了客户端请求到达服务器的端口号</td></tr><tr><td>$server_protocol</td><td>变量中存储了客户端请求协议的版本，比如”HTTP/1.1”</td></tr><tr><td>$request_body_file</td><td>变量中存储了发给后端服务器的本地文件资源的名称</td></tr><tr><td>$request_method</td><td>变量中存储了客户端的请求方式，比如”GET”,”POST”等</td></tr><tr><td>$request_filename</td><td>变量中存储了当前请求的资源文件的路径名</td></tr><tr><td>$request_uri</td><td>变量中存储了当前请求的URI，并且携带请求参数，比如<a href="http://192.168.200.133/server?id=10&amp;name=zhangsan%E4%B8%AD%E7%9A%84&quot;/server?id=10&amp;name=zhangsan&quot;">http://192.168.200.133/server?id=10&amp;name=zhangsan中的&quot;/server?id=10&amp;name=zhangsan&quot;</a></td></tr></tbody></table><p>上述参数还可以在日志文件中使用，这个就要用到前面我们介绍的<code>log_format</code>指令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">log_format main <span class="token string">'$remote_addr - $request - $status-$request_uri  $http_user_agent'</span><span class="token punctuation">;</span>access_log logs/access.log main<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h4><p>该指令用来支持条件判断，并根据条件判断结果选择不同的Nginx配置。</p><table><thead><tr><th>语法</th><th>if  (condition){…}</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location</td></tr></tbody></table><p>condition为判定条件，可以支持以下写法：</p><ol><li>变量名。如果变量名对应的值为空字符串或”0”，if都判断为false,其他条件为true。</li></ol><pre class="line-numbers language-bsh" data-language="bsh"><code class="language-bsh">if ($param)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>使用”=”和”!=”比较变量和字符串是否相等，满足条件为true，不满足为false</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$request_method</span> <span class="token operator">=</span> POST<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token builtin class-name">return</span> <span class="token number">405</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：此处和Java不太一样的地方是字符串不需要添加引号,并且等号和不等号前后到需要加空格。</p><ol start="3"><li><p>使用正则表达式对变量进行匹配，匹配成功返回true，否则返回false。变量与正则表达式之间使用”<del>“,”</del>*”,”!<del>“,”!</del>*“来连接。</p><p>“~”代表匹配正则表达式过程中区分大小写，</p><p>“~*“代表匹配正则表达式过程中不区分大小写</p><p>“!<del>“和”!</del>*“刚好和上面取相反值，如果匹配上返回false,匹配不上返回true</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$http_user_agent</span> ~ MSIE<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">#$http_user_agent的值中是否包含MSIE字符串，如果包含返回true</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：正则表达式字符串一般不需要加引号，但是如果字符串中包含”}”或者是”;”等字符时，就需要把引号加上。</p><ol start="4"><li>判断请求的文件是否存在使用”-f”和”!-f”,</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">(</span>-f <span class="token variable">$request_filename</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">#判断请求的文件是否存在</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>-f <span class="token variable">$request_filename</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">#判断请求的文件是否不存在</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li><p>判断请求的目录是否存在使用”-d”和”!-d”</p></li><li><p>判断请求的目录或者文件是否存在使用”-e”和”!-e”</p></li><li><p>判断请求的文件是否可执行使用”-x”和”!-x”</p></li></ol><h4 id="break指令"><a href="#break指令" class="headerlink" title="break指令"></a>break指令</h4><p>该指令用于中断当前相同作用域中的其他Nginx配置。与该指令处于同一作用域的Nginx配置中，位于它前面的指令配置生效，位于后面的指令配置无效。并且break还有另外一个功能就是终止当前的匹配并把当前的URI在本location进行重定向访问处理。</p><table><thead><tr><th>语法</th><th>break;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location、if</td></tr></tbody></table><p>例子:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location /testbreak<span class="token punctuation">&#123;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">set</span> <span class="token variable">$username</span> TOM<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$args</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Set <span class="token variable">$username</span> JERRY<span class="token punctuation">;</span>        <span class="token builtin class-name">break</span><span class="token punctuation">;</span><span class="token builtin class-name">set</span> <span class="token variable">$username</span> ROSE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>add_header username <span class="token variable">$username</span><span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token variable">$username</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="return指令"><a href="#return指令" class="headerlink" title="return指令"></a>return指令</h4><p>该指令用于完成对请求的处理，直接向客户端返回。在return后的所有Nginx配置都是无效的。</p><table><thead><tr><th>语法</th><th>return code [text];<br/>return code URL;<br/>return URL;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location、if</td></tr></tbody></table><p>code:为返回给客户端的HTTP状态代理。可以返回的状态代码为0~999的任意HTTP状态代理</p><p>text:为返回给客户端的响应体内容，支持变量的使用</p><p>URL:为返回给客户端的URL地址</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location /testreturn <span class="token punctuation">&#123;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> success<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>location /testreturn <span class="token punctuation">&#123;</span><span class="token builtin class-name">return</span> https://www.baidu.com<span class="token punctuation">;</span> // <span class="token number">302</span>重定向到百度<span class="token punctuation">&#125;</span>location /testreturn <span class="token punctuation">&#123;</span><span class="token builtin class-name">return</span> <span class="token number">302</span> https://www.baidu.com<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>location /testreturn <span class="token punctuation">&#123;</span><span class="token builtin class-name">return</span> <span class="token number">302</span> www.baidu.com<span class="token punctuation">;</span>//不允许这么写<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="rewrite指令"><a href="#rewrite指令" class="headerlink" title="rewrite指令"></a>rewrite指令</h4><p>该指令通过正则表达式的使用来改变URI。可以同时存在一个或者多个指令，按照顺序依次对URL进行匹配和处理。</p><table><thead><tr><th>语法</th><th>rewrite regex replacement [flag];</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location、if</td></tr></tbody></table><p>regex:用来匹配URI的正则表达式</p><p>replacement:匹配成功后，用于替换URI中被截取内容的字符串。如果该字符串是以”http://“或者”https://“开头的，则不会继续向下对URI进行其他处理，而是直接返回重写后的URI给客户端。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location rewrite <span class="token punctuation">&#123;</span>rewrite ^/rewrite/url<span class="token punctuation">\</span>w*$ https://www.baidu.com<span class="token punctuation">;</span>rewrite ^/rewrite/<span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">\</span>w*$ /<span class="token variable">$1</span><span class="token punctuation">;</span>rewrite ^/rewrite/<span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">\</span>w*$ /<span class="token variable">$1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>location /test<span class="token punctuation">&#123;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> test_success<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>location /demo<span class="token punctuation">&#123;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> demo_success<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>flag:用来设置rewrite对URI的处理行为，可选值有如下：</p><ul><li>last:终止继续在本location块中处理接收到的URI，并将此处重写的URI作为一个新的URI，使用各location块进行处理。该标志将重写后的URI重写在server块中执行，为重写后的URI提供了转入到其他location块的机会。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location rewrite <span class="token punctuation">&#123;</span>rewrite ^/rewrite/<span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">\</span>w*$ /<span class="token variable">$1</span> last<span class="token punctuation">;</span>rewrite ^/rewrite/<span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">\</span>w*$ /<span class="token variable">$1</span> last<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>location /test<span class="token punctuation">&#123;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> test_success<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>location /demo<span class="token punctuation">&#123;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> demo_success<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问 <code>http://192.168.200.133:8081/rewrite/testabc</code>,能正确访问</p><ul><li>break：将此处重写的URI作为一个新的URI,在本块中继续进行处理。该标志将重写后的地址在当前的location块中执行，不会将新的URI转向其他的location块。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location rewrite <span class="token punctuation">&#123;</span>    <span class="token comment">#/test   /usr/local/nginx/html/test/index.html</span>rewrite ^/rewrite/<span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">\</span>w*$ /<span class="token variable">$1</span> <span class="token builtin class-name">break</span><span class="token punctuation">;</span>rewrite ^/rewrite/<span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">\</span>w*$ /<span class="token variable">$1</span> <span class="token builtin class-name">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>location /test<span class="token punctuation">&#123;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> test_success<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>location /demo<span class="token punctuation">&#123;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> demo_success<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问 <code>http://192.168.200.133:8081/rewrite/demoabc</code>,页面报404错误</p><ul><li>redirect：将重写后的URI返回给客户端，状态码为302，指明是临时重定向URI,主要用在replacement变量不是以”http://“或者”https://“开头的情况。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location rewrite <span class="token punctuation">&#123;</span>rewrite ^/rewrite/<span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">\</span>w*$ /<span class="token variable">$1</span> redirect<span class="token punctuation">;</span>rewrite ^/rewrite/<span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">\</span>w*$ /<span class="token variable">$1</span> redirect<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>location /test<span class="token punctuation">&#123;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> test_success<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>location /demo<span class="token punctuation">&#123;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> demo_success<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问<code>http://192.168.200.133:8081/rewrite/testabc</code>请求会被临时重定向，浏览器地址也会发生改变</p><ul><li>permanent：将重写后的URI返回给客户端，状态码为301，指明是永久重定向URI,主要用在replacement变量不是以”http://“或者”https://“开头的情况。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location rewrite <span class="token punctuation">&#123;</span>rewrite ^/rewrite/<span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">\</span>w*$ /<span class="token variable">$1</span> permanent<span class="token punctuation">;</span>rewrite ^/rewrite/<span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">\</span>w*$ /<span class="token variable">$1</span> permanent<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>location /test<span class="token punctuation">&#123;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> test_success<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>location /demo<span class="token punctuation">&#123;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> demo_success<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问<code>http://192.168.200.133:8081/rewrite/testabc</code>请求会被永久重定向，浏览器地址也会发生改变</p><h4 id="rewrite-log指令"><a href="#rewrite-log指令" class="headerlink" title="rewrite_log指令"></a>rewrite_log指令</h4><p>该指令配置是否开启URL重写日志的输出功能。</p><table><thead><tr><th>语法</th><th>rewrite_log on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>rewrite_log off;</td></tr><tr><td>位置</td><td>http、server、location、if</td></tr></tbody></table><p>开启后，URL重写的相关日志将以notice级别输出到error_log指令配置的日志文件汇总。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rewrite_log on<span class="token punctuation">;</span>error_log  logs/error.log notice<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Rewrite的案例"><a href="#Rewrite的案例" class="headerlink" title="Rewrite的案例"></a>Rewrite的案例</h3><h4 id="域名跳转"><a href="#域名跳转" class="headerlink" title="域名跳转"></a>域名跳转</h4><p>》问题分析</p><p>先来看一个效果，如果我们想访问京东网站，大家都知道我们可以输入<code>www.jd.com</code>,但是同样的我们也可以输入<code>www.360buy.com</code>同样也都能访问到京东网站。这个其实是因为京东刚开始的时候域名就是<a href="http://www.360buy.com,后面由于各种原因把自己的域名换成了www.jd.com/">www.360buy.com，后面由于各种原因把自己的域名换成了www.jd.com</a>, 虽然说域名变量，但是对于以前只记住了<a href="http://www.360buy.com的用户来说,我们如何把这部分用户也迁移到我们新域名的访问上来,针对于这个问题,我们就可以使用nginx中rewrite的域名跳转来解决./">www.360buy.com的用户来说，我们如何把这部分用户也迁移到我们新域名的访问上来，针对于这个问题，我们就可以使用Nginx中Rewrite的域名跳转来解决。</a></p><p>》环境准备</p><ul><li>准备三个域名：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/hosts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1   www.itcast.cn<span class="token number">127.0</span>.0.1   www.itheima.cn<span class="token number">127.0</span>.0.1   www.itheima.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>通过Nginx实现访问<a href="http://www.itcast.cn/">www.itcast.cn</a></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name www.itcast.cn<span class="token punctuation">;</span>location /<span class="token punctuation">&#123;</span>default_type text/html<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token string">'&lt;h1>welcome to itcast&lt;/h1>'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>》通过Rewrite完成将<a href="http://www.ithema.com和www.itheima.cn的请求跳转到www.itcast.com/">www.ithema.com和www.itheima.cn的请求跳转到www.itcast.com</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name www.itheima.com www.itheima.cn<span class="token punctuation">;</span>rewrite ^/ http://www.itcast.cn<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题描述:如何在域名跳转的过程中携带请求的URI？</p><p>修改配置信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name www.itheima.com www.itheima.cn<span class="token punctuation">;</span>rewrite ^<span class="token punctuation">(</span>.*<span class="token punctuation">)</span> http://www.itcast.cn<span class="token variable">$1</span>；<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="域名镜像"><a href="#域名镜像" class="headerlink" title="域名镜像"></a>域名镜像</h4><p>镜像网站指定是将一个完全相同的网站分别放置到几台服务器上，并分别使用独立的URL进行访问。其中一台服务器上的网站叫主站，其他的为镜像网站。镜像网站和主站没有太大的区别，可以把镜像网站理解为主站的一个备份节点。可以通过镜像网站提供网站在不同地区的响应速度。镜像网站可以平衡网站的流量负载、可以解决网络宽带限制、封锁等。</p><p>而我们所说的域名镜像和网站镜像比较类似，上述案例中，将<a href="http://www.itheima.com和/">www.itheima.com和</a> <a href="http://www.itheima.cn都能跳转到www.itcast.cn,那么www.itcast.cn我们就可以把它起名叫主域名,其他两个就是我们所说的镜像域名,当然如果我们不想把整个网站做镜像,只想为其中某一个子目录下的资源做镜像,我们可以在location块中配置rewrite功能,比如/">www.itheima.cn都能跳转到www.itcast.cn，那么www.itcast.cn我们就可以把它起名叫主域名，其他两个就是我们所说的镜像域名，当然如果我们不想把整个网站做镜像，只想为其中某一个子目录下的资源做镜像，我们可以在location块中配置rewrite功能，比如</a>:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>    listen          <span class="token number">80</span><span class="token punctuation">;</span>    server_name     www.itheima.cn www.itheima.com<span class="token punctuation">;</span>    location /user <span class="token punctuation">&#123;</span>    rewrite ^/user<span class="token punctuation">(</span>.*<span class="token punctuation">)</span>$ http://www.itcast.cn<span class="token variable">$1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    location /emp<span class="token punctuation">&#123;</span>        default_type text/html<span class="token punctuation">;</span>        <span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token string">'&lt;h1>emp_success&lt;/h1>'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="独立域名"><a href="#独立域名" class="headerlink" title="独立域名"></a>独立域名</h4><p>一个完整的项目包含多个模块，比如购物网站有商品搜索模块、商品详情模块和购物车模块等，那么我们如何为每一个模块设置独立的域名。</p><p>需求：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http://search.itcast.com:81  访问商品搜索模块http://item.itcast.com:82  访问商品详情模块http://cart.itcast.com:83  访问商品购物车模块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span>listen <span class="token number">81</span><span class="token punctuation">;</span>server_name search.itcast.com<span class="token punctuation">;</span>rewrite ^<span class="token punctuation">(</span>.*<span class="token punctuation">)</span> http://www.itcast.cn/search<span class="token variable">$1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server<span class="token punctuation">&#123;</span>listen <span class="token number">82</span><span class="token punctuation">;</span>server_name item.itcast.com<span class="token punctuation">;</span>rewrite ^<span class="token punctuation">(</span>.*<span class="token punctuation">)</span> http://www.itcast.cn/item<span class="token variable">$1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server<span class="token punctuation">&#123;</span>listen <span class="token number">83</span><span class="token punctuation">;</span>server_name cart.itcast.com<span class="token punctuation">;</span>rewrite ^<span class="token punctuation">(</span>.*<span class="token punctuation">)</span> http://www.itcast.cn/cart<span class="token variable">$1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="目录自动添加”-“"><a href="#目录自动添加”-“" class="headerlink" title="目录自动添加”/“"></a>目录自动添加”/“</h4><p>问题描述</p><p>通过一个例子来演示下问题:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen<span class="token number">8082</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /heima <span class="token punctuation">&#123;</span>root html<span class="token punctuation">;</span>index index.html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过<code>http://192.168.200.133:8082/heima</code>和通过<code>http://192.168.200.133:8082/heima/</code>访问的区别？</p><p>如果不加斜杠，Nginx服务器内部会自动做一个301的重定向，重定向的地址会有一个指令叫server_name_in_redirect on|off;来决定重定向的地址：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">如果该指令为on重定向的地址为:  http://server_name:8082/目录名/<span class="token punctuation">;</span>http://localhost:8082/heima/如果该指令为off重定向的地址为:  http://原URL中的域名:8082/目录名/<span class="token punctuation">;</span>http://192.168.200.133:8082/heima/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以就拿刚才的地址来说，<a href="http://192.168.200.133:8082/heima%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%8A%A0%E6%96%9C%E6%9D%A0%EF%BC%8C%E9%82%A3%E4%B9%88%E6%8C%89%E7%85%A7%E4%B8%8A%E8%BF%B0%E8%A7%84%E5%88%99%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%8C%87%E4%BB%A4server_name_in_redirect%E4%B8%BAon%EF%BC%8C%E5%88%99301%E9%87%8D%E5%AE%9A%E5%90%91%E5%9C%B0%E5%9D%80%E5%8F%98%E4%B8%BA">http://192.168.200.133:8082/heima如果不加斜杠，那么按照上述规则，如果指令server_name_in_redirect为on，则301重定向地址变为</a> <a href="http://localhost:8082/heima/,%E5%A6%82%E6%9E%9C%E4%B8%BAoff%EF%BC%8C%E5%88%99301%E9%87%8D%E5%AE%9A%E5%90%91%E5%9C%B0%E5%9D%80%E5%8F%98%E4%B8%BAhttp://192.168.200.133:8082/heima/%E3%80%82%E5%90%8E%E9%9D%A2%E8%BF%99%E4%B8%AA%E6%98%AF%E6%AD%A3%E5%B8%B8%E7%9A%84%EF%BC%8C%E5%89%8D%E9%9D%A2%E5%9C%B0%E5%9D%80%E5%B0%B1%E6%9C%89%E9%97%AE%E9%A2%98%E3%80%82">http://localhost:8082/heima/,如果为off，则301重定向地址变为http://192.168.200.133:8082/heima/。后面这个是正常的，前面地址就有问题。</a></p><p>注意server_name_in_redirect指令在Nginx的0.8.48版本之前默认都是on，之后改成了off,所以现在我们这个版本不需要考虑这个问题，但是如果是0.8.48以前的版本并且server_name_in_redirect设置为on，我们如何通过rewrite来解决这个问题？</p><p>解决方案</p><p>我们可以使用rewrite功能为末尾没有斜杠的URL自动添加一个斜杠</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen<span class="token number">80</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>server_name_in_redirect on<span class="token punctuation">;</span>location /heima <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>-d <span class="token variable">$request_filename</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>rewrite ^/<span class="token punctuation">(</span>.*<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">[</span>^/<span class="token punctuation">]</span><span class="token punctuation">)</span>$ http://<span class="token variable">$host</span>/<span class="token variable">$1</span><span class="token variable">$2</span>/ permanent<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="合并目录"><a href="#合并目录" class="headerlink" title="合并目录"></a>合并目录</h4><p>搜索引擎优化(SEO)是一种利用搜索引擎的搜索规则来提高目的网站在有关搜索引擎内排名的方式。我们在创建自己的站点时，可以通过很多中方式来有效的提供搜索引擎优化的程度。其中有一项就包含URL的目录层级一般不要超过三层，否则的话不利于搜索引擎的搜索也给客户端的输入带来了负担，但是将所有的文件放在一个目录下又会导致文件资源管理混乱并且访问文件的速度也会随着文件增多而慢下来，这两个问题是相互矛盾的，那么使用rewrite如何解决上述问题?</p><p>举例，网站中有一个资源文件的访问路径时 /server/11/22/33/44/20.html,也就是说20.html存在于第5级目录下，如果想要访问该资源文件，客户端的URL地址就要写成 <code>http://192.168.200.133/server/11/22/33/44/20.html</code>,</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">8083</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /server<span class="token punctuation">&#123;</span>root html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这个是非常不利于SEO搜索引擎优化的，同时客户端也不好记.使用rewrite我们可以进行如下配置:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">8083</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /server<span class="token punctuation">&#123;</span>rewrite ^/server-<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>+<span class="token punctuation">)</span>-<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>+<span class="token punctuation">)</span>-<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>+<span class="token punctuation">)</span>-<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>+<span class="token punctuation">)</span><span class="token punctuation">\</span>.html$ /server/<span class="token variable">$1</span>/<span class="token variable">$2</span>/<span class="token variable">$3</span>/<span class="token variable">$4</span>/<span class="token variable">$5</span>.html last<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的花，客户端只需要输入<a href="http://www.web.name/server-11-22-33-44-20.html%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E5%88%B020.html%E9%A1%B5%E9%9D%A2%E4%BA%86%E3%80%82%E8%BF%99%E9%87%8C%E4%B9%9F%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E4%BA%86rewrite%E6%8C%87%E4%BB%A4%E6%94%AF%E6%8C%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%89%B9%E6%80%A7%E3%80%82">http://www.web.name/server-11-22-33-44-20.html就可以访问到20.html页面了。这里也充分利用了rewrite指令支持正则表达式的特性。</a></p><h4 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h4><p>防盗链之前我们已经介绍过了相关的知识，在rewrite中的防盗链和之前将的原理其实都是一样的，只不过通过rewrite可以将防盗链的功能进行完善下，当出现防盗链的情况，我们可以使用rewrite将请求转发到自定义的一张图片和页面，给用户比较好的提示信息。下面我们就通过根据文件类型实现防盗链的一个配置实例:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location /images <span class="token punctuation">&#123;</span>    root html<span class="token punctuation">;</span>    valid_referers none blocked www.baidu.com<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$invalid_referer</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">#return 403;</span>        rewrite ^/    /images/forbidden.png <span class="token builtin class-name">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h2><h3 id="Nginx反向代理概述"><a href="#Nginx反向代理概述" class="headerlink" title="Nginx反向代理概述"></a>Nginx反向代理概述</h3><p>关于正向代理和反向代理，我们在前面的章节已经通过一张图给大家详细的介绍过了，简而言之就是正向代理代理的对象是客户端，反向代理代理的是服务端，这是两者之间最大的区别。</p><p>Nginx即可以实现正向代理，也可以实现反向代理。</p><p>我们先来通过一个小案例演示下Nginx正向代理的简单应用。</p><p>先提需求：</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1581846370052.png"></p><p>(1)服务端的设置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http <span class="token punctuation">&#123;</span>  log_format main <span class="token string">'client send request=>clientIp=$remote_addr serverIp=>$host'</span><span class="token punctuation">;</span>server<span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_namelocalhost<span class="token punctuation">;</span>access_log logs/access.log main<span class="token punctuation">;</span>location <span class="token punctuation">&#123;</span>root html<span class="token punctuation">;</span>index index.html index.htm<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2)使用客户端访问服务端，打开日志查看结果</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1581847577947.png"></p><p>(3)代理服务器设置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>        listen  <span class="token number">82</span><span class="token punctuation">;</span>        resolver <span class="token number">8.8</span>.8.8<span class="token punctuation">;</span>        location /<span class="token punctuation">&#123;</span>                proxy_pass http://<span class="token variable">$host</span><span class="token variable">$request_uri</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(4)查看代理服务器的IP(192.168.200.146)和Nginx配置监听的端口(82)</p><p>(5)在客户端配置代理服务器</p><p>(6)设置完成后，再次通过浏览器访问服务端</p><p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/img/1589729479920.png"></p><p>通过对比，上下两次的日志记录，会发现虽然我们是客户端访问服务端，但是如何使用了代理，那么服务端能看到的只是代理发送过去的请求，这样的化，就使用Nginx实现了正向代理的设置。</p><p>但是Nginx正向代理，在实际的应用中不是特别多，所以我们简单了解下，接下来我们继续学习Nginx的反向代理，这是Nginx比较重要的一个功能。</p><h3 id="Nginx反向代理的配置语法"><a href="#Nginx反向代理的配置语法" class="headerlink" title="Nginx反向代理的配置语法"></a>Nginx反向代理的配置语法</h3><p>Nginx反向代理模块的指令是由<code>ngx_http_proxy_module</code>模块进行解析，该模块在安装Nginx的时候已经自己加装到Nginx中了，接下来我们把反向代理中的常用指令一一介绍下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">proxy_passproxy_set_headerproxy_redirect<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h4><p>该指令用来设置被代理服务器地址，可以是主机名称、IP地址加端口号形式。</p><table><thead><tr><th>语法</th><th>proxy_pass URL;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>location</td></tr></tbody></table><p>URL:为要设置的被代理服务器地址，包含传输协议(<code>http</code>,<code>https://</code>)、主机名称或IP地址加端口号、URI等要素。</p><p>举例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">proxy_pass http://www.baidu.com<span class="token punctuation">;</span>location /server<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>proxy_pass http://192.168.200.146<span class="token punctuation">;</span>    http://192.168.200.146/server/index.htmlproxy_pass http://192.168.200.146/<span class="token punctuation">;</span>    http://192.168.200.146/index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大家在编写proxy_pass的时候，后面的值要不要加”/“?</p><p>接下来通过例子来说明刚才我们提到的问题：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /<span class="token punctuation">&#123;</span><span class="token comment">#proxy_pass http://192.168.200.146;</span>proxy_pass http://192.168.200.146/<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>当客户端访问 http://localhost/index.html,效果是一样的server<span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /server<span class="token punctuation">&#123;</span><span class="token comment">#proxy_pass http://192.168.200.146;</span>proxy_pass http://192.168.200.146/<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>当客户端访问 http://localhost/server/index.html这个时候，第一个proxy_pass就变成了http://localhost/server/index.html第二个proxy_pass就变成了http://localhost/index.html效果就不一样了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="proxy-set-header"><a href="#proxy-set-header" class="headerlink" title="proxy_set_header"></a>proxy_set_header</h4><p>该指令可以更改Nginx服务器接收到的客户端请求的请求头信息，然后将新的请求头发送给代理的服务器</p><table><thead><tr><th>语法</th><th>proxy_set_header field value;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_set_header Host $proxy_host;<br/>proxy_set_header Connection close;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>需要注意的是，如果想要看到结果，必须在被代理的服务器上来获取添加的头信息。</p><p>被代理服务器： [192.168.200.146]</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>        listen  <span class="token number">8080</span><span class="token punctuation">;</span>        server_name localhost<span class="token punctuation">;</span>        default_type text/plain<span class="token punctuation">;</span>        <span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token variable">$http_username</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代理服务器: [192.168.200.133]</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>        listen  <span class="token number">8080</span><span class="token punctuation">;</span>        server_name localhost<span class="token punctuation">;</span>        location /server <span class="token punctuation">&#123;</span>                proxy_pass http://192.168.200.146:8080/<span class="token punctuation">;</span>                proxy_set_header username TOM<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问测试</p><h4 id="proxy-redirect"><a href="#proxy-redirect" class="headerlink" title="proxy_redirect"></a>proxy_redirect</h4><p>该指令是用来重置头信息中的”Location”和”Refresh”的值。</p><table><thead><tr><th>语法</th><th>proxy_redirect redirect replacement;<br/>proxy_redirect default;<br/>proxy_redirect off;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_redirect default;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>》为什么要用该指令?</p><p>服务端[192.168.200.146]</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>    listen  <span class="token number">8081</span><span class="token punctuation">;</span>    server_name localhost<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>-f <span class="token variable">$request_filename</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token builtin class-name">return</span> <span class="token number">302</span> http://192.168.200.146<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代理服务端[192.168.200.133]</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen  <span class="token number">8081</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location / <span class="token punctuation">&#123;</span>proxy_pass http://192.168.200.146:8081/<span class="token punctuation">;</span>proxy_redirect http://192.168.200.146 http://192.168.200.133<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>》该指令的几组选项</p><p>proxy_redirect redirect replacement;</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redirect:目标,Location的值replacement:要替换的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>proxy_redirect default;</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">default<span class="token punctuation">;</span>将location块的uri变量作为replacement,将proxy_pass变量作为redirect进行替换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>proxy_redirect off;</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">关闭proxy_redirect的功能<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Nginx反向代理实战"><a href="#Nginx反向代理实战" class="headerlink" title="Nginx反向代理实战"></a>Nginx反向代理实战</h3><p>服务器1,2,3存在两种情况</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">第一种情况: 三台服务器的内容不一样。第二种情况: 三台服务器的内容是一样。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>如果服务器1、服务器2和服务器3的内容不一样，那我们可以根据用户请求来分发到不同的服务器。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">代理服务器server <span class="token punctuation">&#123;</span>        listen          <span class="token number">8082</span><span class="token punctuation">;</span>        server_name     localhost<span class="token punctuation">;</span>        location /server1 <span class="token punctuation">&#123;</span>                proxy_pass http://192.168.200.146:9001/<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        location /server2 <span class="token punctuation">&#123;</span>                proxy_pass http://192.168.200.146:9002/<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        location /server3 <span class="token punctuation">&#123;</span>                proxy_pass http://192.168.200.146:9003/<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>服务端server1server <span class="token punctuation">&#123;</span>        listen          <span class="token number">9001</span><span class="token punctuation">;</span>        server_name     localhost<span class="token punctuation">;</span>        default_type text/html<span class="token punctuation">;</span>        <span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token string">'&lt;h1>192.168.200.146:9001&lt;/h1>'</span><span class="token punctuation">&#125;</span>server2server <span class="token punctuation">&#123;</span>        listen          <span class="token number">9002</span><span class="token punctuation">;</span>        server_name     localhost<span class="token punctuation">;</span>        default_type text/html<span class="token punctuation">;</span>        <span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token string">'&lt;h1>192.168.200.146:9002&lt;/h1>'</span><span class="token punctuation">&#125;</span>server3server <span class="token punctuation">&#123;</span>        listen          <span class="token number">9003</span><span class="token punctuation">;</span>        server_name     localhost<span class="token punctuation">;</span>        default_type text/html<span class="token punctuation">;</span>        <span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token string">'&lt;h1>192.168.200.146:9003&lt;/h1>'</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>如果服务器1、服务器2和服务器3的内容是一样的，该如何处理?</li></ol><h3 id="Nginx的安全控制"><a href="#Nginx的安全控制" class="headerlink" title="Nginx的安全控制"></a>Nginx的安全控制</h3><p>关于web服务器的安全是比较大的一个话题，里面所涉及的内容很多，Nginx反向代理是如何来提升web服务器的安全呢？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">安全隔离<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>什么是安全隔离?</p><p>通过代理分开了客户端到应用程序服务器端的连接，实现了安全措施。在反向代理之前设置防火墙，仅留一个入口供代理服务器访问。</p><h4 id="如何使用SSL对流量进行加密"><a href="#如何使用SSL对流量进行加密" class="headerlink" title="如何使用SSL对流量进行加密"></a>如何使用SSL对流量进行加密</h4><p>翻译成大家能熟悉的说法就是将我们常用的http请求转变成https请求，那么这两个之间的区别简单的来说两个都是HTTP协议，只不过https是身披SSL外壳的http.</p><p>HTTPS是一种通过计算机网络进行安全通信的传输协议。它经由HTTP进行通信，利用SSL/TLS建立全通信，加密数据包，确保数据的安全性。</p><p>SSL(Secure Sockets Layer)安全套接层</p><p>TLS(Transport Layer Security)传输层安全</p><p>上述这两个是为网络通信提供安全及数据完整性的一种安全协议，TLS和SSL在传输层和应用层对网络连接进行加密。</p><p>总结来说为什么要使用https:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http协议是明文传输数据，存在安全问题，而https是加密传输，相当于http+ssl，并且可以防止流量劫持。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Nginx要想使用SSL，需要满足一个条件即需要添加一个模块<code>--with-http_ssl_module</code>,而该模块在编译的过程中又需要OpenSSL的支持，这个我们之前已经准备好了。</p><h5 id="nginx添加SSL的支持"><a href="#nginx添加SSL的支持" class="headerlink" title="nginx添加SSL的支持"></a>nginx添加SSL的支持</h5><p>（1）完成 <code>--with-http_ssl_module</code>模块的增量添加</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">》将原有/usr/local/nginx/sbin/nginx进行备份》拷贝nginx之前的配置信息》在nginx的安装源码进行配置指定对应模块  ./configure --with-http_ssl_module》通过make模板进行编译》将objs下面的nginx移动到/usr/local/nginx/sbin下》在源码目录下执行  <span class="token function">make</span> upgrade进行升级，这个可以实现不停机添加新模块的功能<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Nginx的SSL相关指令"><a href="#Nginx的SSL相关指令" class="headerlink" title="Nginx的SSL相关指令"></a>Nginx的SSL相关指令</h5><p>因为刚才我们介绍过该模块的指令都是通过ngx_http_ssl_module模块来解析的。</p><p>》ssl:该指令用来在指定的服务器开启HTTPS,可以使用 listen 443 ssl,后面这种方式更通用些。</p><table><thead><tr><th>语法</th><th>ssl on | off;</th></tr></thead><tbody><tr><td>默认值</td><td>ssl off;</td></tr><tr><td>位置</td><td>http、server</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">server&#123;listen 443 ssl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>》ssl_certificate:为当前这个虚拟主机指定一个带有PEM格式证书的证书。</p><table><thead><tr><th>语法</th><th>ssl_certificate file;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http、server</td></tr></tbody></table><p>》ssl_certificate_key:该指令用来指定PEM secret key文件的路径</p><table><thead><tr><th>语法</th><th>ssl_ceritificate_key file;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http、server</td></tr></tbody></table><p>》ssl_session_cache:该指令用来配置用于SSL会话的缓存</p><table><thead><tr><th>语法</th><th>ssl_sesion_cache off|none|[builtin[:size]] [shared:name:size]</th></tr></thead><tbody><tr><td>默认值</td><td>ssl_session_cache none;</td></tr><tr><td>位置</td><td>http、server</td></tr></tbody></table><p>off:禁用会话缓存，客户端不得重复使用会话</p><p>none:禁止使用会话缓存，客户端可以重复使用，但是并没有在缓存中存储会话参数</p><p>builtin:内置OpenSSL缓存，仅在一个工作进程中使用。</p><p>shared:所有工作进程之间共享缓存，缓存的相关信息用name和size来指定</p><p>》ssl_session_timeout：开启SSL会话功能后，设置客户端能够反复使用储存在缓存中的会话参数时间。</p><table><thead><tr><th>语法</th><th>ssl_session_timeout time;</th></tr></thead><tbody><tr><td>默认值</td><td>ssl_session_timeout 5m;</td></tr><tr><td>位置</td><td>http、server</td></tr></tbody></table><p>》ssl_ciphers:指出允许的密码，密码指定为OpenSSL支持的格式</p><table><thead><tr><th>语法</th><th>ssl_ciphers ciphers;</th></tr></thead><tbody><tr><td>默认值</td><td>ssl_ciphers HIGH:!aNULL:!MD5;</td></tr><tr><td>位置</td><td>http、server</td></tr></tbody></table><p>可以使用<code>openssl ciphers</code>查看openssl支持的格式。</p><p>》ssl_prefer_server_ciphers：该指令指定是否服务器密码优先客户端密码</p><table><thead><tr><th>语法</th><th>ssl_perfer_server_ciphers on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>ssl_perfer_server_ciphers off;</td></tr><tr><td>位置</td><td>http、server</td></tr></tbody></table><h5 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h5><p>方式一：使用阿里云/腾讯云等第三方服务进行购买。</p><p>方式二:使用openssl生成证书</p><p>先要确认当前系统是否有安装openssl</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装下面的命令进行生成</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> /root/cert<span class="token builtin class-name">cd</span> /root/certopenssl genrsa -des3 -out server.key <span class="token number">1024</span>openssl req -new -key server.key -out server.csr<span class="token function">cp</span> server.key server.key.orgopenssl rsa -in server.key.org -out server.keyopenssl x509 -req -days <span class="token number">365</span> -in server.csr -signkey server.key -out server.crt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="开启SSL实例"><a href="#开启SSL实例" class="headerlink" title="开启SSL实例"></a>开启SSL实例</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>    listen       <span class="token number">443</span> ssl<span class="token punctuation">;</span>    server_name  localhost<span class="token punctuation">;</span>    ssl_certificate      server.cert<span class="token punctuation">;</span>    ssl_certificate_key  server.key<span class="token punctuation">;</span>    ssl_session_cache    shared:SSL:1m<span class="token punctuation">;</span>    ssl_session_timeout  5m<span class="token punctuation">;</span>    ssl_ciphers  HIGH:<span class="token operator">!</span>aNULL:<span class="token operator">!</span>MD5<span class="token punctuation">;</span>    ssl_prefer_server_ciphers  on<span class="token punctuation">;</span>    location / <span class="token punctuation">&#123;</span>        root   html<span class="token punctuation">;</span>        index  index.html index.htm<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（4）验证</p><h3 id="反向代理系统调优"><a href="#反向代理系统调优" class="headerlink" title="反向代理系统调优"></a>反向代理系统调优</h3><p>反向代理值Buffer和Cache</p><p>Buffer翻译过来是”缓冲”，Cache翻译过来是”缓存”。</p><p>总结下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">相同点:两种方式都是用来提供IO吞吐效率，都是用来提升Nginx代理的性能。不同点:缓冲主要用来解决不同设备之间数据传递速度不一致导致的性能低的问题，缓冲中的数据一旦此次操作完成后，就可以删除。缓存主要是备份，将被代理服务器的数据缓存一份到代理服务器，这样的话，客户端再次获取相同数据的时候，就只需要从代理服务器上获取，效率较高，缓存中的数据可以重复使用，只有满足特定条件才会删除.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（1）Proxy Buffer相关指令</p><p>》proxy_buffering :该指令用来开启或者关闭代理服务器的缓冲区；</p><table><thead><tr><th>语法</th><th>proxy_buffering on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_buffering on;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>》proxy_buffers:该指令用来指定单个连接从代理服务器读取响应的缓存区的个数和大小。</p><table><thead><tr><th>语法</th><th>proxy_buffers number size;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_buffers 8 4k | 8K;(与系统平台有关)</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>number:缓冲区的个数</p><p>size:每个缓冲区的大小，缓冲区的总大小就是number*size</p><p>》proxy_buffer_size:该指令用来设置从被代理服务器获取的第一部分响应数据的大小。保持与proxy_buffers中的size一致即可，当然也可以更小。</p><table><thead><tr><th>语法</th><th>proxy_buffer_size size;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_buffer_size 4k | 8k;(与系统平台有关)</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>》proxy_busy_buffers_size：该指令用来限制同时处于BUSY状态的缓冲总大小。</p><table><thead><tr><th>语法</th><th>proxy_busy_buffers_size size;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_busy_buffers_size 8k|16K;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>》proxy_temp_path:当缓冲区存满后，仍未被Nginx服务器完全接受，响应数据就会被临时存放在磁盘文件上，该指令设置文件路径</p><table><thead><tr><th>语法</th><th>proxy_temp_path  path;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_temp_path proxy_temp;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>注意path最多设置三层。  </p><p>》proxy_temp_file_write_size：该指令用来设置磁盘上缓冲文件的大小。</p><table><thead><tr><th>语法</th><th>proxy_temp_file_write_size size;</th></tr></thead><tbody><tr><td>默认值</td><td>proxy_temp_file_write_size 8K|16K;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>通用网站的配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">proxy_buffering on<span class="token punctuation">;</span>proxy_buffer_size <span class="token number">4</span> 32k<span class="token punctuation">;</span>proxy_busy_buffers_size 64k<span class="token punctuation">;</span>proxy_temp_file_write_size 64k<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>根据项目的具体内容进行相应的调节。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx进阶篇（一）</title>
      <link href="/2021/07/25/Nginx/Nginx%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/07/25/Nginx/Nginx%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx进阶篇"><a href="#Nginx进阶篇" class="headerlink" title="Nginx进阶篇"></a>Nginx进阶篇</h1><h2 id="Nginx服务器基础配置实例"><a href="#Nginx服务器基础配置实例" class="headerlink" title="Nginx服务器基础配置实例"></a>Nginx服务器基础配置实例</h2><p>前面我们已经对Nginx服务器默认配置文件的结构和涉及的基本指令做了详细的阐述。通过这些指令的合理配置，我们就可以让一台Nginx服务器正常工作，并且提供基本的web服务器功能。</p><p>接下来我们将通过一个比较完整和最简单的基础配置实例，来巩固下前面所学习的指令及其配置。</p><p>需求如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">（1）有如下访问：http://192.168.200.133:8081/server1/location1访问的是：index_sr1_location1.htmlhttp://192.168.200.133:8081/server1/location2访问的是：index_sr1_location2.htmlhttp://192.168.200.133:8082/server2/location1访问的是：index_sr2_location1.htmlhttp://192.168.200.133:8082/server2/location2访问的是：index_sr2_location2.html（2）如果访问的资源不存在，返回自定义的404页面（3）将/server1和/server2的配置使用不同的配置文件分割将文件放到/home/www/conf.d目录下，然后使用include进行合并（4）为/server1和/server2各自创建一个访问日志文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>准备相关文件，目录如下：</p><img src="https://zeyanblog.oss-cn-hangzhou.aliyuncs.com/halo/image_1626707143148.png" alt="image.png" style="zoom: 50%;" /><p>配置的内容如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">##全局块 begin##</span><span class="token comment">#配置允许运行Nginx工作进程的用户和用户组</span>user www<span class="token punctuation">;</span><span class="token comment">#配置运行Nginx进程生成的worker进程数</span>worker_processes <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">#配置Nginx服务器运行对错误日志存放的路径</span>error_log logs/error.log<span class="token punctuation">;</span><span class="token comment">#配置Nginx服务器允许时记录Nginx的master进程的PID文件路径和名称</span>pid logs/nginx.pid<span class="token punctuation">;</span><span class="token comment">#配置Nginx服务是否以守护进程方法启动</span><span class="token comment">#daemon on;</span><span class="token comment">##全局块 end##</span><span class="token comment">##events块 begin##</span>events<span class="token punctuation">&#123;</span><span class="token comment">#设置Nginx网络连接序列化</span>accept_mutex on<span class="token punctuation">;</span><span class="token comment">#设置Nginx的worker进程是否可以同时接收多个请求</span>multi_accept on<span class="token punctuation">;</span><span class="token comment">#设置Nginx的worker进程最大的连接数</span>worker_connections <span class="token number">1024</span><span class="token punctuation">;</span><span class="token comment">#设置Nginx使用的事件驱动模型</span>use epoll<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">##events块 end##</span><span class="token comment">##http块 start##</span>http<span class="token punctuation">&#123;</span><span class="token comment">#定义MIME-Type</span>include mime.types<span class="token punctuation">;</span>default_type application/octet-stream<span class="token punctuation">;</span><span class="token comment">#配置允许使用sendfile方式运输</span>sendfile on<span class="token punctuation">;</span><span class="token comment">#配置连接超时时间</span>keepalive_timeout <span class="token number">65</span><span class="token punctuation">;</span><span class="token comment">#配置请求处理日志格式</span>log_format server1 <span class="token string">'===>server1 access log'</span><span class="token punctuation">;</span>log_format server2 <span class="token string">'===>server2 access log'</span><span class="token punctuation">;</span><span class="token comment">##server块 开始##</span>include /home/www/conf.d/*.conf<span class="token punctuation">;</span><span class="token comment">##server块 结束##</span><span class="token punctuation">&#125;</span><span class="token comment">##http块 end##</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>server1.conf</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span><span class="token comment">#配置监听端口和主机名称</span>listen <span class="token number">8081</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span><span class="token comment">#配置请求处理日志存放路径</span>access_log /home/www/myweb/server1/logs/access.log server1<span class="token punctuation">;</span><span class="token comment">#配置错误页面</span>error_page <span class="token number">404</span> /404.html<span class="token punctuation">;</span><span class="token comment">#配置处理/server1/location1请求的location</span>location /server1/location1<span class="token punctuation">&#123;</span>root /home/www/myweb<span class="token punctuation">;</span>index index_sr1_location1.html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">#配置处理/server1/location2请求的location</span>location /server1/location2<span class="token punctuation">&#123;</span>root /home/www/myweb<span class="token punctuation">;</span>index index_sr1_location2.html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">#配置错误页面转向</span>location <span class="token operator">=</span> /404.html <span class="token punctuation">&#123;</span>root /home/www/myweb<span class="token punctuation">;</span>index <span class="token number">404</span>.html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>server2.conf</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span><span class="token comment">#配置监听端口和主机名称</span>listen <span class="token number">8082</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span><span class="token comment">#配置请求处理日志存放路径</span>access_log /home/www/myweb/server2/logs/access.log server2<span class="token punctuation">;</span><span class="token comment">#配置错误页面,对404.html做了定向配置</span>error_page <span class="token number">404</span> /404.html<span class="token punctuation">;</span><span class="token comment">#配置处理/server1/location1请求的location</span>location /server2/location1<span class="token punctuation">&#123;</span>root /home/www/myweb<span class="token punctuation">;</span>index index_sr2_location1.html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">#配置处理/server2/location2请求的location</span>location /server2/location2<span class="token punctuation">&#123;</span>root /home/www/myweb<span class="token punctuation">;</span>index index_sr2_location2.html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">#配置错误页面转向</span>location <span class="token operator">=</span> /404.html <span class="token punctuation">&#123;</span>root /home/www/myweb<span class="token punctuation">;</span>index <span class="token number">404</span>.html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Nginx静态资源部署"><a href="#Nginx静态资源部署" class="headerlink" title="Nginx静态资源部署"></a>Nginx静态资源部署</h2><h3 id="Nginx静态资源概述"><a href="#Nginx静态资源概述" class="headerlink" title="Nginx静态资源概述"></a>Nginx静态资源概述</h3><p>上网去搜索访问资源对于我们来说并不陌生，通过浏览器发送一个HTTP请求实现从客户端发送请求到服务器端获取所需要内容后并把内容回显展示在页面的一个过程。这个时候，我们所请 求的内容就分为两种类型，一类是静态资源、一类是动态资源。<br>静态资源即指在服务器端真实存在并且能直接拿来展示的一些文件，比如常见的html页面、css文件、js文件、图 片、视频等资源；<br>动态资源即指在服务器端真实存在但是要想获取需要经过一定的业务逻辑处理，根据不同的条件展示在页面不同这 一部分内容，比如说报表数据展示、根据当前登录用户展示相关具体数据等资源；</p><p>Nginx处理静态资源的内容，我们需要考虑下面这几个问题：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">（1）静态资源的配置指令（2）静态资源的配置优化（3）静态资源的压缩配置指令（4）静态资源的缓存处理（5）静态资源的访问控制，包括跨域问题和防盗链问题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Nginx静态资源的配置指令"><a href="#Nginx静态资源的配置指令" class="headerlink" title="Nginx静态资源的配置指令"></a>Nginx静态资源的配置指令</h3><h4 id="listen指令"><a href="#listen指令" class="headerlink" title="listen指令"></a>listen指令</h4><p>listen:用来配置监听端口。</p><table><thead><tr><th>语法</th><th>listen address[:port] [default_server]…;<br/>listen port [default_server]…;</th></tr></thead><tbody><tr><td>默认值</td><td>listen *:80 | *:8000</td></tr><tr><td>位置</td><td>server</td></tr></tbody></table><p>listen的设置比较灵活，我们通过几个例子来把常用的设置方式熟悉下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">listen <span class="token number">127.0</span>.0.1:8000<span class="token punctuation">;</span> // listen localhost:8000 监听指定的IP和端口listen <span class="token number">127.0</span>.0.1<span class="token punctuation">;</span>监听指定IP的所有端口listen <span class="token number">8000</span><span class="token punctuation">;</span>监听指定端口上的连接listen *:8000<span class="token punctuation">;</span>监听指定端口上的连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>default_server属性是标识符，用来将此虚拟主机设置成默认主机。所谓的默认主机指的是如果没有匹配到对应的address:port，则会默认执行的。如果不指定默认使用的是第一个server。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span>listen <span class="token number">8080</span><span class="token punctuation">;</span>server_name <span class="token number">127.0</span>.0.1<span class="token punctuation">;</span>location /<span class="token punctuation">&#123;</span>root html<span class="token punctuation">;</span>index index.html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>server<span class="token punctuation">&#123;</span>listen <span class="token number">8080</span> default_server<span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">444</span> <span class="token string">'This is a error request'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="server-name指令"><a href="#server-name指令" class="headerlink" title="server_name指令"></a>server_name指令</h4><p>server_name：用来设置虚拟主机服务名称。</p><p>127.0.0.1 、 localhost 、域名[<a href="http://www.baidu.com/">www.baidu.com</a> | <a href="http://www.jd.com]">www.jd.com]</a></p><table><thead><tr><th>语法</th><th>server_name  name …;<br/>name可以提供多个中间用空格分隔</th></tr></thead><tbody><tr><td>默认值</td><td>server_name  “”;</td></tr><tr><td>位置</td><td>server</td></tr></tbody></table><p>关于server_name的配置方式有三种，分别是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">精确匹配通配符匹配正则表达式匹配<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>配置方式一：精确匹配</p><p>如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name www.itcast.cn www.itheima.cn<span class="token punctuation">;</span><span class="token punctuation">..</span>.<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>补充小知识点:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>windows:C:\Windows\System32\drivers\etc</p><p>centos：/etc/hosts</p><p>因为域名是要收取一定的费用，所以我们可以使用修改hosts文件来制作一些虚拟域名来使用。需要修改 <code>/etc/hosts</code>文件来添加</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/hosts<span class="token number">127.0</span>.0.1 www.itcast.cn<span class="token number">127.0</span>.0.1 www.itheima.cn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>配置方式二:使用通配符配置</p><p>server_name中支持通配符”*”,但需要注意的是通配符不能出现在域名的中间，只能出现在首段或尾段，如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name  *.itcast.cnwww.itheima.*<span class="token punctuation">;</span><span class="token comment"># www.itcast.cn abc.itcast.cn www.itheima.cn www.itheima.com</span><span class="token punctuation">..</span>.<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的配置就会报错</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name  www.*.cn www.itheima.c*<span class="token punctuation">..</span>.<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置三:使用正则表达式配置</p><p>server_name中可以使用正则表达式，并且使用<code>~</code>作为正则表达式字符串的开始标记。</p><p>常见的正则表达式</p><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>匹配搜索字符串开始位置</td></tr><tr><td>$</td><td>匹配搜索字符串结束位置</td></tr><tr><td>.</td><td>匹配除换行符\n之外的任何单个字符</td></tr><tr><td>\</td><td>转义字符，将下一个字符标记为特殊字符</td></tr><tr><td>[xyz]</td><td>字符集，与任意一个指定字符匹配</td></tr><tr><td>[a-z]</td><td>字符范围，匹配指定范围内的任何字符</td></tr><tr><td>\w</td><td>与以下任意字符匹配 A-Z a-z 0-9 和下划线,等效于[A-Za-z0-9_]</td></tr><tr><td>\d</td><td>数字字符匹配，等效于[0-9]</td></tr><tr><td>{n}</td><td>正好匹配n次</td></tr><tr><td>{n,}</td><td>至少匹配n次</td></tr><tr><td>{n,m}</td><td>匹配至少n次至多m次</td></tr><tr><td>*</td><td>零次或多次，等效于{0,}</td></tr><tr><td>+</td><td>一次或多次，等效于{1,}</td></tr><tr><td>?</td><td>零次或一次，等效于{0,1}</td></tr></tbody></table><p>配置如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span>        listen <span class="token number">80</span><span class="token punctuation">;</span>        server_name ~^www<span class="token punctuation">\</span>.<span class="token punctuation">(</span><span class="token punctuation">\</span>w+<span class="token punctuation">)</span><span class="token punctuation">\</span>.com$<span class="token punctuation">;</span>        default_type text/plain<span class="token punctuation">;</span>        <span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token variable">$1</span>  <span class="token variable">$2</span> <span class="token punctuation">..</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>注意 ~后面不能加空格，括号可以取值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="匹配执行顺序"><a href="#匹配执行顺序" class="headerlink" title="匹配执行顺序"></a>匹配执行顺序</h5><p>由于server_name指令支持通配符和正则表达式，因此在包含多个虚拟主机的配置文件中，可能会出现一个名称被多个虚拟主机的server_name匹配成功，当遇到这种情况，当前的请求交给谁来处理呢？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name ~^www<span class="token punctuation">\</span>.<span class="token punctuation">\</span>w+<span class="token punctuation">\</span>.com$<span class="token punctuation">;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token string">'regex_success'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server<span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name www.itheima.*<span class="token punctuation">;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token string">'wildcard_after_success'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server<span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name *.itheima.com<span class="token punctuation">;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token string">'wildcard_before_success'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server<span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name www.itheima.com<span class="token punctuation">;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token string">'exact_success'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server<span class="token punctuation">&#123;</span>listen <span class="token number">80</span> default_server<span class="token punctuation">;</span>server_name _<span class="token punctuation">;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">444</span> <span class="token string">'default_server not found server'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结论：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">exact_successwildcard_before_successwildcard_after_successregex_successdefault_server not found server<span class="token operator">!</span><span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">No1:准确匹配server_nameNo2:通配符在开始时匹配server_name成功No3:通配符在结束时匹配server_name成功No4:正则表达式匹配server_name成功No5:被默认的default_server处理，如果没有指定默认找第一个server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="location指令"><a href="#location指令" class="headerlink" title="location指令"></a>location指令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location / <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>location /abc<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">..</span>.<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>location:用来设置请求的URI</p><table><thead><tr><th>语法</th><th>location [  =  |   ~  |  <del>*   |   ^</del>   |@ ] uri{…}</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server,location</td></tr></tbody></table><p>uri变量是待匹配的请求字符串，可以不包含正则表达式，也可以包含正则表达式，那么nginx服务器在搜索匹配location的时候，是先使用不包含正则表达式进行匹配，找到一个匹配度最高的一个，然后在通过包含正则表达式的进行匹配，如果能匹配到直接访问，匹配不到，就使用刚才匹配度最高的那个location来处理请求。</p><p>属性介绍:</p><p>不带符号，要求必须以指定模式开始</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name <span class="token number">127.0</span>.0.1<span class="token punctuation">;</span>location /abc<span class="token punctuation">&#123;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token string">"access success"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>以下访问都是正确的http://192.168.200.133/abchttp://192.168.200.133/abc?p1<span class="token operator">=</span>TOMhttp://192.168.200.133/abc/http://192.168.200.133/abcdef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>= :  用于不包含正则表达式的uri前，必须与指定的模式精确匹配</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name <span class="token number">127.0</span>.0.1<span class="token punctuation">;</span>location <span class="token operator">=</span>/abc<span class="token punctuation">&#123;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token string">"access success"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>可以匹配到http://192.168.200.133/abchttp://192.168.200.133/abc?p1<span class="token operator">=</span>TOM匹配不到http://192.168.200.133/abc/http://192.168.200.133/abcdef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>~ ： 用于表示当前uri中包含了正则表达式，并且区分大小写<br>~*:  用于表示当前uri中包含了正则表达式，并且不区分大小写</p><p>换句话说，如果uri包含了正则表达式，需要用上述两个符合来标识</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name <span class="token number">127.0</span>.0.1<span class="token punctuation">;</span>location ~^/abc<span class="token punctuation">\</span>w<span class="token variable">$&#123;default_type text<span class="token operator">/</span>plain;return 200 "access success";&#125;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name <span class="token number">127.0</span>.0.1<span class="token punctuation">;</span>location ~*^/abc<span class="token punctuation">\</span>w<span class="token variable">$&#123;default_type text<span class="token operator">/</span>plain;return 200 "access success";&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>^~: 用于不包含正则表达式的uri前，功能和不加符号的一致，唯一不同的是，如果模式匹配，那么就停止搜索其他模式了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name <span class="token number">127.0</span>.0.1<span class="token punctuation">;</span>location ^~/abc<span class="token punctuation">&#123;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token string">"access success"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置请求资源的目录root-alias"><a href="#设置请求资源的目录root-alias" class="headerlink" title="设置请求资源的目录root / alias"></a>设置请求资源的目录root / alias</h4><p>root：设置请求的根目录</p><table><thead><tr><th>语法</th><th>root path;</th></tr></thead><tbody><tr><td>默认值</td><td>root html;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>path为Nginx服务器接收到请求以后查找资源的根目录路径。</p><p>alias：用来更改location的URI</p><table><thead><tr><th>语法</th><th>alias path;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>location</td></tr></tbody></table><p>path为修改后的根路径。</p><p>以上两个指令都可以来指定访问资源的路径，那么这两者之间的区别是什么?</p><p>举例说明：</p><p>（1）在<code>/usr/local/nginx/html</code>目录下创建一个 images目录,并在目录下放入一张图片<code>mv.png</code>图片</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location /images <span class="token punctuation">&#123;</span>root /usr/local/nginx/html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>访问图片的路径为:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http://192.168.200.133/images/mv.png<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）如果把root改为alias</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location /images <span class="token punctuation">&#123;</span><span class="token builtin class-name">alias</span> /usr/local/nginx/html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>再次访问上述地址，页面会出现404的错误，查看错误日志会发现是因为地址不对，所以验证了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root的处理结果是: root路径+location路径/usr/local/nginx/html/images/mv.pngalias的处理结果是:使用alias路径替换location路径/usr/local/nginx/html/images<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要在alias后面路径改为</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location /images <span class="token punctuation">&#123;</span><span class="token builtin class-name">alias</span> /usr/local/nginx/html/images<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（3）如果location路径是以/结尾,则alias也必须是以/结尾，root没有要求</p><p>将上述配置修改为</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location /images/ <span class="token punctuation">&#123;</span><span class="token builtin class-name">alias</span> /usr/local/nginx/html/images<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>访问就会出问题，查看错误日志还是路径不对，所以需要把alias后面加上 / </p><p>小结：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root的处理结果是: root路径+location路径alias的处理结果是:使用alias路径替换location路径alias是一个目录别名的定义，root则是最上层目录的含义。如果location路径是以/结尾,则alias也必须是以/结尾，root没有要求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="index指令"><a href="#index指令" class="headerlink" title="index指令"></a>index指令</h4><p>index:设置网站的默认首页</p><table><thead><tr><th>语法</th><th>index file …;</th></tr></thead><tbody><tr><td>默认值</td><td>index index.html;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>index后面可以跟多个设置，如果访问的时候没有指定具体访问的资源，则会依次进行查找，找到第一个为止。</p><p>举例说明：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location / <span class="token punctuation">&#123;</span>root /usr/local/nginx/html<span class="token punctuation">;</span>index index.html index.htm<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>访问该location的时候，可以通过 http://ip:port/，地址后面如果不添加任何内容，则默认依次访问index.html和index.htm，找到第一个来进行返回<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="error-page指令"><a href="#error-page指令" class="headerlink" title="error_page指令"></a>error_page指令</h4><p>error_page:设置网站的错误页面</p><table><thead><tr><th>语法</th><th>error_page code … [=[response]] uri;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http、server、location……</td></tr></tbody></table><p>当出现对应的响应code后，如何来处理。</p><p>举例说明：</p><p>（1）可以指定具体跳转的地址</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>error_page <span class="token number">404</span> http://www.itcast.cn<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（2）可以指定重定向地址</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span>error_page <span class="token number">404</span> /50x.html<span class="token punctuation">;</span>error_page <span class="token number">500</span> <span class="token number">502</span> <span class="token number">503</span> <span class="token number">504</span> /50x.html<span class="token punctuation">;</span>location <span class="token operator">=</span>/50x.html<span class="token punctuation">&#123;</span>root html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）使用location的@符合完成错误信息展示</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span>error_page <span class="token number">404</span> @jump_to_error<span class="token punctuation">;</span>location @jump_to_error <span class="token punctuation">&#123;</span>default_type text/plain<span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">404</span> <span class="token string">'Not Found Page...'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可选项<code>=[response]</code>的作用是用来将相应代码更改为另外一个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span>error_page <span class="token number">404</span> <span class="token operator">=</span><span class="token number">200</span> /50x.html<span class="token punctuation">;</span>location <span class="token operator">=</span>/50x.html<span class="token punctuation">&#123;</span>root html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>这样的话，当返回404找不到对应的资源的时候，在浏览器上可以看到，最终返回的状态码是200，这块需要注意下，编写error_page后面的内容，404后面需要加空格，200前面不能加空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="静态资源优化配置语法"><a href="#静态资源优化配置语法" class="headerlink" title="静态资源优化配置语法"></a>静态资源优化配置语法</h3><p>Nginx对静态资源如何进行优化配置。这里从三个属性配置进行优化：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sendfile on<span class="token punctuation">;</span>tcp_nopush on<span class="token punctuation">;</span>tcp_nodeplay on<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（1）sendﬁle，用来开启高效的文件传输模式。</p><table><thead><tr><th>语法</th><th>sendﬁle on |oﬀ;</th></tr></thead><tbody><tr><td>默认值</td><td>sendﬁle oﬀ;</td></tr><tr><td>位置</td><td>http、server、location…</td></tr></tbody></table><p>请求静态资源的过程：客户端通过网络接口向服务端发送请求，操作系统将这些客户端的请求传递给服务器端应用程序，服务器端应用程序会处理这些请求，请求处理完成以后，操作系统还需要将处理得到的结果通过网络适配器传递回去。</p><p>如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name localhost；location / <span class="token punctuation">&#123;</span>root html<span class="token punctuation">;</span>index index.html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>在html目录下有一个welcome.html页面，访问地址http://192.168.200.133/welcome.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）tcp_nopush：该指令必须在sendfile打开的状态下才会生效，主要是用来提升网络包的传输’效率’</p><table><thead><tr><th>语法</th><th>tcp_nopush on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>tcp_nopush oﬀ;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>（3）tcp_nodelay：该指令必须在keep-alive连接开启的情况下才生效，来提高网络包传输的’实时性’</p><table><thead><tr><th>语法</th><th>tcp_nodelay on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>tcp_nodelay on;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>经过刚才的分析，”tcp_nopush”和”tcp_nodelay“看起来是”互斥的”，那么为什么要将这两个值都打开，这个大家需要知道的是在linux2.5.9以后的版本中两者是可以兼容的，三个指令都开启的好处是，sendfile可以开启高效的文件传输模式，tcp_nopush开启可以确保在发送到客户端之前数据包已经充分“填满”， 这大大减少了网络开销，并加快了文件发送的速度。 然后，当它到达最后一个可能因为没有“填满”而暂停的数据包时，Nginx会忽略tcp_nopush参数， 然后，tcp_nodelay强制套接字发送数据。由此可知，TCP_NOPUSH可以与TCP_NODELAY一起设置，它比单独配置TCP_NODELAY具有更强的性能。所以我们可以使用如下配置来优化Nginx静态资源的处理</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sendfile on<span class="token punctuation">;</span>tcp_nopush on<span class="token punctuation">;</span>tcp_nodelay on<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Nginx静态资源压缩实战"><a href="#Nginx静态资源压缩实战" class="headerlink" title="Nginx静态资源压缩实战"></a>Nginx静态资源压缩实战</h3><p>经过上述内容的优化，我们再次思考一个问题，假如在满足上述优化的前提下，我们传送一个1M的数据和一个10M的数据那个效率高?，答案显而易见，传输内容小，速度就会快。那么问题又来了，同样的内容，如果把大小降下来，我们脑袋里面要蹦出一个词就是”压缩”，接下来，我们来学习Nginx的静态资源压缩模块。</p><p>在Nginx的配置文件中可以通过配置gzip来对静态资源进行压缩，相关的指令可以配置在http块、server块和location块中，Nginx可以通过</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ngx_http_gzip_module模块ngx_http_gzip_static_module模块ngx_http_gunzip_module模块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对这些指令进行解析和处理。</p><p>接下来我们从以下内容进行学习</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">（1）Gzip各模块支持的配置指令（2）Gzip压缩功能的配置（3）Gzip和sendfile的冲突解决（4）浏览器不支持Gzip的解决方案<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Gzip模块配置指令"><a href="#Gzip模块配置指令" class="headerlink" title="Gzip模块配置指令"></a>Gzip模块配置指令</h4><p>接下来所学习的指令都来自ngx_http_gzip_module模块，该模块会在nginx安装的时候内置到nginx的安装环境中，也就是说我们可以直接使用这些指令。</p><ol><li>gzip指令：该指令用于开启或者关闭gzip功能</li></ol><table><thead><tr><th>语法</th><th>gzip on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip off;</td></tr><tr><td>位置</td><td>http、server、location…</td></tr></tbody></table><p>注意只有该指令为打开状态，下面的指令才有效果</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http<span class="token punctuation">&#123;</span>   <span class="token function">gzip</span> on<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>gzip_types指令：该指令可以根据响应页的MIME类型选择性地开启Gzip压缩功能</li></ol><table><thead><tr><th>语法</th><th>gzip_types mime-type …;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip_types text/html;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>所选择的值可以从mime.types文件中进行查找，也可以使用”*”代表所有。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http<span class="token punctuation">&#123;</span>gzip_types application/javascript<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li>gzip_comp_level指令：该指令用于设置Gzip压缩程度，级别从1-9,1表示要是程度最低，要是效率最高，9刚好相反，压缩程度最高，但是效率最低最费时间。</li></ol><table><thead><tr><th>语法</th><th>gzip_comp_level level;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip_comp_level 1;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http<span class="token punctuation">&#123;</span>gzip_comp_level <span class="token number">6</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li>gzip_vary指令：该指令用于设置使用Gzip进行压缩发送是否携带“Vary:Accept-Encoding”头域的响应头部。主要是告诉接收方，所发送的数据经过了Gzip压缩处理</li></ol><table><thead><tr><th>语法</th><th>gzip_vary on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip_vary off;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><ol start="5"><li>gzip_buffers指令：该指令用于处理请求压缩的缓冲区数量和大小。</li></ol><table><thead><tr><th>语法</th><th>gzip_buffers number size;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip_buffers 32 4k|16 8k;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>其中number:指定Nginx服务器向系统申请缓存空间个数，size指的是每个缓存空间的大小。主要实现的是申请number个每个大小为size的内存空间。这个值的设定一般会和服务器的操作系统有关，所以建议此项不设置，使用默认值即可。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gzip_buffers <span class="token number">4</span> 16K<span class="token punctuation">;</span>  <span class="token comment">#缓存空间大小</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li>gzip_disable指令：针对不同种类客户端发起的请求，可以选择性地开启和关闭Gzip功能。</li></ol><table><thead><tr><th>语法</th><th>gzip_disable regex …;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>regex:根据客户端的浏览器标志(user-agent)来设置，支持使用正则表达式。指定的浏览器标志不使用Gzip.该指令一般是用来排除一些明显不支持Gzip的浏览器。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gzip_disable <span class="token string">"MSIE [1-6]\."</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="7"><li>gzip_http_version指令：针对不同的HTTP协议版本，可以选择性地开启和关闭Gzip功能。</li></ol><table><thead><tr><th>语法</th><th>gzip_http_version 1.0|1.1;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip_http_version 1.1;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>该指令是指定使用Gzip的HTTP最低版本，该指令一般采用默认值即可。</p><ol start="8"><li>gzip_min_length指令：该指令针对传输数据的大小，可以选择性地开启和关闭Gzip功能</li></ol><table><thead><tr><th>语法</th><th>gzip_min_length length;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip_min_length 20;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nignx计量大小的单位：bytes<span class="token punctuation">[</span>字节<span class="token punctuation">]</span> / kb<span class="token punctuation">[</span>千字节<span class="token punctuation">]</span> / M<span class="token punctuation">[</span>兆<span class="token punctuation">]</span>例如: <span class="token number">1024</span> / 10k<span class="token operator">|</span>K / 10m<span class="token operator">|</span>M<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Gzip压缩功能对大数据的压缩效果明显，但是如果要压缩的数据比较小的化，可能出现越压缩数据量越大的情况，因此我们需要根据响应内容的大小来决定是否使用Gzip功能，响应页面的大小可以通过头信息中的<code>Content-Length</code>来获取。但是如何使用了Chunk编码动态压缩，该指令将被忽略。建议设置为1K或以上。</p><ol start="9"><li>gzip_proxied指令：该指令设置是否对服务端返回的结果进行Gzip压缩。</li></ol><table><thead><tr><th>语法</th><th>gzip_proxied  off|expired|no-cache|<br/>no-store|private|no_last_modified|no_etag|auth|any;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip_proxied off;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>off - 关闭Nginx服务器对后台服务器返回结果的Gzip压缩<br>expired - 启用压缩，如果header头中包含 “Expires” 头信息<br>no-cache - 启用压缩，如果header头中包含 “Cache-Control:no-cache” 头信息<br>no-store - 启用压缩，如果header头中包含 “Cache-Control:no-store” 头信息<br>private - 启用压缩，如果header头中包含 “Cache-Control:private” 头信息<br>no_last_modified - 启用压缩,如果header头中不包含 “Last-Modified” 头信息<br>no_etag - 启用压缩 ,如果header头中不包含 “ETag” 头信息<br>auth - 启用压缩 , 如果header头中包含 “Authorization” 头信息<br>any - 无条件启用压缩</p><h4 id="Gzip压缩功能的实例配置"><a href="#Gzip压缩功能的实例配置" class="headerlink" title="Gzip压缩功能的实例配置"></a>Gzip压缩功能的实例配置</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">gzip</span> on<span class="token punctuation">;</span>    <span class="token comment">#开启gzip功能</span>gzip_types *<span class="token punctuation">;</span>  <span class="token comment">#压缩源文件类型,根据具体的访问资源类型设定</span>gzip_comp_level <span class="token number">6</span><span class="token punctuation">;</span>  <span class="token comment">#gzip压缩级别</span>gzip_min_length <span class="token number">1024</span><span class="token punctuation">;</span> <span class="token comment">#进行压缩响应页面的最小长度,content-length</span>gzip_buffers <span class="token number">4</span> 16K<span class="token punctuation">;</span>  <span class="token comment">#缓存空间大小</span>gzip_http_version <span class="token number">1.1</span><span class="token punctuation">;</span> <span class="token comment">#指定压缩响应所需要的最低HTTP请求版本</span>gzip_vary  on<span class="token punctuation">;</span>  <span class="token comment">#往头信息中添加压缩标识</span>gzip_disable <span class="token string">"MSIE [1-6]\."</span><span class="token punctuation">;</span> <span class="token comment">#对IE6以下的版本都不进行压缩</span>gzip_proxied  off； <span class="token comment">#nginx作为反向代理压缩服务端返回数据的条件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些配置在很多地方可能都会用到，所以我们可以将这些内容抽取到一个配置文件中，然后通过include指令把配置文件再次加载到nginx.conf配置文件中，方法使用。</p><p>nginx_gzip.conf</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">gzip</span> on<span class="token punctuation">;</span>gzip_types *<span class="token punctuation">;</span>gzip_comp_level <span class="token number">6</span><span class="token punctuation">;</span>gzip_min_length <span class="token number">1024</span><span class="token punctuation">;</span>gzip_buffers <span class="token number">4</span> 16K<span class="token punctuation">;</span>gzip_http_version <span class="token number">1.1</span><span class="token punctuation">;</span>gzip_vary  on<span class="token punctuation">;</span>gzip_disable <span class="token string">"MSIE [1-6]\."</span><span class="token punctuation">;</span>gzip_proxied  off<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>nginx.conf</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">include nginx_gzip.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Gzip和sendfile共存问题"><a href="#Gzip和sendfile共存问题" class="headerlink" title="Gzip和sendfile共存问题"></a>Gzip和sendfile共存问题</h4><p>前面在讲解sendfile的时候，提到过，开启sendfile以后，在读取磁盘上的静态资源文件的时候，可以减少拷贝的次数，可以不经过用户进程将静态文件通过网络设备发送出去，但是Gzip要想对资源压缩，是需要经过用户进程进行操作的。所以如何解决两个设置的共存问题。</p><p>可以使用ngx_http_gzip_static_module模块的gzip_static指令来解决。</p><h5 id="gzip-static指令"><a href="#gzip-static指令" class="headerlink" title="gzip_static指令"></a>gzip_static指令</h5><p>gzip_static: 检查与访问资源同名的.gz文件时，response中以gzip相关的header返回.gz文件的内容。</p><table><thead><tr><th>语法</th><th><strong>gzip_static</strong> on | off | always;</th></tr></thead><tbody><tr><td>默认值</td><td>gzip_static off;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>添加上述命令后，会报一个错误，<code>unknown directive &quot;gzip_static&quot;</code>主要的原因是Nginx默认是没有添加ngx_http_gzip_static_module模块。如何来添加?</p><h5 id="添加模块到Nginx的实现步骤"><a href="#添加模块到Nginx的实现步骤" class="headerlink" title="添加模块到Nginx的实现步骤"></a>添加模块到Nginx的实现步骤</h5><p>(1)查询当前Nginx的配置参数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx -V<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(2)将nginx安装目录下sbin目录中的nginx二进制文件进行更名</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/nginx/sbin<span class="token function">mv</span> nginx nginxold<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>(3) 进入Nginx的安装目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root/nginx/core/nginx-1.16.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(4)执行make clean清空之前编译的内容</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(5)使用configure来配置参数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure --with-http_gzip_static_module<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(6)使用make命令进行编译</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(7) 将objs目录下的nginx二进制执行文件移动到nginx安装目录下的sbin目录中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> objs/nginx /usr/local/nginx/sbin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(8)执行更新命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="gzip-static测试使用"><a href="#gzip-static测试使用" class="headerlink" title="gzip_static测试使用"></a>gzip_static测试使用</h5><p>(1)直接访问<code>http://192.168.200.133/jquery.js</code></p><p>(2)使用gzip命令进行压缩</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/nginx/html<span class="token function">gzip</span> jquery.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>(3)再次访问<code>http://192.168.200.133/jquery.js</code></p><h3 id="静态资源的缓存处理"><a href="#静态资源的缓存处理" class="headerlink" title="静态资源的缓存处理"></a>静态资源的缓存处理</h3><h4 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">缓存（cache），原始意义是指访问速度比一般随机存取存储器（RAM）快的一种高速存储器，通常它不像系统主存那样使用DRAM技术，而使用昂贵但较快速的SRAM技术。缓存的设置是所有现代计算机系统发挥高性能的重要因素之一。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="什么是web缓存"><a href="#什么是web缓存" class="headerlink" title="什么是web缓存"></a>什么是web缓存</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="web缓存的种类"><a href="#web缓存的种类" class="headerlink" title="web缓存的种类"></a>web缓存的种类</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">客户端缓存浏览器缓存服务端缓存Nginx / Redis / Memcached等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="为什么要用浏览器缓存"><a href="#为什么要用浏览器缓存" class="headerlink" title="为什么要用浏览器缓存"></a>为什么要用浏览器缓存</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">成本最低的一种缓存实现减少网络带宽消耗降低服务器压力减少网络延迟，加快页面打开速度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="浏览器缓存的执行流程"><a href="#浏览器缓存的执行流程" class="headerlink" title="浏览器缓存的执行流程"></a>浏览器缓存的执行流程</h4><p>HTTP协议中和页面缓存相关的字段，我们先来认识下：</p><table><thead><tr><th>header</th><th>说明</th></tr></thead><tbody><tr><td>Expires</td><td>缓存过期的日期和时间</td></tr><tr><td>Cache-Control</td><td>设置和缓存相关的配置信息</td></tr><tr><td>Last-Modified</td><td>请求资源最后修改时间</td></tr><tr><td>ETag</td><td>请求变量的实体标签的当前值，比如文件的MD5值</td></tr></tbody></table><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>（1）用户首次通过浏览器发送请求到服务端获取数据，客户端是没有对应的缓存，所以需要发送request请求来获取数据；</p><p>（2）服务端接收到请求后，获取服务端的数据及服务端缓存的允许后，返回200的成功状态码并且在响应头上附上对应资源以及缓存信息；</p><p>（3）当用户再次访问相同资源的时候，客户端会在浏览器的缓存目录中查找是否存在响应的缓存文件</p><p>（4）如果没有找到对应的缓存文件，则走(2)步</p><p>（5）如果有缓存文件，接下来对缓存文件是否过期进行判断，过期的判断标准是(Expires),</p><p>（6）如果没有过期，则直接从本地缓存中返回数据进行展示</p><p>（7）如果Expires过期，接下来需要判断缓存文件是否发生过变化</p><p>（8）判断的标准有两个，一个是ETag(Entity Tag),一个是Last-Modified</p><p>（9）判断结果是未发生变化，则服务端返回304，直接从缓存文件中获取数据</p><p>（10）如果判断是发生了变化，重新从服务端获取数据，并根据缓存协商(服务端所设置的是否需要进行缓存数据的设置)来进行数据缓存。</p><h4 id="浏览器缓存相关指令"><a href="#浏览器缓存相关指令" class="headerlink" title="浏览器缓存相关指令"></a>浏览器缓存相关指令</h4><p>Nginx需要进行缓存相关设置，就需要用到如下的指令</p><h5 id="expires指令"><a href="#expires指令" class="headerlink" title="expires指令"></a>expires指令</h5><p>expires:该指令用来控制页面缓存的作用。可以通过该指令控制HTTP应答中的“Expires”和”Cache-Control”</p><table><thead><tr><th>语法</th><th>expires   [modified] time<br/>expires epoch|max|off;</th></tr></thead><tbody><tr><td>默认值</td><td>expires off;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>time:可以整数也可以是负数，指定过期时间，如果是负数，Cache-Control则为no-cache,如果为整数或0，则Cache-Control的值为max-age=time;</p><p>epoch: 指定Expires的值为’1 January,1970,00:00:01 GMT’(1970-01-01 00:00:00)，Cache-Control的值no-cache</p><p>max:指定Expires的值为’31 December2037 23:59:59GMT’ (2037-12-31 23:59:59) ，Cache-Control的值为10年</p><p>off:默认不缓存。</p><h5 id="add-header指令"><a href="#add-header指令" class="headerlink" title="add_header指令"></a>add_header指令</h5><p>add_header指令是用来添加指定的响应头和响应值。</p><table><thead><tr><th>语法</th><th>add_header name value [always];</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>http、server、location…</td></tr></tbody></table><p>Cache-Control作为响应头信息，可以设置如下值：</p><p>缓存响应指令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Cache-control: must-revalidateCache-control: no-cacheCache-control: no-storeCache-control: no-transformCache-control: publicCache-control: privateCache-control: proxy-revalidateCache-Control: max-age<span class="token operator">=</span><span class="token operator">&lt;</span>seconds<span class="token operator">></span>Cache-control: s-maxage<span class="token operator">=</span><span class="token operator">&lt;</span>seconds<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>must-revalidate</td><td>可缓存但必须再向源服务器进行确认</td></tr><tr><td>no-cache</td><td>缓存前必须确认其有效性</td></tr><tr><td>no-store</td><td>不缓存请求或响应的任何内容</td></tr><tr><td>no-transform</td><td>代理不可更改媒体类型</td></tr><tr><td>public</td><td>可向任意方提供响应的缓存</td></tr><tr><td>private</td><td>仅向特定用户返回响应</td></tr><tr><td>proxy-revalidate</td><td>要求中间缓存服务器对缓存的响应有效性再进行确认</td></tr><tr><td>max-age=&lt;秒&gt;</td><td>响应最大Age值</td></tr><tr><td>s-maxage=&lt;秒&gt;</td><td>公共缓存服务器响应的最大Age值</td></tr></tbody></table><p>max-age=[秒]：</p><h3 id="Nginx的跨域问题解决"><a href="#Nginx的跨域问题解决" class="headerlink" title="Nginx的跨域问题解决"></a>Nginx的跨域问题解决</h3><p>这块内容，我们主要从以下方面进行解决：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">什么情况下会出现跨域问题?实例演示跨域问题具体的解决方案是什么?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>浏览器的同源策略：是一种约定，是浏览器最核心也是最基本的安全功能，如果浏览器少了同源策略，则浏览器的正常功能可能都会受到影响。</p><p>同源:  协议、域名(IP)、端口相同即为同源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http://192.168.200.131/user/1https://192.168.200.131/user/1不http://192.168.200.131/user/1http://192.168.200.132/user/1不http://192.168.200.131/user/1http://192.168.200.131:8080/user/1不http://www.nginx.com/user/1http://www.nginx.org/user/1不http://192.168.200.131/user/1http://192.168.200.131:8080/user/1不http://www.nginx.org:80/user/1http://www.nginx.org/user/1满足<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h4><p>简单描述下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">有两台服务器分别为A,B,如果从服务器A的页面发送异步请求到服务器B获取数据，如果服务器A和服务器B不满足同源策略，则就会出现跨域问题。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="跨域问题的案例演示"><a href="#跨域问题的案例演示" class="headerlink" title="跨域问题的案例演示"></a>跨域问题的案例演示</h4><p>出现跨域问题会有什么效果?</p><p>（1）nginx的html目录下新建一个a.html</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>跨域问题演示<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jquery.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">            <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#btn"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        $<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'http://192.168.200.133:8080/getUser'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>获取数据<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）在nginx.conf配置如下内容</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span>        listen  <span class="token number">8080</span><span class="token punctuation">;</span>        server_name localhost<span class="token punctuation">;</span>        location /getUser<span class="token punctuation">&#123;</span>                default_type application/json<span class="token punctuation">;</span>                <span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token string">'&#123;"id":1,"name":"TOM","age":18&#125;'</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>server<span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /<span class="token punctuation">&#123;</span>root html<span class="token punctuation">;</span>index index.html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>​``<span class="token variable"><span class="token variable">`</span><span class="token function">bash</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>通过浏览器访问测试<span class="token comment">#### 解决方案</span>使用add_header指令，该指令可以用来添加一些头信息<span class="token operator">|</span> 语法   <span class="token operator">|</span> add_header name  value<span class="token punctuation">..</span>. <span class="token operator">|</span><span class="token operator">|</span> ------ <span class="token operator">|</span> ------------------------- <span class="token operator">|</span><span class="token operator">|</span> 默认值 <span class="token operator">|</span> —                         <span class="token operator">|</span><span class="token operator">|</span> 位置   <span class="token operator">|</span> http、server、location    <span class="token operator">|</span>此处用来解决跨域问题，需要添加两个头信息，一个是<span class="token variable">`</span></span>Access-Control-Allow-Origin<span class="token variable"><span class="token variable">`</span>,<span class="token variable">`</span></span>Access-Control-Allow-Methods<span class="token variable"><span class="token variable">`</span>Access-Control-Allow-Origin: 直译过来是允许跨域访问的源地址信息，可以配置多个<span class="token punctuation">(</span>多个用逗号分隔<span class="token punctuation">)</span>，也可以使用<span class="token variable">`</span></span>*<span class="token variable"><span class="token variable">`</span>代表所有源Access-Control-Allow-Methods:直译过来是允许跨域访问的请求方式，值可以为 GET POST PUT DELETE<span class="token punctuation">..</span>.,可以全部设置，也可以根据需要设置，多个用逗号分隔具体配置方式​<span class="token variable">`</span></span>``bashlocation /getUser<span class="token punctuation">&#123;</span>    add_header Access-Control-Allow-Origin *<span class="token punctuation">;</span>    add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE<span class="token punctuation">;</span>    default_type application/json<span class="token punctuation">;</span>    <span class="token builtin class-name">return</span> <span class="token number">200</span> <span class="token string">'&#123;"id":1,"name":"TOM","age":18&#125;'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="静态资源防盗链"><a href="#静态资源防盗链" class="headerlink" title="静态资源防盗链"></a>静态资源防盗链</h3><h4 id="什么是资源盗链"><a href="#什么是资源盗链" class="headerlink" title="什么是资源盗链"></a>什么是资源盗链</h4><p>资源盗链指的是此内容不在自己服务器上，而是通过技术手段，绕过别人的限制将别人的内容放到自己页面上最终展示给用户。以此来盗取大网站的空间和流量。简而言之就是用别人的东西成就自己的网站。</p><p>效果演示</p><p>东:<a href="https://img14.360buyimg.com/n7/jfs/t1/101062/37/2153/254169/5dcbd410E6d10ba22/4ddbd212be225fcd.jpg">https://img14.360buyimg.com/n7/jfs/t1/101062/37/2153/254169/5dcbd410E6d10ba22/4ddbd212be225fcd.jpg</a></p><p>百度:<a href="https://pics7.baidu.com/feed/cf1b9d16fdfaaf516f7e2011a7cda1e8f11f7a1a.jpeg?token=551979a23a0995e5e5279b8fa1a48b34&amp;s=BD385394D2E963072FD48543030030BB">https://pics7.baidu.com/feed/cf1b9d16fdfaaf516f7e2011a7cda1e8f11f7a1a.jpeg?token=551979a23a0995e5e5279b8fa1a48b34&amp;s=BD385394D2E963072FD48543030030BB</a></p><p>我们自己准备一个页面，在页面上引入这两个图片查看效果<br>从上面的效果，可以看出来，下面的图片地址添加了防止盗链的功能，京东这边我们可以直接使用其图片。</p><h4 id="Nginx防盗链的实现原理："><a href="#Nginx防盗链的实现原理：" class="headerlink" title="Nginx防盗链的实现原理："></a>Nginx防盗链的实现原理：</h4><p>了解防盗链的原理之前，我们得先学习一个HTTP的头信息Referer,当浏览器向web服务器发送请求的时候，一般都会带上Referer,来告诉浏览器该网页是从哪个页面链接过来的。</p><p>后台服务器可以根据获取到的这个Referer信息来判断是否为自己信任的网站地址，如果是则放行继续访问，如果不是则可以返回403(服务端拒绝访问)的状态信息。</p><p>Nginx防盗链的具体实现:</p><p>valid_referers:nginx会通就过查看referer自动和valid_referers后面的内容进行匹配，如果匹配到了就将$invalid_referer变量置0，如果没有匹配到，则将$invalid_referer变量置为1，匹配的过程中不区分大小写。</p><table><thead><tr><th>语法</th><th>valid_referers none|blocked|server_names|string…</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location</td></tr></tbody></table><p>none: 如果Header中的Referer为空，允许访问</p><p>blocked:在Header中的Referer不为空，但是该值被防火墙或代理进行伪装过，如不带”http://“ 、”https://“等协议头的资源允许访问。</p><p>server_names:指定具体的域名或者IP</p><p>string: 可以支持正则表达式和*的字符串。如果是正则表达式，需要以<code>~</code>开头表示，例如</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location ~*<span class="token punctuation">\</span>.<span class="token punctuation">(</span>png<span class="token operator">|</span>jpg<span class="token operator">|</span>gif<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           valid_referers none blocked www.baidu.com <span class="token number">192.168</span>.200.222 *.example.com example.*  www.example.org  ~<span class="token punctuation">\</span>.google<span class="token punctuation">\</span>.<span class="token punctuation">;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$invalid_referer</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token builtin class-name">return</span> <span class="token number">403</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span>           root /usr/local/nginx/html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>遇到的问题:图片有很多，该如何批量进行防盗链？</p><h4 id="针对目录进行防盗链"><a href="#针对目录进行防盗链" class="headerlink" title="针对目录进行防盗链"></a>针对目录进行防盗链</h4><p>配置如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location /images <span class="token punctuation">&#123;</span>           valid_referers none blocked www.baidu.com <span class="token number">192.168</span>.200.222 *.example.com example.*  www.example.org  ~<span class="token punctuation">\</span>.google<span class="token punctuation">\</span>.<span class="token punctuation">;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$invalid_referer</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token builtin class-name">return</span> <span class="token number">403</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span>           root /usr/local/nginx/html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们可以对一个目录下的所有资源进行翻到了操作。</p><p>遇到的问题：Referer的限制比较粗，比如随意加一个Referer，上面的方式是无法进行限制的。那么这个问题改如何解决？</p><p>此处我们需要用到Nginx的第三方模块<code>ngx_http_accesskey_module</code>，第三方模块如何实现盗链，如果在Nginx中使用第三方模块的功能，这些我们在后面的Nginx的模块篇再进行详细的讲解。</p><h3 id="Rewrite功能配置"><a href="#Rewrite功能配置" class="headerlink" title="Rewrite功能配置"></a>Rewrite功能配置</h3><p>Rewrite是Nginx服务器提供的一个重要基本功能，是Web服务器产品中几乎必备的功能。主要的作用是用来实现URL的重写。</p><p>注意:Nginx服务器的Rewrite功能的实现依赖于PCRE的支持，因此在编译安装Nginx服务器之前，需要安装PCRE库。Nginx使用的是ngx_http_rewrite_module模块来解析和处理Rewrite功能的相关配置。</p><h4 id="“地址重写”与”地址转发”"><a href="#“地址重写”与”地址转发”" class="headerlink" title="“地址重写”与”地址转发”"></a>“地址重写”与”地址转发”</h4><p>重写和转发的区别:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">地址重写浏览器地址会发生变化而地址转发则不变一次地址重写会产生两次请求而一次地址转发只会产生一次请求地址重写到的页面必须是一个完整的路径而地址转发则不需要地址重写因为是两次请求所以request范围内属性不能传递给新页面而地址转发因为是一次请求所以可以传递值地址转发速度快于地址重写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Rewrite规则"><a href="#Rewrite规则" class="headerlink" title="Rewrite规则"></a>Rewrite规则</h4><h4 id="set指令"><a href="#set指令" class="headerlink" title="set指令"></a>set指令</h4><p>该指令用来设置一个新的变量。</p><table><thead><tr><th>语法</th><th>set $variable value;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location、if</td></tr></tbody></table><p>variable:变量的名称，该变量名称要用”$”作为变量的第一个字符，且不能与Nginx服务器预设的全局变量同名。</p><p>value:变量的值，可以是字符串、其他变量或者变量的组合等。</p><h4 id="Rewrite常用全局变量"><a href="#Rewrite常用全局变量" class="headerlink" title="Rewrite常用全局变量"></a>Rewrite常用全局变量</h4><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>$args</td><td>变量中存放了请求URL中的请求指令。比如<a href="http://192.168.200.133:8080/?arg1=value1&amp;args2=value2%E4%B8%AD%E7%9A%84&quot;arg1=value1&amp;arg2=value2&quot;%EF%BC%8C%E5%8A%9F%E8%83%BD%E5%92%8C$query_string%E4%B8%80%E6%A0%B7">http://192.168.200.133:8080?arg1=value1&amp;args2=value2中的&quot;arg1=value1&amp;arg2=value2&quot;，功能和$query_string一样</a></td></tr><tr><td>$http_user_agent</td><td>变量存储的是用户访问服务的代理信息(如果通过浏览器访问，记录的是浏览器的相关版本信息)</td></tr><tr><td>$host</td><td>变量存储的是访问服务器的server_name值</td></tr><tr><td>$document_uri</td><td>变量存储的是当前访问地址的URI。比如<a href="http://192.168.200.133/server?id=10&amp;name=zhangsan%E4%B8%AD%E7%9A%84&quot;/server&quot;%EF%BC%8C%E5%8A%9F%E8%83%BD%E5%92%8C$uri%E4%B8%80%E6%A0%B7">http://192.168.200.133/server?id=10&amp;name=zhangsan中的&quot;/server&quot;，功能和$uri一样</a></td></tr><tr><td>$document_root</td><td>变量存储的是当前请求对应location的root值，如果未设置，默认指向Nginx自带html目录所在位置</td></tr><tr><td>$content_length</td><td>变量存储的是请求头中的Content-Length的值</td></tr><tr><td>$content_type</td><td>变量存储的是请求头中的Content-Type的值</td></tr><tr><td>$http_cookie</td><td>变量存储的是客户端的cookie信息，可以通过add_header Set-Cookie ‘cookieName=cookieValue’来添加cookie数据</td></tr><tr><td>$limit_rate</td><td>变量中存储的是Nginx服务器对网络连接速率的限制，也就是Nginx配置中对limit_rate指令设置的值，默认是0，不限制。</td></tr><tr><td>$remote_addr</td><td>变量中存储的是客户端的IP地址</td></tr><tr><td>$remote_port</td><td>变量中存储了客户端与服务端建立连接的端口号</td></tr><tr><td>$remote_user</td><td>变量中存储了客户端的用户名，需要有认证模块才能获取</td></tr><tr><td>$scheme</td><td>变量中存储了访问协议</td></tr><tr><td>$server_addr</td><td>变量中存储了服务端的地址</td></tr><tr><td>$server_name</td><td>变量中存储了客户端请求到达的服务器的名称</td></tr><tr><td>$server_port</td><td>变量中存储了客户端请求到达服务器的端口号</td></tr><tr><td>$server_protocol</td><td>变量中存储了客户端请求协议的版本，比如”HTTP/1.1”</td></tr><tr><td>$request_body_file</td><td>变量中存储了发给后端服务器的本地文件资源的名称</td></tr><tr><td>$request_method</td><td>变量中存储了客户端的请求方式，比如”GET”,”POST”等</td></tr><tr><td>$request_filename</td><td>变量中存储了当前请求的资源文件的路径名</td></tr><tr><td>$request_uri</td><td>变量中存储了当前请求的URI，并且携带请求参数，比如<a href="http://192.168.200.133/server?id=10&amp;name=zhangsan%E4%B8%AD%E7%9A%84&quot;/server?id=10&amp;name=zhangsan&quot;">http://192.168.200.133/server?id=10&amp;name=zhangsan中的&quot;/server?id=10&amp;name=zhangsan&quot;</a></td></tr></tbody></table><h4 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h4><p>该指令用来支持条件判断，并根据条件判断结果选择不同的Nginx配置。</p><table><thead><tr><th>语法</th><th>if  (condition){…}</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location</td></tr></tbody></table><p>condition为判定条件，可以支持以下写法：</p><ol><li>变量名。如果变量名对应的值为空或者是0，if都判断为false,其他条件为true。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$param</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">2</span>. 使用<span class="token string">"="</span>和<span class="token string">"!="</span>比较变量和字符串是否相等，满足条件为true，不满足为false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$request_method</span> <span class="token operator">=</span> POST<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token builtin class-name">return</span> <span class="token number">405</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：此处和Java不太一样的地方是字符串不需要添加引号。</p><ol start="3"><li><p>使用正则表达式对变量进行匹配，匹配成功返回true，否则返回false。变量与正则表达式之间使用”<del>“,”</del>*”,”!<del>“,”!</del>*“来连接。</p><p>“~”代表匹配正则表达式过程中区分大小写，</p><p>“~*“代表匹配正则表达式过程中不区分大小写</p><p>“!<del>“和”!</del>*“刚好和上面取相反值，如果匹配上返回false,匹配不上返回true</p></li></ol><pre class="line-numbers language-none"><code class="language-none">if ($http_user_agent ~ MSIE)&#123;#$http_user_agent的值中是否包含MSIE字符串，如果包含返回true&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：正则表达式字符串一般不需要加引号，但是如果字符串中包含”}”或者是”;”等字符时，就需要把引号加上。</p><ol start="4"><li><p>判断请求的文件是否存在使用”-f”和”!-f”,</p><p>当使用”-f”时，如果请求的文件存在返回true，不存在返回false。</p><p>当使用”!f”时，如果请求文件不存在，但该文件所在目录存在返回true,文件和目录都不存在返回false,如果文件存在返回false</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">(</span>-f <span class="token variable">$request_filename</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">#判断请求的文件是否存在</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>-f <span class="token variable">$request_filename</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">#判断请求的文件是否不存在</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li><p>判断请求的目录是否存在使用”-d”和”!-d”,</p><p>当使用”-d”时，如果请求的目录存在，if返回true，如果目录不存在则返回false</p><p>当使用”!-d”时，如果请求的目录不存在但该目录的上级目录存在则返回true，该目录和它上级目录都不存在则返回false,如果请求目录存在也返回false.</p></li><li><p>判断请求的目录或者文件是否存在使用”-e”和”!-e”</p><p>当使用”-e”,如果请求的目录或者文件存在时，if返回true,否则返回false.</p><p>当使用”!-e”,如果请求的文件和文件所在路径上的目录都不存在返回true,否则返回false</p></li><li><p>判断请求的文件是否可执行使用”-x”和”!-x”</p><p>当使用”-x”,如果请求的文件可执行，if返回true,否则返回false</p><p>当使用”!-x”,如果请求文件不可执行，返回true,否则返回false</p></li></ol><h4 id="break指令"><a href="#break指令" class="headerlink" title="break指令"></a>break指令</h4><p>该指令用于中断当前相同作用域中的其他Nginx配置。与该指令处于同一作用域的Nginx配置中，位于它前面的指令配置生效，位于后面的指令配置无效。</p><table><thead><tr><th>语法</th><th>break;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location、if</td></tr></tbody></table><p>例子:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location /<span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$param</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token builtin class-name">set</span> <span class="token variable">$id</span> <span class="token variable">$1</span><span class="token punctuation">;</span><span class="token builtin class-name">break</span><span class="token punctuation">;</span>limit_rate 10k<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="return指令"><a href="#return指令" class="headerlink" title="return指令"></a>return指令</h4><p>该指令用于完成对请求的处理，直接向客户端返回响应状态代码。在return后的所有Nginx配置都是无效的。</p><table><thead><tr><th>语法</th><th>return code [text];<br/>return code URL;<br/>return URL;</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location、if</td></tr></tbody></table><p>code:为返回给客户端的HTTP状态代理。可以返回的状态代码为0~999的任意HTTP状态代理</p><p>text:为返回给客户端的响应体内容，支持变量的使用</p><p>URL:为返回给客户端的URL地址</p><h4 id="rewrite指令"><a href="#rewrite指令" class="headerlink" title="rewrite指令"></a>rewrite指令</h4><p>该指令通过正则表达式的使用来改变URI。可以同时存在一个或者多个指令，按照顺序依次对URL进行匹配和处理。</p><p>URL和URI的区别：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">URI:统一资源标识符URL:统一资源定位符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><table><thead><tr><th>语法</th><th>rewrite regex replacement [flag];</th></tr></thead><tbody><tr><td>默认值</td><td>—</td></tr><tr><td>位置</td><td>server、location、if</td></tr></tbody></table><p>regex:用来匹配URI的正则表达式</p><p>replacement:匹配成功后，用于替换URI中被截取内容的字符串。如果该字符串是以”http://“或者”https://“开头的，则不会继续向下对URI进行其他处理，而是直接返回重写后的URI给客户端。</p><p>flag:用来设置rewrite对URI的处理行为，可选值有如下：</p><ul><li>last:</li><li>break</li><li>redirect</li><li>permanent</li></ul><h4 id="rewrite-log指令"><a href="#rewrite-log指令" class="headerlink" title="rewrite_log指令"></a>rewrite_log指令</h4><p>该指令配置是否开启URL重写日志的输出功能。</p><table><thead><tr><th>语法</th><th>rewrite_log on|off;</th></tr></thead><tbody><tr><td>默认值</td><td>rewrite_log off;</td></tr><tr><td>位置</td><td>http、server、location、if</td></tr></tbody></table><p>开启后，URL重写的相关日志将以notice级别输出到error_log指令配置的日志文件汇总。</p><h3 id="Rewrite的案例"><a href="#Rewrite的案例" class="headerlink" title="Rewrite的案例"></a>Rewrite的案例</h3><h4 id="域名跳转"><a href="#域名跳转" class="headerlink" title="域名跳转"></a>域名跳转</h4><p>》问题分析</p><p>先来看一个效果，如果我们想访问京东网站，大家都知道我们可以输入<code>www.jd.com</code>,但是同样的我们也可以输入<code>www.360buy.com</code>同样也都能访问到京东网站。这个其实是因为京东刚开始的时候域名就是<a href="http://www.360buy.com,后面由于各种原因把自己的域名换成了www.jd.com/">www.360buy.com，后面由于各种原因把自己的域名换成了www.jd.com</a>, 虽然说域名变量，但是对于以前只记住了<a href="http://www.360buy.com的用户来说,我们如何把这部分用户也迁移到我们新域名的访问上来,针对于这个问题,我们就可以使用nginx中rewrite的域名跳转来解决./">www.360buy.com的用户来说，我们如何把这部分用户也迁移到我们新域名的访问上来，针对于这个问题，我们就可以使用Nginx中Rewrite的域名跳转来解决。</a></p><p>》环境准备</p><ul><li>准备两个域名  <a href="http://www.360buy.com/">www.360buy.com</a> | <a href="http://www.jd.com/">www.jd.com</a></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/hosts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">192.168</span>.200.133 www.360buy.com<span class="token number">192.168</span>.200.133 www.jd.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>在/usr/local/nginx/html/hm目录下创建一个访问页面</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>欢迎来到我们的网站<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通过Nginx实现当访问www.访问到系统的首页</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name www.hm.com<span class="token punctuation">;</span>location /<span class="token punctuation">&#123;</span>root /usr/local/nginx/html/hm<span class="token punctuation">;</span>index index.html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>》通过Rewrite完成将<a href="http://www.360buy.com的请求跳转到www.jd.com/">www.360buy.com的请求跳转到www.jd.com</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name www.360buy.com<span class="token punctuation">;</span>rewrite ^/ http://www.jd.com permanent<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题描述:如何在域名跳转的过程中携带请求的URI？</p><p>修改配置信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name www.itheima.com<span class="token punctuation">;</span>rewrite ^<span class="token punctuation">(</span>.*<span class="token punctuation">)</span> http://www.hm.com<span class="token variable">$1</span> permanent<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题描述:我们除了上述说的<a href="http://www.jd.com/">www.jd.com</a> 、<a href="http://www.360buy.com其实还有我们也可以通过www.jingdong.com来访问,那么如何通过rewrite来实现多个域名的跳转/">www.360buy.com其实还有我们也可以通过www.jingdong.com来访问，那么如何通过Rewrite来实现多个域名的跳转</a>?</p><p>添加域名</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/hosts<span class="token number">192.168</span>.200.133 www.jingdong.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改配置信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name www.360buy.com www.jingdong.com<span class="token punctuation">;</span>rewrite ^<span class="token punctuation">(</span>.*<span class="token punctuation">)</span> http://www.jd.com<span class="token variable">$1</span> permanent<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="域名镜像"><a href="#域名镜像" class="headerlink" title="域名镜像"></a>域名镜像</h4><p>上述案例中，将<a href="http://www.360buy.com/">www.360buy.com</a> 和 <a href="http://www.jingdong.com都能跳转到www.jd.com,那么www.jd.com我们就可以把它起名叫主域名,其他两个就是我们所说的镜像域名,当然如果我们不想把整个网站做镜像,只想为其中某一个子目录下的资源做镜像,我们可以在location块中配置rewrite功能,比如/">www.jingdong.com都能跳转到www.jd.com，那么www.jd.com我们就可以把它起名叫主域名，其他两个就是我们所说的镜像域名，当然如果我们不想把整个网站做镜像，只想为其中某一个子目录下的资源做镜像，我们可以在location块中配置rewrite功能，比如</a>:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name rewrite.myweb.com<span class="token punctuation">;</span>location ^~ /source1<span class="token punctuation">&#123;</span>rewrite ^/resource1<span class="token punctuation">(</span>.*<span class="token punctuation">)</span> http://rewrite.myweb.com/web<span class="token variable">$1</span> last<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>location ^~ /source2<span class="token punctuation">&#123;</span>rewrite ^/resource2<span class="token punctuation">(</span>.*<span class="token punctuation">)</span> http://rewrite.myweb.com/web<span class="token variable">$1</span> last<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="独立域名"><a href="#独立域名" class="headerlink" title="独立域名"></a>独立域名</h4><p>一个完整的项目包含多个模块，比如购物网站有商品商品搜索模块、商品详情模块已经购物车模块等，那么我们如何为每一个模块设置独立的域名。</p><p>需求：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http://search.hm.com  访问商品搜索模块http://item.hm.com  访问商品详情模块http://cart.hm.com  访问商品购物车模块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name search.hm.com<span class="token punctuation">;</span>rewrite ^<span class="token punctuation">(</span>.*<span class="token punctuation">)</span> http://www.hm.com/bbs<span class="token variable">$1</span> last<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server<span class="token punctuation">&#123;</span>listen <span class="token number">81</span><span class="token punctuation">;</span>server_name item.hm.com<span class="token punctuation">;</span>rewrite ^<span class="token punctuation">(</span>.*<span class="token punctuation">)</span> http://www.hm.com/item<span class="token variable">$1</span> last<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server<span class="token punctuation">&#123;</span>listen <span class="token number">82</span><span class="token punctuation">;</span>server_name cart.hm.com<span class="token punctuation">;</span>rewrite ^<span class="token punctuation">(</span>.*<span class="token punctuation">)</span> http://www.hm.com/cart<span class="token variable">$1</span> last<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="目录自动添加”-“"><a href="#目录自动添加”-“" class="headerlink" title="目录自动添加”/“"></a>目录自动添加”/“</h4><p>问题描述</p><p>通过一个例子来演示下问题:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen<span class="token number">80</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location / <span class="token punctuation">&#123;</span>root html<span class="token punctuation">;</span>index index.html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要想访问上述资源，很简单，只需要通过<a href="http://192.168.200.133直接就能访问,地址后面不需要加/,%E4%BD%86%E6%98%AF%E5%A6%82%E6%9E%9C%E5%B0%86%E4%B8%8A%E8%BF%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9%E4%B8%BA%E5%A6%82%E4%B8%8B%E5%86%85%E5%AE%B9">http://192.168.200.133直接就能访问，地址后面不需要加/,但是如果将上述的配置修改为如下内容</a>:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen<span class="token number">80</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>location /hm <span class="token punctuation">&#123;</span>root html<span class="token punctuation">;</span>index index.html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候，要想访问上述资源，按照上述的访问方式，我们可以通过<a href="http://192.168.200.133/hm/%E6%9D%A5%E8%AE%BF%E9%97%AE,%E4%BD%86%E6%98%AF%E5%A6%82%E6%9E%9C%E5%9C%B0%E5%9D%80%E5%90%8E%E9%9D%A2%E4%B8%8D%E5%8A%A0%E6%96%9C%E6%9D%A0%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%B0%B1%E4%BC%9A%E5%87%BA%E9%97%AE%E9%A2%98%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%8A%A0%E6%96%9C%E6%9D%A0%EF%BC%8CNginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E9%83%A8%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%81%9A%E4%B8%80%E4%B8%AA301%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%9C%B0%E5%9D%80%E4%BC%9A%E6%9C%89%E4%B8%80%E4%B8%AA%E6%8C%87%E4%BB%A4%E5%8F%ABserver_name_in_redirect">http://192.168.200.133/hm/来访问,但是如果地址后面不加斜杠，页面就会出问题。如果不加斜杠，Nginx服务器内部会自动做一个301的重定向，重定向的地址会有一个指令叫server_name_in_redirect</a> on|off;来决定重定向的地址：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">如果该指令为on重定向的地址为:  http://server_name/目录名/<span class="token punctuation">;</span>如果该指令为off重定向的地址为:  http://原URL中的域名/目录名/<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>所以就拿刚才的地址来说，<a href="http://192.168.200.133/hm%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%8A%A0%E6%96%9C%E6%9D%A0%EF%BC%8C%E9%82%A3%E4%B9%88%E6%8C%89%E7%85%A7%E4%B8%8A%E8%BF%B0%E8%A7%84%E5%88%99%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%8C%87%E4%BB%A4server_name_in_redirect%E4%B8%BAon%EF%BC%8C%E5%88%99301%E9%87%8D%E5%AE%9A%E5%90%91%E5%9C%B0%E5%9D%80%E5%8F%98%E4%B8%BA">http://192.168.200.133/hm如果不加斜杠，那么按照上述规则，如果指令server_name_in_redirect为on，则301重定向地址变为</a> <a href="http://localhost/hm/,%E5%A6%82%E6%9E%9C%E4%B8%BAoff%EF%BC%8C%E5%88%99301%E9%87%8D%E5%AE%9A%E5%90%91%E5%9C%B0%E5%9D%80%E5%8F%98%E4%B8%BAhttp://192.168.200.133/ht/%E3%80%82%E5%90%8E%E9%9D%A2%E8%BF%99%E4%B8%AA%E6%98%AF%E6%AD%A3%E5%B8%B8%E7%9A%84%EF%BC%8C%E5%89%8D%E9%9D%A2%E5%9C%B0%E5%9D%80%E5%B0%B1%E6%9C%89%E9%97%AE%E9%A2%98%E3%80%82">http://localhost/hm/,如果为off，则301重定向地址变为http://192.168.200.133/ht/。后面这个是正常的，前面地址就有问题。</a></p><p>注意server_name_in_redirect指令在Nginx的0.8.48版本之前默认都是on，之后改成了off,所以现在我们这个版本不需要考虑这个问题，但是如果是0.8.48以前的版本并且server_name_in_redirect设置为on，我们如何通过rewrite来解决这个问题？</p><p>解决方案</p><p>我们可以使用rewrite功能为末尾没有斜杠的URL自动添加一个斜杠</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen<span class="token number">80</span><span class="token punctuation">;</span>server_name localhost<span class="token punctuation">;</span>server_name_in_redirect on<span class="token punctuation">;</span>location /hm <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>-d <span class="token variable">$request_filename</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>rewrite ^/<span class="token punctuation">(</span>.*<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">[</span>^/<span class="token punctuation">]</span><span class="token punctuation">)</span>$ http://<span class="token variable">$host</span>/<span class="token variable">$1</span><span class="token variable">$2</span>/ permanent<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="合并目录"><a href="#合并目录" class="headerlink" title="合并目录"></a>合并目录</h4><p>搜索引擎优化(SEO)是一种利用搜索引擎的搜索规则来提供目的网站的有关搜索引擎内排名的方式。我们在创建自己的站点时，可以通过很多中方式来有效的提供搜索引擎优化的程度。其中有一项就包含URL的目录层级一般不要超过三层，否则的话不利于搜索引擎的搜索也给客户端的输入带来了负担，但是将所有的文件放在一个目录下又会导致文件资源管理混乱并且访问文件的速度也会随着文件增多而慢下来，这两个问题是相互矛盾的，那么使用rewrite如何解决上述问题?</p><p>举例，网站中有一个资源文件的访问路径时 /server/11/22/33/44/20.html,也就是说20.html存在于第5级目录下，如果想要访问该资源文件，客户端的URL地址就要写成 <code>http://www.web.name/server/11/22/33/44/20.html</code>,</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name www.web.name<span class="token punctuation">;</span>location /server<span class="token punctuation">&#123;</span>root html<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这个是非常不利于SEO搜索引擎优化的，同时客户端也不好记.使用rewrite我们可以进行如下配置:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name www.web.name<span class="token punctuation">;</span>location /server<span class="token punctuation">&#123;</span>rewrite ^/server-<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>+<span class="token punctuation">)</span>-<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>+<span class="token punctuation">)</span>-<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>+<span class="token punctuation">)</span>-<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>+<span class="token punctuation">)</span><span class="token punctuation">\</span>.html$ /server/<span class="token variable">$1</span>/<span class="token variable">$2</span>/<span class="token variable">$3</span>/<span class="token variable">$4</span>/<span class="token variable">$5</span>.html last<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的花，客户端只需要输入<a href="http://www.web.name/server-11-22-33-44-20.html%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E5%88%B020.html%E9%A1%B5%E9%9D%A2%E4%BA%86%E3%80%82%E8%BF%99%E9%87%8C%E4%B9%9F%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E4%BA%86rewrite%E6%8C%87%E4%BB%A4%E6%94%AF%E6%8C%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%89%B9%E6%80%A7%E3%80%82">http://www.web.name/server-11-22-33-44-20.html就可以访问到20.html页面了。这里也充分利用了rewrite指令支持正则表达式的特性。</a></p><h4 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h4><p>防盗链之前我们已经介绍过了相关的知识，在rewrite中的防盗链和之前将的原理其实都是一样的，只不过通过rewrite可以将防盗链的功能进行完善下，当出现防盗链的情况，我们可以使用rewrite将请求转发到自定义的一张图片和页面，给用户比较好的提示信息。下面我们就通过根据文件类型实现防盗链的一个配置实例:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name www.web.com<span class="token punctuation">;</span>locatin ~* ^.+<span class="token punctuation">\</span>.<span class="token punctuation">(</span>gif<span class="token operator">|</span>jpg<span class="token operator">|</span>png<span class="token operator">|</span>swf<span class="token operator">|</span>flv<span class="token operator">|</span><span class="token function">rar</span><span class="token operator">|</span><span class="token function">zip</span><span class="token punctuation">)</span><span class="token variable">$&#123;valid_referers none blocked server_names *.web.com;if ($invalid_referer)&#123;rewrite <span class="token operator">^</span><span class="token operator">/</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www.web.com<span class="token operator">/</span>images<span class="token operator">/</span>forbidden.png;&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据目录实现防盗链配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server<span class="token punctuation">&#123;</span>listen <span class="token number">80</span><span class="token punctuation">;</span>server_name www.web.com<span class="token punctuation">;</span>location /file/<span class="token punctuation">&#123;</span>root /server/file/<span class="token punctuation">;</span>valid_referers none blocked server_names *.web.com<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$invalid_referer</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>rewrite ^/ http://www.web.com/images/forbidden.png<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx服务启停和升级</title>
      <link href="/2021/07/25/Nginx/Nginx%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%81%9C%E5%92%8C%E5%8D%87%E7%BA%A7/"/>
      <url>/2021/07/25/Nginx/Nginx%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%81%9C%E5%92%8C%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="启停"><a href="#启停" class="headerlink" title="启停"></a>启停</h3><p>Nginx默认采用的是多进程的方式来工作的，当将Nginx启动后，我们通过<code>ps -ef | grep nginx</code>命令可以查看到如下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@192 ~<span class="token punctuation">]</span><span class="token comment"># ps -ef | grep nginx</span>root       <span class="token number">26115</span>       <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">18</span>:35 ?        00:00:00 nginx: master process ./nginxnobody     <span class="token number">26116</span>   <span class="token number">26115</span>  <span class="token number">0</span> <span class="token number">18</span>:35 ?        00:00:00 nginx: worker processroot       <span class="token number">26712</span>   <span class="token number">26666</span>  <span class="token number">0</span> <span class="token number">21</span>:57 pts/1    00:00:00 <span class="token function">grep</span> --color<span class="token operator">=</span>auto nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>,Nginx后台进程中包含一个master进程和多个worker进程，master进程主要用来管理worker进程，包含接收外界的信息，并将接收到的信号发送给各个worker进程，监控worker进程的状态，当worker进程出现异常退出后，会自动重新启动新的worker进程。而worker进程则是专门用来处理用户请求的，各个worker进程之间是平等的并且相互独立，处理请求的机会也是一样的。<br>我们现在作为管理员，只需要通过给master进程发送信号就可以来控制Nginx,这个时候我们需要有两个前提条件，一个是要操作的master进程，一个是信号。</p><h5 id="获取进程ID"><a href="#获取进程ID" class="headerlink" title="获取进程ID"></a>获取进程ID</h5><ul><li>通过 <code>ps -ef | grep nginx</code></li><li>nginx的<code>./configure</code>的配置参数的时候，有一个参数是<code>--pid-path=PATH</code>默认是<code>/usr/local/nginx/logs/nginx.pid</code>,所以可以通过查看该文件来获取nginx的master进程ID</li></ul><h4 id="信号控制"><a href="#信号控制" class="headerlink" title="信号控制"></a>信号控制</h4><h5 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h5><table><thead><tr><th>信号</th><th>作用</th></tr></thead><tbody><tr><td>TERM/INT</td><td>立即关闭整个服务</td></tr><tr><td>QUIT</td><td>“优雅”地关闭整个服务</td></tr><tr><td>HUP</td><td>重读配置文件并使用服务对新配置项生效</td></tr><tr><td>USR1</td><td>重新打开日志文件，可以用来进行日志切割</td></tr><tr><td>USR2</td><td>平滑升级到最新版的nginx</td></tr><tr><td>WINCH</td><td>所有子进程不在接收处理新连接，相当于给work进程发送QUIT指令</td></tr></tbody></table><p>调用命令为<code>kill -signal PID</code></p><p>signal:即为信号；PID即为获取到的master线程ID</p><ol><li>发送TERM/INT信号给master进程，会将Nginx服务立即关闭。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> -<span class="token environment constant">TERM</span> PID / 等同于kill -<span class="token environment constant">TERM</span> <span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> /usr/local/nginx/logs/nginx.pid<span class="token variable">`</span></span> 其实就是传入`<span class="token variable"><span class="token variable">`</span>内的结果<span class="token function">kill</span> -INT PID / <span class="token function">kill</span> -INT <span class="token variable">`</span></span><span class="token function">cat</span> /usr/local/nginx/logs/nginx.pid`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>发送QUIT信号给master进程，master进程会控制所有的work进程不再接收新的请求，等所有请求处理完后，在把进程都关闭掉。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> -QUIT PID / <span class="token function">kill</span> -<span class="token environment constant">TERM</span> <span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> /usr/local/nginx/logs/nginx.pid<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>发送HUP信号给master进程，master进程会把控制旧的work进程不再接收新的请求，等处理完请求后将旧的work进程关闭掉，然后根据nginx的配置文件重新启动新的work进程</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> -HUP PID / <span class="token function">kill</span> -<span class="token environment constant">TERM</span> <span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> /usr/local/nginx/logs/nginx.pid<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>发送USR1信号给master进程，告诉Nginx重新开启日志文件</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> -USR1 PID / <span class="token function">kill</span> -<span class="token environment constant">TERM</span> <span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> /usr/local/nginx/logs/nginx.pid<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li>发送USR2信号给master进程，告诉master进程要平滑升级，这个时候，会重新开启对应的master进程和work进程，整个系统中将会有两个master进程，并且新的master进程的PID会被记录在<code>/usr/local/nginx/logs/nginx.pid</code>而之前的旧的master进程PID会被记录在<code>/usr/local/nginx/logs/nginx.pid.oldbin</code>文件中，接着再次发送QUIT信号给旧的master进程，让其处理完请求后再进行关闭</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> -USR2 PID / <span class="token function">kill</span> -USR2 <span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> /usr/local/nginx/logs/nginx.pid<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> -QUIT PID / <span class="token function">kill</span> -QUIT <span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> /usr/local/nginx/logs/nginx.pid.oldbin<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li>发送WINCH信号给master进程,让master进程控制不让所有的work进程在接收新的请求了，请求处理完后关闭work进程。注意master进程不会被关闭掉</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> -WINCH PID /kill -WINCH<span class="token variable"><span class="token variable">`</span><span class="token function">cat</span> /usr/local/nginx/logs/nginx.pid<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="命令行控制"><a href="#命令行控制" class="headerlink" title="命令行控制"></a>命令行控制</h4><p>此方式是通过Nginx安装目录下的sbin下的可执行文件nginx来进行Nginx状态的控制，我们可以通过<code>nginx -h</code>来查看都有哪些参数可以用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@192 sbin<span class="token punctuation">]</span><span class="token comment"># ./nginx -h</span>nginx version: nginx/1.16.1Usage: nginx <span class="token punctuation">[</span>-?hvVtTq<span class="token punctuation">]</span> <span class="token punctuation">[</span>-s signal<span class="token punctuation">]</span> <span class="token punctuation">[</span>-c filename<span class="token punctuation">]</span> <span class="token punctuation">[</span>-p prefix<span class="token punctuation">]</span> <span class="token punctuation">[</span>-g directives<span class="token punctuation">]</span>Options:  -?,-h         <span class="token builtin class-name">:</span> this <span class="token builtin class-name">help</span>  -v            <span class="token builtin class-name">:</span> show version and <span class="token builtin class-name">exit</span>  -V            <span class="token builtin class-name">:</span> show version and configure options <span class="token keyword">then</span> <span class="token builtin class-name">exit</span>  -t            <span class="token builtin class-name">:</span> <span class="token builtin class-name">test</span> configuration and <span class="token builtin class-name">exit</span>  -T            <span class="token builtin class-name">:</span> <span class="token builtin class-name">test</span> configuration, dump it and <span class="token builtin class-name">exit</span>  -q            <span class="token builtin class-name">:</span> suppress non-error messages during configuration testing  -s signal     <span class="token builtin class-name">:</span> send signal to a master process: stop, quit, reopen, reload  -p prefix     <span class="token builtin class-name">:</span> <span class="token builtin class-name">set</span> prefix path <span class="token punctuation">(</span>default: /usr/local/nginx/<span class="token punctuation">)</span>  -c filename   <span class="token builtin class-name">:</span> <span class="token builtin class-name">set</span> configuration <span class="token function">file</span> <span class="token punctuation">(</span>default: /usr/local/nginx/conf/nginx.conf<span class="token punctuation">)</span>  -g directives <span class="token builtin class-name">:</span> <span class="token builtin class-name">set</span> global directives out of configuration <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>-?和-h:显示帮助信息<br>-v:打印版本号信息并退出<br>-V:打印版本号信息和配置信息并退出<br>-t:测试nginx的配置文件语法是否正确并退出<br>-T:测试nginx的配置文件语法是否正确并列出用到的配置文件信息然后退出<br>-q:在配置测试期间禁止显示非错误消息<br>-s:signal信号，后面可以跟 ：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stop<span class="token punctuation">[</span>快速关闭，类似于<span class="token environment constant">TERM</span>/INT信号的作用<span class="token punctuation">]</span>quit<span class="token punctuation">[</span>优雅的关闭，类似于QUIT信号的作用<span class="token punctuation">]</span> reopen<span class="token punctuation">[</span>重新打开日志文件类似于USR1信号的作用<span class="token punctuation">]</span> reload<span class="token punctuation">[</span>类似于HUP信号的作用<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>-p:prefix，指定Nginx的prefix路径，(默认为: /usr/local/nginx/)<br>-c:filename,指定Nginx的配置文件路径,(默认为: conf/nginx.conf)<br>-g:用来补充Nginx配置文件，向Nginx服务指定启动时应用全局的配置</p><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>如果想对Nginx的版本进行更新，或者要应用一些新的模块，最简单的做法就是停止当前的Nginx服务，然后开启新的Nginx服务。但是这样会导致在一段时间内，用户是无法访问服务器。为了解决这个问题，我们就需要用到Nginx服务器提供的平滑升级功能。</p><h5 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h5><p>（1）先准备两个版本的Nginx分别是 1.14.2和1.16.1</p><p>（2）使用Nginx源码安装的方式将1.14.2版本安装成功并正确访问</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">进入安装目录./configure<span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（3）将Nginx1.16.1进行参数配置和编译，不需要进行安装。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">进入安装目录./configure<span class="token function">make</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="方案一-使用Nginx服务信号进行升级"><a href="#方案一-使用Nginx服务信号进行升级" class="headerlink" title="方案一:使用Nginx服务信号进行升级"></a>方案一:使用Nginx服务信号进行升级</h4><p>第一步:将1.14.2版本的sbin目录下的nginx进行备份</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/nginx/sbin<span class="token function">mv</span> nginx nginxold<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二步:将Nginx1.16.1安装目录编译后的objs目录下的nginx文件，拷贝到原来<code>/usr/local/nginx/sbin</code>目录下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/nginx/core/nginx-1.16.1/objs<span class="token function">cp</span> nginx /usr/local/nginx/sbin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第三步:发送信号USR2给Nginx的1.14.2版本对应的master进程</p><p>第四步:发送信号QUIT给Nginx的1.14.2版本对应的master进程</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> -USR2<span class="token variable"><span class="token variable">`</span>/usr/local/logs/nginx.pid.oldbin<span class="token variable">`</span></span><span class="token function">kill</span> -QUIT <span class="token variable"><span class="token variable">`</span>/usr/local/logs/nginx.pid.oldbin<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="方案二-使用Nginx安装目录的make命令完成升级"><a href="#方案二-使用Nginx安装目录的make命令完成升级" class="headerlink" title="方案二:使用Nginx安装目录的make命令完成升级"></a>方案二:使用Nginx安装目录的make命令完成升级</h4><p>第一步:将1.14.2版本的sbin目录下的nginx进行备份</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/nginx/sbin<span class="token function">mv</span> nginx nginxold<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二步:将Nginx1.16.1安装目录编译后的objs目录下的nginx文件，拷贝到原来<code>/usr/local/nginx/sbin</code>目录下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/nginx/core/nginx-1.16.1/objs<span class="token function">cp</span> nginx /usr/local/nginx/sbin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第三步:进入到安装目录，执行<code>make upgrade</code></p><p>第四步:查看是否更新成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./nginx -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx安装</title>
      <link href="/2021/07/25/Nginx/Nginx%E5%AE%89%E8%A3%85/"/>
      <url>/2021/07/25/Nginx/Nginx%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="Nginx安装方式介绍"><a href="#Nginx安装方式介绍" class="headerlink" title="Nginx安装方式介绍"></a>Nginx安装方式介绍</h3><p>Nginx的安装方式有两种分别是:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">通过Nginx源码通过Nginx源码简单安装 <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>通过Nginx源码复杂安装 <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>通过yum安装 <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果通过Nginx源码安装需要提前准备的内容：</p><h5 id="GCC编译器"><a href="#GCC编译器" class="headerlink" title="GCC编译器"></a>GCC编译器</h5><p>Nginx是使用C语言编写的程序，因此想要运行Nginx就需要安装一个编译工具。GCC就是一个开源的编译器集合，用于处理各种各样的语言，其中就包含了C语言。</p><p>使用命令<code>yum install -y gcc</code>来安装</p><p>安装成功后，可以通过<code>gcc --version</code>来查看gcc是否安装成功</p><h5 id="PCRE"><a href="#PCRE" class="headerlink" title="PCRE"></a>PCRE</h5><p>Nginx在编译过程中需要使用到PCRE库（perl Compatible Regular Expressoin 兼容正则表达式库)，因为在Nginx的Rewrite模块和http核心模块都会使用到PCRE正则表达式语法。</p><p>可以使用命令<code>yum install -y pcre pcre-devel</code>来进行安装</p><p>安装成功后，可以通过<code>rpm -qa pcre pcre-devel</code>来查看是否安装成功</p><h5 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h5><p>zlib库提供了开发人员的压缩算法，在Nginx的各个模块中需要使用gzip压缩，所以我们也需要提前安装其库及源代码zlib和zlib-devel</p><p>可以使用命令<code>yum install -y zlib zlib-devel</code>来进行安装</p><p>安装成功后，可以通过<code>rpm -qa zlib zlib-devel</code>来查看是否安装成功</p><h5 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h5><p>OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包进行安全通信，并且避免被窃听。</p><p>SSL:Secure Sockets Layer安全套接协议的缩写，可以在Internet上提供秘密性传输，其目标是保证两个应用间通信的保密性和可靠性。在Nginx中，如果服务器需要提供安全网页时就需要用到OpenSSL库，所以我们需要对OpenSSL的库文件及它的开发安装包进行一个安装。</p><p>可以使用命令<code>yum install -y openssl openssl-devel</code>来进行安装</p><p>安装成功后，可以通过<code>rpm -qa openssl openssl-devel</code>来查看是否安装成功</p><p>上述命令，一个个来的话比较麻烦，我们也可以通过一条命令来进行安装</p><p><code>yum install -y gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel</code>进行全部安装。</p><h4 id="方案一：Nginx的源码简单安装"><a href="#方案一：Nginx的源码简单安装" class="headerlink" title="方案一：Nginx的源码简单安装"></a>方案一：Nginx的源码简单安装</h4><p>(1)进入官网查找需要下载版本的链接地址，然后使用wget命令进行下载</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> http://nginx.org/download/nginx-1.16.1.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(2)建议大家将下载的资源进行包管理</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p nginx/core<span class="token function">mv</span> nginx-1.16.1.tar.gz nginx/core<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>(3)解压缩</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> -xzf nginx-1.16.1.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(4)进入资源文件中，发现configure</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(5)编译</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(6)安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="方案二：yum安装"><a href="#方案二：yum安装" class="headerlink" title="方案二：yum安装"></a>方案二：yum安装</h4><p>使用源码进行简单安装，我们会发现安装的过程比较繁琐，需要提前准备GCC编译器、PCRE兼容正则表达式库、zlib压缩库、OpenSSL安全通信的软件库包，然后才能进行Nginx的安装。</p><p>（1）安装yum-utils</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> yum  <span class="token function">install</span> -y yum-utils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）添加yum源文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/yum.repos.d/nginx.repo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>nginx-stable<span class="token punctuation">]</span><span class="token assign-left variable">name</span><span class="token operator">=</span>nginx stable repo<span class="token assign-left variable">baseurl</span><span class="token operator">=</span>http://nginx.org/packages/centos/<span class="token variable">$releasever</span>/<span class="token variable">$basearch</span>/<span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">1</span><span class="token assign-left variable">enabled</span><span class="token operator">=</span><span class="token number">1</span><span class="token assign-left variable">gpgkey</span><span class="token operator">=</span>https://nginx.org/keys/nginx_signing.key<span class="token assign-left variable">module_hotfixes</span><span class="token operator">=</span>true<span class="token punctuation">[</span>nginx-mainline<span class="token punctuation">]</span><span class="token assign-left variable">name</span><span class="token operator">=</span>nginx mainline repo<span class="token assign-left variable">baseurl</span><span class="token operator">=</span>http://nginx.org/packages/mainline/centos/<span class="token variable">$releasever</span>/<span class="token variable">$basearch</span>/<span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">1</span><span class="token assign-left variable">enabled</span><span class="token operator">=</span><span class="token number">0</span><span class="token assign-left variable">gpgkey</span><span class="token operator">=</span>https://nginx.org/keys/nginx_signing.key<span class="token assign-left variable">module_hotfixes</span><span class="token operator">=</span>true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）查看是否安装成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum list <span class="token operator">|</span> <span class="token function">grep</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（4）使用yum进行安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yun <span class="token function">install</span> -y nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（5）查看nginx的安装位置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">whereis</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（6）启动测试</p><h4 id="方案三-Nginx的源码复杂安装"><a href="#方案三-Nginx的源码复杂安装" class="headerlink" title="方案三:Nginx的源码复杂安装"></a>方案三:Nginx的源码复杂安装</h4><p>这种方式和简单的安装配置不同的地方在第一步，通过<code>./configure</code>来对编译参数进行设置，需要我们手动来指定。那么都有哪些参数可以进行设置，接下来我们进行一个详细的说明。</p><p>PATH:是和路径相关的配置信息</p><p>with:是启动模块，默认是关闭的</p><p>without:是关闭模块，默认是开启的</p><p>我们先来认识一些简单的路径配置已经通过这些配置来完成一个简单的编译：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">--prefix<span class="token operator">=</span><span class="token environment constant">PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指向Nginx的安装目录，默认值为/usr/local/nginx   </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">--sbin-path<span class="token operator">=</span><span class="token environment constant">PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指向(执行)程序文件(nginx)的路径,默认值为<prefix>/sbin/nginx</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">--modules-path<span class="token operator">=</span><span class="token environment constant">PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指向Nginx动态模块安装目录，默认值为<prefix>/modules</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">--conf-path<span class="token operator">=</span><span class="token environment constant">PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指向配置文件(nginx.conf)的路径,默认值为<prefix>/conf/nginx.conf</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">--error-log-path<span class="token operator">=</span><span class="token environment constant">PATH</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指向错误日志文件的路径,默认值为<prefix>/logs/error.log</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">--http-log-path<span class="token operator">=</span><span class="token environment constant">PATH</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指向访问日志文件的路径,默认值为<prefix>/logs/access.log</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">--pid-path<span class="token operator">=</span><span class="token environment constant">PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指向Nginx启动后进行ID的文件路径，默认值为<prefix>/logs/nginx.pid</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">--lock-path<span class="token operator">=</span><span class="token environment constant">PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指向Nginx锁文件的存放路径,默认值为<prefix>/logs/nginx.lock</p><p>要想使用可以进入解压目录，通过如下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure --prefix<span class="token operator">=</span>/usr/local/nginx <span class="token punctuation">\</span>--sbin-path<span class="token operator">=</span>/usr/local/nginx/sbin/nginx <span class="token punctuation">\</span>--modules-path<span class="token operator">=</span>/usr/local/nginx/modules <span class="token punctuation">\</span>--conf-path<span class="token operator">=</span>/usr/local/nginx/conf/nginx.conf <span class="token punctuation">\</span>--error-log-path<span class="token operator">=</span>/usr/local/nginx/logs/error.log <span class="token punctuation">\</span>--http-log-path<span class="token operator">=</span>/usr/local/nginx/logs/access.log <span class="token punctuation">\</span>--pid-path<span class="token operator">=</span>/usr/local/nginx/logs/nginx.pid <span class="token punctuation">\</span>--lock-path<span class="token operator">=</span>/usr/local/nginx/logs/nginx.lock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在使用上述命令之前，需要将之前服务器已经安装的nginx进行卸载，卸载的步骤分为三步骤：</p><p>步骤一：需要将nginx的进程关闭</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./nginx -s stop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>步骤二:将安装的nginx进行删除</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> -rf /usr/local/nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>步骤三:将安装包之前编译的环境清除掉</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入源码目录，执行 <code>make &amp;&amp; make install</code>;若无 make 命令，先安装如下工具：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y <span class="token function">install</span> gcc automake autoconf libtool <span class="token function">make</span>yum <span class="token function">install</span> gcc gcc-c++<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装后进入 nginx/sbin 目录， 执行 <code>./nginx</code> 启动。</p><h3 id="Nginx配置成系统服务"><a href="#Nginx配置成系统服务" class="headerlink" title="Nginx配置成系统服务"></a>Nginx配置成系统服务</h3><p>把Nginx应用服务设置成为系统服务，方便对Nginx服务的启动和停止等相关操作，具体实现步骤:</p><p>(1) 在<code>/usr/lib/systemd/system</code>目录下添加nginx.service,内容如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /usr/lib/systemd/system/nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>Unit<span class="token punctuation">]</span><span class="token assign-left variable">Description</span><span class="token operator">=</span>nginx web <span class="token function">service</span><span class="token assign-left variable">Documentation</span><span class="token operator">=</span>http://nginx.org/en/docs/<span class="token assign-left variable">After</span><span class="token operator">=</span>network.target<span class="token punctuation">[</span>Service<span class="token punctuation">]</span><span class="token assign-left variable">Type</span><span class="token operator">=</span>forking<span class="token assign-left variable">PIDFile</span><span class="token operator">=</span>/usr/local/nginx/logs/nginx.pid<span class="token assign-left variable">ExecStartPre</span><span class="token operator">=</span>/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf<span class="token assign-left variable">ExecStart</span><span class="token operator">=</span>/usr/local/nginx/sbin/nginx<span class="token assign-left variable">ExecReload</span><span class="token operator">=</span>/usr/local/nginx/sbin/nginx -s reload<span class="token assign-left variable">ExecStop</span><span class="token operator">=</span>/usr/local/nginx/sbin/nginx -s stop<span class="token assign-left variable">PrivateTmp</span><span class="token operator">=</span>true<span class="token punctuation">[</span>Install<span class="token punctuation">]</span><span class="token assign-left variable">WantedBy</span><span class="token operator">=</span>default.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2)添加完成后如果权限有问题需要进行权限设置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> <span class="token number">755</span> /usr/lib/systemd/system/nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(3)使用系统命令来操作Nginx服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">启动: systemctl start nginx停止: systemctl stop nginx重启: systemctl restart nginx重新加载配置文件: systemctl reload nginx查看nginx状态: systemctl status nginx开机启动: systemctl <span class="token builtin class-name">enable</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Nginx命令配置到系统环境"><a href="#Nginx命令配置到系统环境" class="headerlink" title="Nginx命令配置到系统环境"></a>Nginx命令配置到系统环境</h3><p>前面我们介绍过Nginx安装目录下的二级制可执行文件<code>nginx</code>的很多命令，要想使用这些命令前提是需要进入sbin目录下才能使用，很不方便，如何去优化，我们可以将该二进制可执行文件加入到系统的环境变量，这样的话在任何目录都可以使用nginx对应的相关命令。具体实现步骤如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/local/nginx/sbin/nginx -V<span class="token builtin class-name">cd</span> /usr/local/nginx/sbin  nginx -V如何优化？？？<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(1)修改<code>/etc/profile</code>文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile在最后一行添加<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/usr/local/nginx/sbin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(2)使之立即生效</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(3)执行nginx命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx -V<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sed详解</title>
      <link href="/2021/07/25/Linux/sed%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/07/25/Linux/sed%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>sed 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p><h3 id="sed使用参数"><a href="#sed使用参数" class="headerlink" title="sed使用参数"></a>sed使用参数</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span> <span class="token function">sed</span> <span class="token punctuation">[</span>-nefr<span class="token punctuation">]</span> <span class="token punctuation">[</span>动作<span class="token punctuation">]</span>选项与参数：-n ：使用安静<span class="token punctuation">(</span>silent<span class="token punctuation">)</span>模式。在一般 <span class="token function">sed</span> 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行<span class="token punctuation">(</span>或者动作<span class="token punctuation">)</span>才会被列出来。-e ：直接在命令列模式上进行 <span class="token function">sed</span> 的动作编辑；-f ：直接将 <span class="token function">sed</span> 的动作写在一个文件内， -f filename 则可以运行 filename 内的 <span class="token function">sed</span> 动作；-r ：sed 的动作支持的是延伸型正规表示法的语法。<span class="token punctuation">(</span>默认是基础正规表示法语法<span class="token punctuation">)</span>-i ：直接修改读取的文件内容，而不是输出到终端。动作说明： <span class="token punctuation">[</span>n1<span class="token punctuation">[</span>,n2<span class="token punctuation">]</span><span class="token punctuation">]</span>functionn1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 <span class="token number">10</span> 到 <span class="token number">20</span> 行之间进行的，则『 <span class="token number">10,20</span><span class="token punctuation">[</span>动作行为<span class="token punctuation">]</span> 』function：a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现<span class="token punctuation">(</span>目前的下一行<span class="token punctuation">)</span>～c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现<span class="token punctuation">(</span>目前的上一行<span class="token punctuation">)</span>；p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 <span class="token function">sed</span> -n 一起运行～s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 <span class="token number">1</span>,20s/old/new/g 就是啦！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="以行为单位的新增-删除"><a href="#以行为单位的新增-删除" class="headerlink" title="以行为单位的新增/删除"></a>以行为单位的新增/删除</h3><p>将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span> <span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'2,5d'</span><span class="token number">1</span> root:x:0:0:root:/root:/bin/bash<span class="token number">6</span> sync:x:5:0:sync:/sbin:/bin/sync<span class="token number">7</span> shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown<span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token punctuation">(</span>后面省略<span class="token punctuation">)</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sed 的动作为 ‘2,5d’ ，那个 d 就是删除！因为 2-5 行给他删除了，所以显示的数据就没有 2-5 行罗～ 另外，注意一下，原本应该是要下达 sed -e 才对，没有 -e 也行啦！同时也要注意的是， sed 后面接的动作，请务必以 ‘’ 两个单引号括住喔！</p><p>只要删除第 2 行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'2d'</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要删除第 3 到最后一行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'3,$d'</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在第二行后(亦即是加在第三行)加上『drink tea?』字样！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span> <span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'2a drink tea'</span><span class="token number">1</span> root:x:0:0:root:/root:/bin/bash<span class="token number">2</span> bin:x:1:1:bin:/bin:/sbin/nologindrink tea<span class="token number">3</span> daemon:x:2:2:daemon:/sbin:/sbin/nologin<span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token punctuation">(</span>后面省略<span class="token punctuation">)</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那如果是要在第二行前</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'2i drink tea'</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是要增加两行以上，在第二行后面加入两行字，例如『Drink tea or …..』与『drink beer?』</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span> <span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'2a Drink tea or ......\> drink beer ?'</span><span class="token number">1</span> root:x:0:0:root:/root:/bin/bash<span class="token number">2</span> bin:x:1:1:bin:/bin:/sbin/nologinDrink tea or <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>drink beer ?<span class="token number">3</span> daemon:x:2:2:daemon:/sbin:/sbin/nologin<span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token punctuation">(</span>后面省略<span class="token punctuation">)</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每一行之间都必须要以反斜杠<code>\</code>来进行新行的添加！所以，上面的例子中，我们可以发现在第一行的最后面就有 <code>\</code> 存在。</p><h3 id="以行为单位的替换与显示"><a href="#以行为单位的替换与显示" class="headerlink" title="以行为单位的替换与显示"></a>以行为单位的替换与显示</h3><p> 将第2-5行的内容取代成为『No 2-5 number』呢？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span> <span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'2,5c No 2-5 number'</span><span class="token number">1</span> root:x:0:0:root:/root:/bin/bashNo <span class="token number">2</span>-5 number<span class="token number">6</span> sync:x:5:0:sync:/sbin:/bin/sync<span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token punctuation">(</span>后面省略<span class="token punctuation">)</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>透过这个方法我们就能够将数据整行取代了！</p><p>仅列出 /etc/passwd 文件内的第 5-7 行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span> <span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> -n <span class="token string">'5,7p'</span><span class="token number">5</span> lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin<span class="token number">6</span> sync:x:5:0:sync:/sbin:/bin/sync<span class="token number">7</span> shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以透过这个 sed 的以行为单位的显示功能， 就能够将某一个文件内的某些行号选择出来显示。</p><h3 id="数据的搜寻并显示"><a href="#数据的搜寻并显示" class="headerlink" title="数据的搜寻并显示"></a>数据的搜寻并显示</h3><p>搜索 /etc/passwd有root关键字的行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'/root/p'</span><span class="token number">1</span>  root:x:0:0:root:/root:/bin/bash<span class="token number">1</span>  root:x:0:0:root:/root:/bin/bash<span class="token number">2</span>  daemon:x:1:1:daemon:/usr/sbin:/bin/sh<span class="token number">3</span>  bin:x:2:2:bin:/bin:/bin/sh<span class="token number">4</span>  sys:x:3:3:sys:/dev:/bin/sh<span class="token number">5</span>  sync:x:4:65534:sync:/bin:/bin/sync<span class="token punctuation">..</span><span class="token punctuation">..</span>下面忽略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果root找到，除了输出所有行，还会输出匹配行。</p><p>使用-n的时候将只打印包含模板的行。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> -n <span class="token string">'/root/p'</span><span class="token number">1</span>  root:x:0:0:root:/root:/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="数据的搜寻并删除"><a href="#数据的搜寻并删除" class="headerlink" title="数据的搜寻并删除"></a>数据的搜寻并删除</h3><p>删除/etc/passwd所有包含root的行，其他行输出</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span>  <span class="token string">'/root/d'</span><span class="token number">2</span>  daemon:x:1:1:daemon:/usr/sbin:/bin/sh<span class="token number">3</span>  bin:x:2:2:bin:/bin:/bin/sh<span class="token punctuation">..</span><span class="token punctuation">..</span>下面忽略<span class="token comment">#第一行的匹配root已经删除了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据的搜寻并执行命令"><a href="#数据的搜寻并执行命令" class="headerlink" title="数据的搜寻并执行命令"></a>数据的搜寻并执行命令</h3><p>找到匹配模式eastern的行后，</p><p>搜索/etc/passwd,找到root对应的行，执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> -n <span class="token string">'/root/&#123;s/bash/blueshell/;p&#125;'</span><span class="token number">1</span>  root:x:0:0:root:/root:/bin/blueshell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果只替换/etc/passwd的第一个bash关键字为blueshell，就退出</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nl</span> /etc/passwd <span class="token operator">|</span> <span class="token function">sed</span> -n <span class="token string">'/bash/&#123;s/bash/blueshell/;p;q&#125;'</span>    <span class="token number">1</span>  root:x:0:0:root:/root:/bin/blueshell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最后的q是退出。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk详解</title>
      <link href="/2021/07/25/Linux/awk%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/07/25/Linux/awk%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> <span class="token string">'&#123;pattern + action&#125;'</span> <span class="token punctuation">&#123;</span>filenames<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。</p><h3 id="入门实例"><a href="#入门实例" class="headerlink" title="入门实例"></a>入门实例</h3><p>假设last -n 5的输出如下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span> last -n <span class="token number">5</span> <span class="token operator">&lt;=</span><span class="token operator">=</span>仅取出前五行root     pts/1   <span class="token number">192.168</span>.1.100  Tue Feb <span class="token number">10</span> <span class="token number">11</span>:21   still logged <span class="token keyword">in</span>root     pts/1   <span class="token number">192.168</span>.1.100  Tue Feb <span class="token number">10</span> 00:46 - 02:28  <span class="token punctuation">(</span>01:41<span class="token punctuation">)</span>root     pts/1   <span class="token number">192.168</span>.1.100  Mon Feb  <span class="token number">9</span> <span class="token number">11</span>:41 - <span class="token number">18</span>:30  <span class="token punctuation">(</span>06:48<span class="token punctuation">)</span>dmtsai   pts/1   <span class="token number">192.168</span>.1.100  Mon Feb  <span class="token number">9</span> <span class="token number">11</span>:41 - <span class="token number">11</span>:41  <span class="token punctuation">(</span>00:00<span class="token punctuation">)</span>root     tty1                   Fri Sep  <span class="token number">5</span> <span class="token number">14</span>:09 - <span class="token number">14</span>:10  <span class="token punctuation">(</span>00:01<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="五级标题如果只是显示最近登录的5个帐号"><a href="#五级标题如果只是显示最近登录的5个帐号" class="headerlink" title="五级标题如果只是显示最近登录的5个帐号"></a>五级标题如果只是显示最近登录的5个帐号</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">last -n <span class="token number">5</span> <span class="token operator">|</span> <span class="token function">awk</span>  <span class="token string">'&#123;print $1&#125;'</span>rootrootrootdmtsairoot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>awk工作流程是这样的：读入有 <code>\n</code> 换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”,所以$1表示登录用户，$3表示登录用户ip,以此类推。</p><h5 id="五级标题如果只是显示-etc-passwd的账户"><a href="#五级标题如果只是显示-etc-passwd的账户" class="headerlink" title="五级标题如果只是显示/etc/passwd的账户"></a>五级标题如果只是显示/etc/passwd的账户</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /etc/passwd <span class="token operator">|</span><span class="token function">awk</span>  -F <span class="token string">':'</span>  <span class="token string">'&#123;print $1&#125;'</span>  rootdaemonbinsys这种是awk+action的示例，每行都会执行action<span class="token punctuation">&#123;</span>print <span class="token variable">$1</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>-F</code> 指定域分隔符为 <code>:</code>。</strong></p><h5 id="五级标题如果只是显示-etc-passwd的账户和账户对应的shell-而账户与shell之间以tab键分割"><a href="#五级标题如果只是显示-etc-passwd的账户和账户对应的shell-而账户与shell之间以tab键分割" class="headerlink" title="五级标题如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以tab键分割"></a>五级标题如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以tab键分割</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /etc/passwd <span class="token operator">|</span><span class="token function">awk</span>  -F <span class="token string">':'</span>  <span class="token string">'&#123;print $1"\t"$7&#125;'</span>root    /bin/bashdaemon  /bin/shbin     /bin/shsys     /bin/sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以逗号分割,而且在所有行添加列名name,shell,在最后一行添加”blue,/bin/nosh”。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /etc/passwd <span class="token operator">|</span><span class="token function">awk</span>  -F <span class="token string">':'</span>  <span class="token string">'BEGIN &#123;print "name,shell"&#125;  &#123;print $1","$7&#125; END &#123;print "blue,/bin/nosh"&#125;'</span>name,shellroot,/bin/bashdaemon,/bin/shbin,/bin/shsys,/bin/sh<span class="token punctuation">..</span><span class="token punctuation">..</span>blue,/bin/nosh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="搜索-etc-passwd有root关键字的所有行"><a href="#搜索-etc-passwd有root关键字的所有行" class="headerlink" title="搜索/etc/passwd有root关键字的所有行"></a>搜索/etc/passwd有root关键字的所有行</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> -F: <span class="token string">'/root/'</span> /etc/passwdroot:x:0:0:root:/root:/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这种是pattern的使用示例，匹配了pattern(这里是root)的行才会执行action(没有指定action，默认输出每行的内容)。</p><p>搜索支持正则，例如找root开头的: awk -F: ‘/^root/‘ /etc/passwd</p><p>搜索/etc/passwd有root关键字的所有行，并显示对应的shell</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> -F: <span class="token string">'/root/&#123;print $7&#125;'</span> /etc/passwd             /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 这里指定了action{print $7}</p><p>##awk内置变量<br>awk有许多内置变量用来设置环境信息，这些变量可以被改变，下面给出了最常用的一些变量。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ARGC               命令行参数个数ARGV               命令行参数排列ENVIRON            支持队列中系统环境变量的使用FILENAME           awk浏览的文件名FNR                浏览文件的记录数FS                 设置输入域分隔符，等价于命令行 -F选项NF                 浏览记录的域的个数NR                 已读的记录数OFS                输出域分隔符ORS                输出记录分隔符RS                 控制记录分隔符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>统计/etc/passwd:文件名，每行的行号，每行的列数，对应的完整行内容:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span>  -F <span class="token string">':'</span>  <span class="token string">'&#123;print "filename:" FILENAME ",linenumber:" NR ",columns:" NF ",linecontent:"$0&#125;'</span> /etc/passwdfilename:/etc/passwd,linenumber:1,columns:7,linecontent:root:x:0:0:root:/root:/bin/bashfilename:/etc/passwd,linenumber:2,columns:7,linecontent:daemon:x:1:1:daemon:/usr/sbin:/bin/shfilename:/etc/passwd,linenumber:3,columns:7,linecontent:bin:x:2:2:bin:/bin:/bin/shfilename:/etc/passwd,linenumber:4,columns:7,linecontent:sys:x:3:3:sys:/dev:/bin/sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="awk编程"><a href="#awk编程" class="headerlink" title="awk编程"></a>awk编程</h3><h5 id="变量和赋值"><a href="#变量和赋值" class="headerlink" title="变量和赋值"></a>变量和赋值</h5><p>除了awk的内置变量，awk还可以自定义变量。</p><p>下面统计/etc/passwd的账户人数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> <span class="token string">'&#123;count++;print $0;&#125; END&#123;print "user count is ", count&#125;'</span> /etc/passwdroot:x:0:0:root:/root:/bin/bash<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>user count is  <span class="token number">40</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>count是自定义变量。之前的action{}里都是只有一个print,其实print只是一个语句，而action{}可以有多个语句，以;号隔开。</p><p>这里没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">awk</span> <span class="token string">'BEGIN &#123;count=0;print "[start]user count is ", count&#125; &#123;count=count+1;print $0;&#125; END&#123;print "[end]user count is ", count&#125;'</span> /etc/passwd<span class="token punctuation">[</span>start<span class="token punctuation">]</span>user count is  <span class="token number">0</span>root:x:0:0:root:/root:/bin/bash<span class="token punctuation">..</span>.<span class="token punctuation">[</span>end<span class="token punctuation">]</span>user count is  <span class="token number">40</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>统计某个文件夹下的文件占用的字节数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> -l <span class="token operator">|</span><span class="token function">awk</span> <span class="token string">'BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print "[end]size is ", size&#125;'</span><span class="token punctuation">[</span>end<span class="token punctuation">]</span>size is  <span class="token number">8657198</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果以M为单位显示:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> -l <span class="token operator">|</span><span class="token function">awk</span> <span class="token string">'BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print "[end]size is ", size/1024/1024,"M"&#125;'</span> <span class="token punctuation">[</span>end<span class="token punctuation">]</span>size is  <span class="token number">8.25889</span> M<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意，统计不包括文件夹的子目录。</p><h5 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">统计某个文件夹下的文件占用的字节数,过滤4096大小的文件<span class="token punctuation">(</span>一般都是文件夹<span class="token punctuation">)</span>:<span class="token function">ls</span> -l <span class="token operator">|</span><span class="token function">awk</span> <span class="token string">'BEGIN &#123;size=0;print "[start]size is ", size&#125; &#123;if($5!=4096)&#123;size=size+$5;&#125;&#125; END&#123;print "[end]size is ", size/1024/1024,"M"&#125;'</span> <span class="token punctuation">[</span>end<span class="token punctuation">]</span>size is  <span class="token number">8.22339</span> M<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>awk编程的内容极多，更多请参考 <a href="http://www.gnu.org/software/gawk/manual/gawk.html">http://www.gnu.org/software/gawk/manual/gawk.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务传播</title>
      <link href="/2021/07/25/Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/"/>
      <url>/2021/07/25/Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><ul><li>原子性(Atomicity)：事务是一系列原子操作，要么全部成功，要么全部失败。</li><li>一致性(Consistency): 一旦完成(不管是成功还是失败)，确保它所在的一系列业务状态保持一致，状态都是成功，或者都是失败，不能一部分成功一部分失败。</li><li>隔离性(Isolation): 不同事务同时进行某项业务，处理相同的数据时候，需要保证事务之间相互独立，互相之间数据不影响。</li><li>持久性(Durability)：一旦事务完成，无论发生什么系统性错误，事务执行后的数据都被持久化了，不会因为重启或其他操作对数据进行更改。</li></ul><h3 id="Spring中七种事务传播行为"><a href="#Spring中七种事务传播行为" class="headerlink" title="Spring中七种事务传播行为"></a>Spring中七种事务传播行为</h3><ol><li><code>PROPAGATION_REQUIRED</code>：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择</li><li><code>PROPAGATION_REQUIRES_NEW</code>：新建事务，如果当前存在事务，把当前事务挂起</li><li>PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行</li><li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li><li>PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常</li><li>PROPAGATION_MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常</li><li>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作</li></ol><p>Spring中事务的默认实现使用的是AOP，也就是代理的方式，如果大家在使用代码测试时，<strong>同一个Service类中的方法相互调用需要使用注入的对象来调用，不要直接使用this.方法名来调用</strong>，this.方法名调用是对象内部方法调用，不会通过Spring代理，也就是事务不会起作用</p><blockquote><p><a href="https://segmentfault.com/a/1190000013341344">https://segmentfault.com/a/1190000013341344</a> (该篇文章讲解非常仔细)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim常用快捷键</title>
      <link href="/2021/07/23/Linux/Vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2021/07/23/Linux/Vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><ul><li>jk上下移动 hl左右移动</li><li>ctrl-f 上翻一页； ctrl-b 下翻一页</li><li>ctrl-e、ctrl-u 屏幕滚动</li><li>^ 行首 $行尾</li><li>gg 文首，G文尾</li><li>2gg 跳转到第2行</li><li>gd 跳至当前光标所在的变量的声明处</li><li>b 单词词尾， e 单词词首</li><li>fx 在当前行中找x字符，找到了就跳转至；然后 <code>;</code> 重复上一个f命令，而不用重复的输入fx</li><li><code>*</code> 查找光标所在处的单词，向下查找; <code>#</code> 查找光标所在处的单词，向上查找</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>dd 删除当前行</li><li>dw 删除一个字</li></ul><h3 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h3><ul><li>yy 复制一行； nyy复制n行， p粘贴</li><li>行复制：<code>V</code>，移动光标选择多行，y确定，p粘贴</li><li>块复制：ctrl+v，移动光标选择快，y确定， p粘贴</li></ul><h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><ul><li>i 进入当前光标处， a当前光标下一个字符</li><li>I 光标为行首， A 光标为行尾</li><li>o 当前行之下插入一行， O 当前行之上插入一行</li></ul><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><ul><li>J 将下一行和当前行连接为一行</li><li>cc 删除当前行并进入编辑模式， cw 删除当前字并进入编辑模式， c$ 擦除从当前位置至行末的内容，并进入编辑模式</li><li>s 删除当前字符并进入编辑模式， S 删除光标所在行并进入编辑模式</li><li><strong>u 撤销， ctrl+r 重做</strong></li><li><strong>全部删除：</strong>按esc后，然后dG ，或者 <code>ggdG</code></li></ul><h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><ul><li><code>/pattern</code> 向后查找， <code>?pattern</code> 向前查找 <code>/\c...</code> 忽略大小写，加个<code>\c</code>前缀；找到后 n 选取下一个， N 选取上一个</li><li><code>:%s/old/new/g</code> 搜索整个文件，将所有的old替换为new，<code>:%s/old/new/gc</code> 搜索整个文件，每次都要你确认是否替换</li></ul><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><ul><li><code>:x</code> 和 <code>:wq</code> 保存并退出，后者在没实际更改时也会更新修改时间</li><li><code>:q</code> 和 <code>:q!</code> 退出，后者放弃更改，强制退出，前者会确认</li></ul><h3 id="自动排版"><a href="#自动排版" class="headerlink" title="自动排版"></a>自动排版</h3><p>在粘贴了一些代码之后，vim变得比较乱，只要执行 <code>gg=G</code> 就能搞定</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
